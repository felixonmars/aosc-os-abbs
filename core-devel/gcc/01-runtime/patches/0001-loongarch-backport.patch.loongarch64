From 36f8d97e0cd76a4d509366d7589bf8aa0d02d3b7 Mon Sep 17 00:00:00 2001
From: Xi Ruoyao <xry111@xry111.site>
Date: Wed, 6 Jul 2022 13:45:55 +0800
Subject: [PATCH 01/36] loongarch: add alternatives for idiv insns to improve
 code generation

Currently in the description of LoongArch integer division instructions,
the output is marked as earlyclobbered ('&').  It's necessary when
loongarch_check_zero_div_p() because clobbering operand 2 (divisor) will
make the checking for zero divisor impossible.

But, for -mno-check-zero-division (the default of GCC >= 12.2 for
optimized code), the output is not earlyclobbered at all.  And, the
read of operand 1 only occurs before clobbering the output.  So we make
three alternatives for an idiv instruction:

* (=r,r,r): For -mno-check-zero-division.
* (=&r,r,r): For -mcheck-zero-division.
* (=&r,0,r): For -mcheck-zero-division, to explicitly allow patterns
  like "div.d $a0, $a0, $a1".

gcc/ChangeLog:

	* config/loongarch/loongarch.cc (loongarch_check_zero_div_p):
	Remove static, for use in the machine description file.
	* config/loongarch/loongarch-protos.h:
	(loongarch_check_zero_div_p): Add prototype.
	* config/loongarch/loongarch.md (enabled): New attr.
	(*<optab><mode>3): Add (=r,r,r) and (=&r,0,r) alternatives for
	idiv.  Conditionally enable the alternatives using
	loongarch_check_zero_div_p.
	(<optab>di3_fake): Likewise.

gcc/testsuite/ChangeLog:

	* gcc.target/loongarch/div-1.c: New test.
	* gcc.target/loongarch/div-2.c: New test.
	* gcc.target/loongarch/div-3.c: New test.
---
 gcc/config/loongarch/loongarch-protos.h    |  1 +
 gcc/config/loongarch/loongarch.cc          |  2 +-
 gcc/config/loongarch/loongarch.md          | 28 +++++++++++++++-------
 gcc/testsuite/gcc.target/loongarch/div-1.c |  9 +++++++
 gcc/testsuite/gcc.target/loongarch/div-2.c |  9 +++++++
 gcc/testsuite/gcc.target/loongarch/div-3.c |  9 +++++++
 6 files changed, 49 insertions(+), 9 deletions(-)
 create mode 100644 gcc/testsuite/gcc.target/loongarch/div-1.c
 create mode 100644 gcc/testsuite/gcc.target/loongarch/div-2.c
 create mode 100644 gcc/testsuite/gcc.target/loongarch/div-3.c

diff --git a/gcc/config/loongarch/loongarch-protos.h b/gcc/config/loongarch/loongarch-protos.h
index 2144c2421ed..2287fd3763c 100644
--- a/gcc/config/loongarch/loongarch-protos.h
+++ b/gcc/config/loongarch/loongarch-protos.h
@@ -130,6 +130,7 @@ extern bool loongarch_symbol_binds_local_p (const_rtx);
 extern const char *current_section_name (void);
 extern unsigned int current_section_flags (void);
 extern bool loongarch_use_ins_ext_p (rtx, HOST_WIDE_INT, HOST_WIDE_INT);
+extern bool loongarch_check_zero_div_p (void);
 
 union loongarch_gen_fn_ptrs
 {
diff --git a/gcc/config/loongarch/loongarch.cc b/gcc/config/loongarch/loongarch.cc
index 5c9a33c14f7..8b0d7f459e0 100644
--- a/gcc/config/loongarch/loongarch.cc
+++ b/gcc/config/loongarch/loongarch.cc
@@ -2110,7 +2110,7 @@ loongarch_load_store_insns (rtx mem, rtx_insn *insn)
 
 /* Return true if we need to trap on division by zero.  */
 
-static bool
+bool
 loongarch_check_zero_div_p (void)
 {
   /* if -m[no-]check-zero-division is given explicitly.  */
diff --git a/gcc/config/loongarch/loongarch.md b/gcc/config/loongarch/loongarch.md
index 8f8412fba84..6bca2ed3993 100644
--- a/gcc/config/loongarch/loongarch.md
+++ b/gcc/config/loongarch/loongarch.md
@@ -110,6 +110,8 @@
 ;;
 ;; ....................
 
+(define_attr "enabled" "no,yes" (const_string "yes"))
+
 (define_attr "got" "unset,load"
   (const_string "unset"))
 
@@ -763,26 +765,36 @@
 })
 
 (define_insn "*<optab><mode>3"
-  [(set (match_operand:GPR 0 "register_operand" "=&r")
-	(any_div:GPR (match_operand:GPR 1 "register_operand" "r")
-		     (match_operand:GPR 2 "register_operand" "r")))]
+  [(set (match_operand:GPR 0 "register_operand" "=r,&r,&r")
+	(any_div:GPR (match_operand:GPR 1 "register_operand" "r,r,0")
+		     (match_operand:GPR 2 "register_operand" "r,r,r")))]
   ""
 {
   return loongarch_output_division ("<insn>.<d><u>\t%0,%1,%2", operands);
 }
   [(set_attr "type" "idiv")
-   (set_attr "mode" "<MODE>")])
+   (set_attr "mode" "<MODE>")
+   (set (attr "enabled")
+      (if_then_else
+	(match_test "!!which_alternative == loongarch_check_zero_div_p()")
+	(const_string "yes")
+	(const_string "no")))])
 
 (define_insn "<optab>di3_fake"
-  [(set (match_operand:SI 0 "register_operand" "=&r")
-	(any_div:SI (match_operand:DI 1 "register_operand" "r")
-		    (match_operand:DI 2 "register_operand" "r")))]
+  [(set (match_operand:SI 0 "register_operand" "=r,&r,&r")
+	(any_div:SI (match_operand:DI 1 "register_operand" "r,r,0")
+		    (match_operand:DI 2 "register_operand" "r,r,r")))]
   ""
 {
   return loongarch_output_division ("<insn>.w<u>\t%0,%1,%2", operands);
 }
   [(set_attr "type" "idiv")
-   (set_attr "mode" "SI")])
+   (set_attr "mode" "SI")
+   (set (attr "enabled")
+      (if_then_else
+	(match_test "!!which_alternative == loongarch_check_zero_div_p()")
+	(const_string "yes")
+	(const_string "no")))])
 
 ;; Floating point multiply accumulate instructions.
 
diff --git a/gcc/testsuite/gcc.target/loongarch/div-1.c b/gcc/testsuite/gcc.target/loongarch/div-1.c
new file mode 100644
index 00000000000..b1683f8535f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/div-1.c
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mcheck-zero-division" } */
+/* { dg-final { scan-assembler "div.\[wd\]\t\\\$r4,\\\$r4,\\\$r5" } } */
+
+long
+div(long a, long b)
+{
+  return a / b;
+}
diff --git a/gcc/testsuite/gcc.target/loongarch/div-2.c b/gcc/testsuite/gcc.target/loongarch/div-2.c
new file mode 100644
index 00000000000..4c2beb5b930
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/div-2.c
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mno-check-zero-division" } */
+/* { dg-final { scan-assembler "div.\[wd\]\t\\\$r4,\\\$r5,\\\$r4" } } */
+
+long
+div(long a, long b)
+{
+  return b / a;
+}
diff --git a/gcc/testsuite/gcc.target/loongarch/div-3.c b/gcc/testsuite/gcc.target/loongarch/div-3.c
new file mode 100644
index 00000000000..d25969263f5
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/div-3.c
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mcheck-zero-division" } */
+/* { dg-final { scan-assembler-not "div.\[wd\]\t\\\$r4,\\\$r5,\\\$r4" } } */
+
+long
+div(long a, long b)
+{
+  return b / a;
+}
-- 
2.38.1

From e393e69a9d83934751067feedb838ddbd546d3e9 Mon Sep 17 00:00:00 2001
From: Xi Ruoyao <xry111@xry111.site>
Date: Wed, 6 Jul 2022 23:22:29 +0800
Subject: [PATCH 02/36] loongarch: avoid unnecessary sign-extend after 32-bit
 division

Like add.w/sub.w/mul.w, div.w/mod.w/div.wu/mod.wu also sign-extend the
output on LA64.  But, LoongArch v1.00 mandates that the inputs of 32-bit
division to be sign-extended so we have to expand 32-bit division into
RTL sequences.

We defined div.w/mod.w/div.wu/mod.wu as a (DI, DI) -> SI instruction.
This definition does not indicate the fact that these instructions will
store the result as sign-extended value in a 64-bit GR.  Then the
compiler would emit unnecessary sign-extend operations.  For example:

    int div(int a, int b) { return a / b; }

was compiled to:

    div.w  $r4, $r4, $r5
    slli.w $r4, $r4, 0    # this is unnecessary
    jr     $r1

To remove this unnecessary operation, we change the division
instructions to (DI, DI) -> DI and describe the sign-extend behavior
explicitly in the RTL template.  In the expander for 32-bit division we
then use simplify_gen_subreg to extract the lower 32 bits.

gcc/ChangeLog:

	* config/loongarch/loongarch.md (<any_div>di3_fake): Describe
	the sign-extend of result in the RTL template.
	(<any_div><mode>3): Adjust for <any_div>di3_fake change.

gcc/testsuite/ChangeLog:

	* gcc.target/loongarch/div-4.c: New test.
---
 gcc/config/loongarch/loongarch.md          | 12 ++++++++----
 gcc/testsuite/gcc.target/loongarch/div-4.c |  9 +++++++++
 2 files changed, 17 insertions(+), 4 deletions(-)
 create mode 100644 gcc/testsuite/gcc.target/loongarch/div-4.c

diff --git a/gcc/config/loongarch/loongarch.md b/gcc/config/loongarch/loongarch.md
index 6bca2ed3993..5c0445dd879 100644
--- a/gcc/config/loongarch/loongarch.md
+++ b/gcc/config/loongarch/loongarch.md
@@ -752,6 +752,7 @@
   {
     rtx reg1 = gen_reg_rtx (DImode);
     rtx reg2 = gen_reg_rtx (DImode);
+    rtx rd = gen_reg_rtx (DImode);
 
     operands[1] = gen_rtx_SIGN_EXTEND (word_mode, operands[1]);
     operands[2] = gen_rtx_SIGN_EXTEND (word_mode, operands[2]);
@@ -759,7 +760,9 @@
     emit_insn (gen_rtx_SET (reg1, operands[1]));
     emit_insn (gen_rtx_SET (reg2, operands[2]));
 
-    emit_insn (gen_<optab>di3_fake (operands[0], reg1, reg2));
+    emit_insn (gen_<optab>di3_fake (rd, reg1, reg2));
+    emit_insn (gen_rtx_SET (operands[0],
+			    simplify_gen_subreg (SImode, rd, DImode, 0)));
     DONE;
   }
 })
@@ -781,9 +784,10 @@
 	(const_string "no")))])
 
 (define_insn "<optab>di3_fake"
-  [(set (match_operand:SI 0 "register_operand" "=r,&r,&r")
-	(any_div:SI (match_operand:DI 1 "register_operand" "r,r,0")
-		    (match_operand:DI 2 "register_operand" "r,r,r")))]
+  [(set (match_operand:DI 0 "register_operand" "=r,&r,&r")
+	(sign_extend:DI
+	  (any_div:SI (match_operand:DI 1 "register_operand" "r,r,0")
+		      (match_operand:DI 2 "register_operand" "r,r,r"))))]
   ""
 {
   return loongarch_output_division ("<insn>.w<u>\t%0,%1,%2", operands);
diff --git a/gcc/testsuite/gcc.target/loongarch/div-4.c b/gcc/testsuite/gcc.target/loongarch/div-4.c
new file mode 100644
index 00000000000..a52f87d6caf
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/div-4.c
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+/* { dg-final { scan-assembler-not "slli" } } */
+
+int
+div(int a, int b)
+{
+  return a / b;
+}
-- 
2.38.1

From 7ddc3232bdac761ca5fae7a76e8b2ce274e28213 Mon Sep 17 00:00:00 2001
From: Lulu Cheng <chenglulu@loongson.cn>
Date: Thu, 21 Jul 2022 10:32:51 +0800
Subject: [PATCH 03/36] LoongArch: Subdivision symbol type, add SYMBOL_PCREL
 support.

1. Remove cModel type support other than normal.
2. The method for calling global functions changed from 'la.global + jirl' to 'bl'
   when complied add '-fplt'.

gcc/ChangeLog:

	* config/loongarch/constraints.md (a): Delete the constraint.
	(b): A constant call not local address.
	(h): Delete the constraint.
	(t): Delete the constraint.
	* config/loongarch/loongarch-opts.cc (loongarch_config_target):
	Remove cModel type support other than normal.
	* config/loongarch/loongarch-protos.h (enum loongarch_symbol_type):
	Add new symbol type 'SYMBOL_PCREL', 'SYMBOL_TLS_IE' and 'SYMBOL_TLS_LE'.
	(loongarch_split_symbol): Delete useless function declarations.
	(loongarch_split_symbol_type): Delete useless function declarations.
	* config/loongarch/loongarch.cc (enum loongarch_address_type):
	Delete unnecessary comment information.
	(loongarch_symbol_binds_local_p): Modified the judgment order of label
	and symbol.
	(loongarch_classify_symbol): Return symbol type. If symbol is a label,
	or symbol is a local symbol return SYMBOL_PCREL. If is a tls symbol,
	return SYMBOL_TLS. If is a not local symbol return SYMBOL_GOT_DISP.
	(loongarch_symbolic_constant_p): Add handling of 'SYMBOL_TLS_IE'
	'SYMBOL_TLS_LE' and 'SYMBOL_PCREL'.
	(loongarch_symbol_insns): Add handling of 'SYMBOL_TLS_IE' 'SYMBOL_TLS_LE'
	and 'SYMBOL_PCREL'.
	(loongarch_address_insns): Sort code.
	(loongarch_12bit_offset_address_p): Sort code.
	(loongarch_14bit_shifted_offset_address_p): Sort code.
	(loongarch_call_tls_get_addr): Sort code.
	(loongarch_legitimize_tls_address): Sort code.
	(loongarch_output_move): Remove schema support for cmodel other than normal.
	(loongarch_memmodel_needs_release_fence): Sort code.
	(loongarch_print_operand): Sort code.
	* config/loongarch/loongarch.h (LARCH_U12BIT_OFFSET_P):
	Rename to LARCH_12BIT_OFFSET_P.
	(LARCH_12BIT_OFFSET_P): New macro.
	* config/loongarch/loongarch.md: Reimplement the function call. Remove schema
	support for cmodel other than normal.
	* config/loongarch/predicates.md (is_const_call_weak_symbol): Delete this predicate.
	(is_const_call_plt_symbol): Delete this predicate.
	(is_const_call_global_noplt_symbol): Delete this predicate.
	(is_const_call_no_local_symbol): New predicate, determines whether it is a local
	symbol or label.

gcc/testsuite/ChangeLog:

	* gcc.target/loongarch/func-call-1.c: New test.
	* gcc.target/loongarch/func-call-2.c: New test.
	* gcc.target/loongarch/func-call-3.c: New test.
	* gcc.target/loongarch/func-call-4.c: New test.
---
 gcc/config/loongarch/constraints.md           |  24 +-
 gcc/config/loongarch/loongarch-opts.cc        |   7 +
 gcc/config/loongarch/loongarch-protos.h       |   9 +-
 gcc/config/loongarch/loongarch.cc             | 256 +++++++---------
 gcc/config/loongarch/loongarch.h              |   2 +-
 gcc/config/loongarch/loongarch.md             | 279 +++---------------
 gcc/config/loongarch/predicates.md            |  40 ++-
 .../gcc.target/loongarch/func-call-1.c        |  32 ++
 .../gcc.target/loongarch/func-call-2.c        |  32 ++
 .../gcc.target/loongarch/func-call-3.c        |  32 ++
 .../gcc.target/loongarch/func-call-4.c        |  32 ++
 11 files changed, 312 insertions(+), 433 deletions(-)
 create mode 100644 gcc/testsuite/gcc.target/loongarch/func-call-1.c
 create mode 100644 gcc/testsuite/gcc.target/loongarch/func-call-2.c
 create mode 100644 gcc/testsuite/gcc.target/loongarch/func-call-3.c
 create mode 100644 gcc/testsuite/gcc.target/loongarch/func-call-4.c

diff --git a/gcc/config/loongarch/constraints.md b/gcc/config/loongarch/constraints.md
index d0bfddbd5a9..43cb7b5f0f5 100644
--- a/gcc/config/loongarch/constraints.md
+++ b/gcc/config/loongarch/constraints.md
@@ -20,14 +20,14 @@
 
 ;; Register constraints
 
-;; "a" "A constant call global and noplt address."
-;; "b" <-----unused
+;; "a" <-----unused
+;; "b" "A constant call not local address."
 ;; "c" "A constant call local address."
 ;; "d" <-----unused
 ;; "e" JIRL_REGS
 ;; "f" FP_REGS
 ;; "g" <-----unused
-;; "h" "A constant call plt address."
+;; "h" <-----unused
 ;; "i" "Matches a general integer constant." (Global non-architectural)
 ;; "j" SIBCALL_REGS
 ;; "k" "A memory operand whose address is formed by a base register and
@@ -42,7 +42,7 @@
 ;; "q" CSR_REGS
 ;; "r" GENERAL_REGS (Global non-architectural)
 ;; "s" "Matches a symbolic integer constant." (Global non-architectural)
-;; "t" "A constant call weak address"
+;; "t" <-----unused
 ;; "u" "A signed 52bit constant and low 32-bit is zero (for logic instructions)"
 ;; "v" "A signed 64-bit constant and low 44-bit is zero (for logic instructions)."
 ;; "w" "Matches any valid memory."
@@ -89,10 +89,10 @@
 ;; "<" "Matches a pre-dec or post-dec operand." (Global non-architectural)
 ;; ">" "Matches a pre-inc or post-inc operand." (Global non-architectural)
 
-(define_constraint "a"
+(define_constraint "b"
   "@internal
-   A constant call global and noplt address."
-  (match_operand 0 "is_const_call_global_noplt_symbol"))
+   A constant call no local address."
+  (match_operand 0 "is_const_call_no_local_symbol"))
 
 (define_constraint "c"
   "@internal
@@ -105,11 +105,6 @@
 (define_register_constraint "f" "TARGET_HARD_FLOAT ? FP_REGS : NO_REGS"
   "A floating-point register (if available).")
 
-(define_constraint "h"
-  "@internal
-   A constant call plt address."
-  (match_operand 0 "is_const_call_plt_symbol"))
-
 (define_register_constraint "j" "SIBCALL_REGS"
   "@internal")
 
@@ -134,11 +129,6 @@
 (define_register_constraint "q" "CSR_REGS"
   "A general-purpose register except for $r0 and $r1 for lcsr.")
 
-(define_constraint "t"
-  "@internal
-   A constant call weak address."
-  (match_operand 0 "is_const_call_weak_symbol"))
-
 (define_constraint "u"
   "A signed 52bit constant and low 32-bit is zero (for logic instructions)."
   (and (match_code "const_int")
diff --git a/gcc/config/loongarch/loongarch-opts.cc b/gcc/config/loongarch/loongarch-opts.cc
index eb9c2a52f9e..fc477bfd4bb 100644
--- a/gcc/config/loongarch/loongarch-opts.cc
+++ b/gcc/config/loongarch/loongarch-opts.cc
@@ -376,6 +376,13 @@ fallback:
 
   /* 5.  Target code model */
   t.cmodel = constrained.cmodel ? opt_cmodel : CMODEL_NORMAL;
+  if (t.cmodel != CMODEL_NORMAL)
+    {
+      warning (0, "%qs is not supported, now cmodel is set to 'normal'.",
+	       loongarch_cmodel_strings[t.cmodel]);
+      t.cmodel = CMODEL_NORMAL;
+    }
+
 
   /* Cleanup and return.  */
   obstack_free (&msg_obstack, NULL);
diff --git a/gcc/config/loongarch/loongarch-protos.h b/gcc/config/loongarch/loongarch-protos.h
index 2287fd3763c..080766250d1 100644
--- a/gcc/config/loongarch/loongarch-protos.h
+++ b/gcc/config/loongarch/loongarch-protos.h
@@ -27,9 +27,13 @@ along with GCC; see the file COPYING3.  If not see
    SYMBOL_GOT_DISP
        The symbol's value will be loaded directly from the GOT.
 
+   SYMBOL_PCREL
+       The symbol's value will be loaded directly from data section.
+
    SYMBOL_TLS
        A thread-local symbol.
 
+   SYMBOL_TLS_IE
    SYMBOL_TLSGD
    SYMBOL_TLSLDM
        UNSPEC wrappers around SYMBOL_TLS, corresponding to the
@@ -37,7 +41,10 @@ along with GCC; see the file COPYING3.  If not see
    */
 enum loongarch_symbol_type {
   SYMBOL_GOT_DISP,
+  SYMBOL_PCREL,
   SYMBOL_TLS,
+  SYMBOL_TLS_IE,
+  SYMBOL_TLS_LE,
   SYMBOL_TLSGD,
   SYMBOL_TLSLDM,
 };
@@ -61,7 +68,6 @@ extern int loongarch_idiv_insns (machine_mode);
 #ifdef RTX_CODE
 extern void loongarch_emit_binary (enum rtx_code, rtx, rtx, rtx);
 #endif
-extern bool loongarch_split_symbol (rtx, rtx, machine_mode, rtx *);
 extern rtx loongarch_unspec_address (rtx, enum loongarch_symbol_type);
 extern rtx loongarch_strip_unspec_address (rtx);
 extern void loongarch_move_integer (rtx, rtx, unsigned HOST_WIDE_INT);
@@ -154,7 +160,6 @@ extern rtx loongarch_expand_thread_pointer (rtx);
 extern bool loongarch_eh_uses (unsigned int);
 extern bool loongarch_epilogue_uses (unsigned int);
 extern bool loongarch_load_store_bonding_p (rtx *, machine_mode, bool);
-extern bool loongarch_split_symbol_type (enum loongarch_symbol_type);
 
 typedef rtx (*mulsidi3_gen_fn) (rtx, rtx, rtx);
 
diff --git a/gcc/config/loongarch/loongarch.cc b/gcc/config/loongarch/loongarch.cc
index 8b0d7f459e0..1cb5742f6dd 100644
--- a/gcc/config/loongarch/loongarch.cc
+++ b/gcc/config/loongarch/loongarch.cc
@@ -114,19 +114,7 @@ enum loongarch_address_type
 };
 
 
-/* Information about an address described by loongarch_address_type.
-
-   ADDRESS_CONST_INT
-       No fields are used.
-
-   ADDRESS_REG
-       REG is the base register and OFFSET is the constant offset.
-
-   ADDRESS_REG_REG
-       A base register indexed by (optionally scaled) register.
-
-   ADDRESS_SYMBOLIC
-       SYMBOL_TYPE is the type of symbol that the address references.  */
+/* Information about an address described by loongarch_address_type.  */
 struct loongarch_address_info
 {
   enum loongarch_address_type type;
@@ -1617,11 +1605,12 @@ loongarch_weak_symbol_p (const_rtx x)
 bool
 loongarch_symbol_binds_local_p (const_rtx x)
 {
-  if (LABEL_REF_P (x))
+  if (SYMBOL_REF_P (x))
+    return (SYMBOL_REF_DECL (x)
+	    ? targetm.binds_local_p (SYMBOL_REF_DECL (x))
+	    : SYMBOL_REF_LOCAL_P (x));
+  else
     return false;
-
-  return (SYMBOL_REF_DECL (x) ? targetm.binds_local_p (SYMBOL_REF_DECL (x))
-			      : SYMBOL_REF_LOCAL_P (x));
 }
 
 /* Return true if rtx constants of mode MODE should be put into a small
@@ -1640,17 +1629,16 @@ static enum loongarch_symbol_type
 loongarch_classify_symbol (const_rtx x)
 {
   if (LABEL_REF_P (x))
-    return SYMBOL_GOT_DISP;
-
-  gcc_assert (SYMBOL_REF_P (x));
+    return SYMBOL_PCREL;
 
   if (SYMBOL_REF_TLS_MODEL (x))
     return SYMBOL_TLS;
 
-  if (SYMBOL_REF_P (x))
+  if (SYMBOL_REF_P (x)
+      && !loongarch_symbol_binds_local_p (x))
     return SYMBOL_GOT_DISP;
 
-  return SYMBOL_GOT_DISP;
+  return SYMBOL_PCREL;
 }
 
 /* Return true if X is a symbolic constant.  If it is,
@@ -1683,9 +1671,15 @@ loongarch_symbolic_constant_p (rtx x, enum loongarch_symbol_type *symbol_type)
      relocations.  */
   switch (*symbol_type)
     {
-    case SYMBOL_GOT_DISP:
+    case SYMBOL_TLS_IE:
+    case SYMBOL_TLS_LE:
     case SYMBOL_TLSGD:
     case SYMBOL_TLSLDM:
+    case SYMBOL_PCREL:
+      /* GAS rejects offsets outside the range [-2^31, 2^31-1].  */
+      return sext_hwi (INTVAL (offset), 32) == INTVAL (offset);
+
+    case SYMBOL_GOT_DISP:
     case SYMBOL_TLS:
       return false;
     }
@@ -1707,9 +1701,14 @@ loongarch_symbol_insns (enum loongarch_symbol_type type, machine_mode mode)
 
       return 3;
 
+    case SYMBOL_PCREL:
+    case SYMBOL_TLS_IE:
+    case SYMBOL_TLS_LE:
+      return 2;
+
     case SYMBOL_TLSGD:
     case SYMBOL_TLSLDM:
-      return 1;
+      return 3;
 
     case SYMBOL_TLS:
       /* We don't treat a bare TLS symbol as a constant.  */
@@ -1937,11 +1936,7 @@ loongarch_address_insns (rtx x, machine_mode mode, bool might_split_p)
     switch (addr.type)
       {
       case ADDRESS_REG:
-	return factor;
-
       case ADDRESS_REG_REG:
-	return factor;
-
       case ADDRESS_CONST_INT:
 	return factor;
 
@@ -1983,7 +1978,7 @@ loongarch_12bit_offset_address_p (rtx x, machine_mode mode)
   return (loongarch_classify_address (&addr, x, mode, false)
 	  && addr.type == ADDRESS_REG
 	  && CONST_INT_P (addr.offset)
-	  && LARCH_U12BIT_OFFSET_P (INTVAL (addr.offset)));
+	  && LARCH_12BIT_OFFSET_P (INTVAL (addr.offset)));
 }
 
 /* Return true if X is a legitimate address with a 14-bit offset shifted 2.
@@ -2001,6 +1996,9 @@ loongarch_14bit_shifted_offset_address_p (rtx x, machine_mode mode)
 	  && LARCH_SHIFT_2_OFFSET_P (INTVAL (addr.offset)));
 }
 
+/* Return true if X is a legitimate address with base and index.
+   MODE is the mode of the value being accessed.  */
+
 bool
 loongarch_base_index_address_p (rtx x, machine_mode mode)
 {
@@ -2310,7 +2308,7 @@ loongarch_call_tls_get_addr (rtx sym, enum loongarch_symbol_type type, rtx v0)
 
 /* Generate the code to access LOC, a thread-local SYMBOL_REF, and return
    its address.  The return value will be both a valid address and a valid
-   SET_SRC (either a REG or a LO_SUM).  */
+   SET_SRC.  */
 
 static rtx
 loongarch_legitimize_tls_address (rtx loc)
@@ -2336,7 +2334,7 @@ loongarch_legitimize_tls_address (rtx loc)
       break;
 
     case TLS_MODEL_INITIAL_EXEC:
-      /* la.tls.ie; tp-relative add  */
+      /* la.tls.ie; tp-relative add.  */
       tp = gen_rtx_REG (Pmode, THREAD_POINTER_REGNUM);
       tmp = gen_reg_rtx (Pmode);
       emit_insn (loongarch_got_load_tls_ie (tmp, loc));
@@ -2345,7 +2343,7 @@ loongarch_legitimize_tls_address (rtx loc)
       break;
 
     case TLS_MODEL_LOCAL_EXEC:
-      /* la.tls.le; tp-relative add  */
+      /* la.tls.le; tp-relative add.  */
       tp = gen_rtx_REG (Pmode, THREAD_POINTER_REGNUM);
       tmp = gen_reg_rtx (Pmode);
       emit_insn (loongarch_got_load_tls_le (tmp, loc));
@@ -3371,6 +3369,7 @@ loongarch_output_move (rtx dest, rtx src)
 	    case 2:
 	      return "st.h\t%z1,%0";
 	    case 4:
+	      /* Matching address type with a 12bit offset.  */
 	      if (const_arith_operand (offset, Pmode))
 		return "st.w\t%z1,%0";
 	      else
@@ -3409,6 +3408,7 @@ loongarch_output_move (rtx dest, rtx src)
 	    case 2:
 	      return "ld.hu\t%0,%1";
 	    case 4:
+	      /* Matching address type with a 12bit offset.  */
 	      if (const_arith_operand (offset, Pmode))
 		return "ld.w\t%0,%1";
 	      else
@@ -3436,56 +3436,16 @@ loongarch_output_move (rtx dest, rtx src)
 	  else
 	    gcc_unreachable ();
 	}
+    }
 
-      if (symbolic_operand (src, VOIDmode))
-	{
-	  if ((TARGET_CMODEL_TINY && (!loongarch_global_symbol_p (src)
-				      || loongarch_symbol_binds_local_p (src)))
-	      || (TARGET_CMODEL_TINY_STATIC && !loongarch_weak_symbol_p (src)))
-	    {
-	      /* The symbol must be aligned to 4 byte.  */
-	      unsigned int align;
-
-	      if (LABEL_REF_P (src))
-		align = 32 /* Whatever.  */;
-	      else if (CONSTANT_POOL_ADDRESS_P (src))
-		align = GET_MODE_ALIGNMENT (get_pool_mode (src));
-	      else if (TREE_CONSTANT_POOL_ADDRESS_P (src))
-		{
-		  tree exp = SYMBOL_REF_DECL (src);
-		  align = TYPE_ALIGN (TREE_TYPE (exp));
-		  align = loongarch_constant_alignment (exp, align);
-		}
-	      else if (SYMBOL_REF_DECL (src))
-		align = DECL_ALIGN (SYMBOL_REF_DECL (src));
-	      else if (SYMBOL_REF_HAS_BLOCK_INFO_P (src)
-		       && SYMBOL_REF_BLOCK (src) != NULL)
-		align = SYMBOL_REF_BLOCK (src)->alignment;
-	      else
-		align = BITS_PER_UNIT;
-
-	      if (align % (4 * 8) == 0)
-		return "pcaddi\t%0,%%pcrel(%1)>>2";
-	    }
-	  if (TARGET_CMODEL_TINY
-	      || TARGET_CMODEL_TINY_STATIC
-	      || TARGET_CMODEL_NORMAL
-	      || TARGET_CMODEL_LARGE)
-	    {
-	      if (!loongarch_global_symbol_p (src)
-		  || loongarch_symbol_binds_local_p (src))
-		return "la.local\t%0,%1";
-	      else
-		return "la.global\t%0,%1";
-	    }
-	  if (TARGET_CMODEL_EXTREME)
-	    {
-	      sorry ("Normal symbol loading not implemented in extreme mode.");
-	      gcc_unreachable ();
-	    }
-
-	}
+  if (dest_code == REG && symbolic_operand (src, VOIDmode))
+    {
+      if (loongarch_classify_symbol (src) == SYMBOL_PCREL)
+	return "la.local\t%0,%1";
+      else
+	return "la.global\t%0,%1";
     }
+
   if (src_code == REG && FP_REG_P (REGNO (src)))
     {
       if (dest_code == REG && FP_REG_P (REGNO (dest)))
@@ -3503,6 +3463,7 @@ loongarch_output_move (rtx dest, rtx src)
 	  return dbl_p ? "fst.d\t%1,%0" : "fst.s\t%1,%0";
 	}
     }
+
   if (dest_code == REG && FP_REG_P (REGNO (dest)))
     {
       if (src_code == MEM)
@@ -3517,6 +3478,7 @@ loongarch_output_move (rtx dest, rtx src)
 	  return dbl_p ? "fld.d\t%0,%1" : "fld.s\t%0,%1";
 	}
     }
+
   gcc_unreachable ();
 }
 
@@ -4347,27 +4309,27 @@ loongarch_memmodel_needs_release_fence (enum memmodel model)
 
 /* Implement TARGET_PRINT_OPERAND.  The LoongArch-specific operand codes are:
 
-   'X'	Print CONST_INT OP in hexadecimal format.
-   'x'	Print the low 16 bits of CONST_INT OP in hexadecimal format.
+   'A'	Print a _DB suffix if the memory model requires a release.
+   'b'	Print the address of a memory operand, without offset.
+   'C'	Print the integer branch condition for comparison OP.
    'd'	Print CONST_INT OP in decimal.
+   'F'	Print the FPU branch condition for comparison OP.
+   'G'	Print a DBAR insn if the memory model requires a release.
+   'i'	Print i if the operand is not a register.
    'm'	Print one less than CONST_INT OP in decimal.
-   'y'	Print exact log2 of CONST_INT OP in decimal.
-   'C'	Print the integer branch condition for comparison OP.
    'N'	Print the inverse of the integer branch condition for comparison OP.
-   'F'	Print the FPU branch condition for comparison OP.
-   'W'	Print the inverse of the FPU branch condition for comparison OP.
    'T'	Print 'f' for (eq:CC ...), 't' for (ne:CC ...),
 	      'z' for (eq:?I ...), 'n' for (ne:?I ...).
    't'	Like 'T', but with the EQ/NE cases reversed
-   'Y'	Print loongarch_fp_conditions[INTVAL (OP)]
-   'Z'	Print OP and a comma for 8CC, otherwise print nothing.
-   'z'	Print $0 if OP is zero, otherwise print OP normally.
-   'b'	Print the address of a memory operand, without offset.
    'V'	Print exact log2 of CONST_INT OP element 0 of a replicated
 	  CONST_VECTOR in decimal.
-   'A'	Print a _DB suffix if the memory model requires a release.
-   'G'	Print a DBAR insn if the memory model requires a release.
-   'i'	Print i if the operand is not a register.  */
+   'W'	Print the inverse of the FPU branch condition for comparison OP.
+   'X'	Print CONST_INT OP in hexadecimal format.
+   'x'	Print the low 16 bits of CONST_INT OP in hexadecimal format.
+   'Y'	Print loongarch_fp_conditions[INTVAL (OP)]
+   'y'	Print exact log2 of CONST_INT OP in decimal.
+   'Z'	Print OP and a comma for 8CC, otherwise print nothing.
+   'z'	Print $0 if OP is zero, otherwise print OP normally.  */
 
 static void
 loongarch_print_operand (FILE *file, rtx op, int letter)
@@ -4385,18 +4347,13 @@ loongarch_print_operand (FILE *file, rtx op, int letter)
 
   switch (letter)
     {
-    case 'X':
-      if (CONST_INT_P (op))
-	fprintf (file, HOST_WIDE_INT_PRINT_HEX, INTVAL (op));
-      else
-	output_operand_lossage ("invalid use of '%%%c'", letter);
+    case 'A':
+      if (loongarch_memmodel_needs_rel_acq_fence ((enum memmodel) INTVAL (op)))
+       fputs ("_db", file);
       break;
 
-    case 'x':
-      if (CONST_INT_P (op))
-	fprintf (file, HOST_WIDE_INT_PRINT_HEX, INTVAL (op) & 0xffff);
-      else
-	output_operand_lossage ("invalid use of '%%%c'", letter);
+    case 'C':
+      loongarch_print_int_branch_condition (file, code, letter);
       break;
 
     case 'd':
@@ -4406,6 +4363,20 @@ loongarch_print_operand (FILE *file, rtx op, int letter)
 	output_operand_lossage ("invalid use of '%%%c'", letter);
       break;
 
+    case 'F':
+      loongarch_print_float_branch_condition (file, code, letter);
+      break;
+
+    case 'G':
+      if (loongarch_memmodel_needs_release_fence ((enum memmodel) INTVAL (op)))
+	fputs ("dbar\t0", file);
+      break;
+
+    case 'i':
+      if (code != REG)
+	fputs ("i", file);
+      break;
+
     case 'm':
       if (CONST_INT_P (op))
 	fprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (op) - 1);
@@ -4413,17 +4384,17 @@ loongarch_print_operand (FILE *file, rtx op, int letter)
 	output_operand_lossage ("invalid use of '%%%c'", letter);
       break;
 
-    case 'y':
-      if (CONST_INT_P (op))
-	{
-	  int val = exact_log2 (INTVAL (op));
-	  if (val != -1)
-	    fprintf (file, "%d", val);
-	  else
-	    output_operand_lossage ("invalid use of '%%%c'", letter);
-	}
-      else
-	output_operand_lossage ("invalid use of '%%%c'", letter);
+    case 'N':
+      loongarch_print_int_branch_condition (file, reverse_condition (code),
+					    letter);
+      break;
+
+    case 't':
+    case 'T':
+      {
+	int truth = (code == NE) == (letter == 'T');
+	fputc ("zfnt"[truth * 2 + FCC_REG_P (REGNO (XEXP (op, 0)))], file);
+      }
       break;
 
     case 'V':
@@ -4441,30 +4412,36 @@ loongarch_print_operand (FILE *file, rtx op, int letter)
 	output_operand_lossage ("invalid use of '%%%c'", letter);
       break;
 
-    case 'C':
-      loongarch_print_int_branch_condition (file, code, letter);
-      break;
-
-    case 'N':
-      loongarch_print_int_branch_condition (file, reverse_condition (code),
-					    letter);
+    case 'W':
+      loongarch_print_float_branch_condition (file, reverse_condition (code),
+					      letter);
       break;
 
-    case 'F':
-      loongarch_print_float_branch_condition (file, code, letter);
+    case 'x':
+      if (CONST_INT_P (op))
+	fprintf (file, HOST_WIDE_INT_PRINT_HEX, INTVAL (op) & 0xffff);
+      else
+	output_operand_lossage ("invalid use of '%%%c'", letter);
       break;
 
-    case 'W':
-      loongarch_print_float_branch_condition (file, reverse_condition (code),
-					      letter);
+    case 'X':
+      if (CONST_INT_P (op))
+	fprintf (file, HOST_WIDE_INT_PRINT_HEX, INTVAL (op));
+      else
+	output_operand_lossage ("invalid use of '%%%c'", letter);
       break;
 
-    case 'T':
-    case 't':
-      {
-	int truth = (code == NE) == (letter == 'T');
-	fputc ("zfnt"[truth * 2 + FCC_REG_P (REGNO (XEXP (op, 0)))], file);
-      }
+    case 'y':
+      if (CONST_INT_P (op))
+	{
+	  int val = exact_log2 (INTVAL (op));
+	  if (val != -1)
+	    fprintf (file, "%d", val);
+	  else
+	    output_operand_lossage ("invalid use of '%%%c'", letter);
+	}
+      else
+	output_operand_lossage ("invalid use of '%%%c'", letter);
       break;
 
     case 'Y':
@@ -4481,21 +4458,6 @@ loongarch_print_operand (FILE *file, rtx op, int letter)
       fputc (',', file);
       break;
 
-    case 'A':
-      if (loongarch_memmodel_needs_rel_acq_fence ((enum memmodel) INTVAL (op)))
-	fputs ("_db", file);
-      break;
-
-    case 'G':
-      if (loongarch_memmodel_needs_release_fence ((enum memmodel) INTVAL (op)))
-	fputs ("dbar\t0", file);
-      break;
-
-    case 'i':
-      if (code != REG)
-	fputs ("i", file);
-      break;
-
     default:
       switch (code)
 	{
diff --git a/gcc/config/loongarch/loongarch.h b/gcc/config/loongarch/loongarch.h
index f9de9a6e4fb..89a5bd728fe 100644
--- a/gcc/config/loongarch/loongarch.h
+++ b/gcc/config/loongarch/loongarch.h
@@ -614,7 +614,7 @@ enum reg_class
 #define LU12I_INT(X) LU12I_OPERAND (INTVAL (X))
 #define LU32I_INT(X) LU32I_OPERAND (INTVAL (X))
 #define LU52I_INT(X) LU52I_OPERAND (INTVAL (X))
-#define LARCH_U12BIT_OFFSET_P(OFFSET) (IN_RANGE (OFFSET, -2048, 2047))
+#define LARCH_12BIT_OFFSET_P(OFFSET) (IN_RANGE (OFFSET, -2048, 2047))
 #define LARCH_9BIT_OFFSET_P(OFFSET) (IN_RANGE (OFFSET, -256, 255))
 #define LARCH_16BIT_OFFSET_P(OFFSET) (IN_RANGE (OFFSET, -32768, 32767))
 #define LARCH_SHIFT_2_OFFSET_P(OFFSET) (((OFFSET) & 0x3) == 0)
diff --git a/gcc/config/loongarch/loongarch.md b/gcc/config/loongarch/loongarch.md
index 5c0445dd879..376879fbccb 100644
--- a/gcc/config/loongarch/loongarch.md
+++ b/gcc/config/loongarch/loongarch.md
@@ -2844,48 +2844,14 @@
 })
 
 (define_insn "sibcall_internal"
-  [(call (mem:SI (match_operand 0 "call_insn_operand" "j,c,a,t,h"))
+  [(call (mem:SI (match_operand 0 "call_insn_operand" "j,c,b"))
 	 (match_operand 1 "" ""))]
   "SIBLING_CALL_P (insn)"
-{
-  switch (which_alternative)
-    {
-    case 0:
-      return "jr\t%0";
-    case 1:
-      if (TARGET_CMODEL_LARGE)
-	return "pcaddu18i\t$r12,(%%pcrel(%0+0x20000))>>18\n\t"
-	       "jirl\t$r0,$r12,%%pcrel(%0+4)-(%%pcrel(%0+4+0x20000)>>18<<18)";
-      else if (TARGET_CMODEL_EXTREME)
-	return "la.local\t$r12,$r13,%0\n\tjr\t$r12";
-      else
-	return "b\t%0";
-    case 2:
-      if (TARGET_CMODEL_TINY_STATIC)
-	return "b\t%0";
-      else if (TARGET_CMODEL_EXTREME)
-	return "la.global\t$r12,$r13,%0\n\tjr\t$r12";
-      else
-	return "la.global\t$r12,%0\n\tjr\t$r12";
-    case 3:
-      if (TARGET_CMODEL_EXTREME)
-	return "la.global\t$r12,$r13,%0\n\tjr\t$r12";
-      else
-	return "la.global\t$r12,%0\n\tjr\t$r12";
-    case 4:
-      if (TARGET_CMODEL_NORMAL || TARGET_CMODEL_TINY)
-	return "b\t%%plt(%0)";
-      else if (TARGET_CMODEL_LARGE)
-	return "pcaddu18i\t$r12,(%%plt(%0)+0x20000)>>18\n\t"
-	       "jirl\t$r0,$r12,%%plt(%0)+4-((%%plt(%0)+(4+0x20000))>>18<<18)";
-      else
-	/* Cmodel extreme and tiny static not support plt.  */
-	gcc_unreachable ();
-    default:
-      gcc_unreachable ();
-    }
-}
-  [(set_attr "jirl" "indirect,direct,direct,direct,direct")])
+  "@
+   jr\t%0
+   b\t%0
+   b\t%%plt(%0)"
+  [(set_attr "jirl" "indirect,direct,direct")])
 
 (define_expand "sibcall_value"
   [(parallel [(set (match_operand 0 "")
@@ -2920,96 +2886,28 @@
 
 (define_insn "sibcall_value_internal"
   [(set (match_operand 0 "register_operand" "")
-	(call (mem:SI (match_operand 1 "call_insn_operand" "j,c,a,t,h"))
+	(call (mem:SI (match_operand 1 "call_insn_operand" "j,c,b"))
 	      (match_operand 2 "" "")))]
   "SIBLING_CALL_P (insn)"
-{
-  switch (which_alternative)
-  {
-    case 0:
-      return "jr\t%1";
-    case 1:
-      if (TARGET_CMODEL_LARGE)
-	return "pcaddu18i\t$r12,%%pcrel(%1+0x20000)>>18\n\t"
-	       "jirl\t$r0,$r12,%%pcrel(%1+4)-((%%pcrel(%1+4+0x20000))>>18<<18)";
-      else if (TARGET_CMODEL_EXTREME)
-	return "la.local\t$r12,$r13,%1\n\tjr\t$r12";
-      else
-	return "b\t%1";
-    case 2:
-      if (TARGET_CMODEL_TINY_STATIC)
-	return "b\t%1";
-      else if (TARGET_CMODEL_EXTREME)
-	return "la.global\t$r12,$r13,%1\n\tjr\t$r12";
-      else
-	return "la.global\t$r12,%1\n\tjr\t$r12";
-    case 3:
-      if (TARGET_CMODEL_EXTREME)
-	return "la.global\t$r12,$r13,%1\n\tjr\t$r12";
-      else
-	return "la.global\t$r12,%1\n\tjr\t$r12";
-    case 4:
-      if (TARGET_CMODEL_NORMAL || TARGET_CMODEL_TINY)
-	return " b\t%%plt(%1)";
-      else if (TARGET_CMODEL_LARGE)
-	return "pcaddu18i\t$r12,(%%plt(%1)+0x20000)>>18\n\t"
-	       "jirl\t$r0,$r12,%%plt(%1)+4-((%%plt(%1)+(4+0x20000))>>18<<18)";
-      else
-	/* Cmodel extreme and tiny static not support plt.  */
-	gcc_unreachable ();
-    default:
-      gcc_unreachable ();
-  }
-}
-  [(set_attr "jirl" "indirect,direct,direct,direct,direct")])
+  "@
+   jr\t%1
+   b\t%1
+   b\t%%plt(%1)"
+  [(set_attr "jirl" "indirect,direct,direct")])
 
 (define_insn "sibcall_value_multiple_internal"
   [(set (match_operand 0 "register_operand" "")
-	(call (mem:SI (match_operand 1 "call_insn_operand" "j,c,a,t,h"))
+	(call (mem:SI (match_operand 1 "call_insn_operand" "j,c,b"))
 	      (match_operand 2 "" "")))
    (set (match_operand 3 "register_operand" "")
 	(call (mem:SI (match_dup 1))
 	      (match_dup 2)))]
   "SIBLING_CALL_P (insn)"
-{
-  switch (which_alternative)
-  {
-    case 0:
-      return "jr\t%1";
-    case 1:
-      if (TARGET_CMODEL_LARGE)
-	return "pcaddu18i\t$r12,%%pcrel(%1+0x20000)>>18\n\t"
-	       "jirl\t$r0,$r12,%%pcrel(%1+4)-(%%pcrel(%1+4+0x20000)>>18<<18)";
-      else if (TARGET_CMODEL_EXTREME)
-	return "la.local\t$r12,$r13,%1\n\tjr\t$r12";
-      else
-	return "b\t%1";
-    case 2:
-      if (TARGET_CMODEL_TINY_STATIC)
-	return "b\t%1";
-      else if (TARGET_CMODEL_EXTREME)
-	return "la.global\t$r12,$r13,%1\n\tjr\t$r12";
-      else
-	return "la.global\t$r12,%1\n\tjr\t$r12";
-    case 3:
-      if (TARGET_CMODEL_EXTREME)
-	return "la.global\t$r12,$r13,%1\n\tjr\t$r12";
-      else
-	return "la.global\t$r12,%1\n\tjr\t$r12";
-    case 4:
-      if (TARGET_CMODEL_NORMAL || TARGET_CMODEL_TINY)
-	return "b\t%%plt(%1)";
-      else if (TARGET_CMODEL_LARGE)
-	return "pcaddu18i\t$r12,(%%plt(%1)+0x20000)>>18\n\t"
-	       "jirl\t$r0,$r12,%%plt(%1)+4-((%%plt(%1)+(4+0x20000))>>18<<18)";
-      else
-	/* Cmodel extreme and tiny static not support plt.  */
-	gcc_unreachable ();
-    default:
-      gcc_unreachable ();
-  }
-}
-  [(set_attr "jirl" "indirect,direct,direct,direct,direct")])
+  "@
+   jr\t%1
+   b\t%1
+   b\t%%plt(%1)"
+  [(set_attr "jirl" "indirect,direct,direct")])
 
 (define_expand "call"
   [(parallel [(call (match_operand 0 "")
@@ -3025,50 +2923,15 @@
 })
 
 (define_insn "call_internal"
-  [(call (mem:SI (match_operand 0 "call_insn_operand" "e,c,a,t,h"))
+  [(call (mem:SI (match_operand 0 "call_insn_operand" "e,c,b"))
 	 (match_operand 1 "" ""))
    (clobber (reg:SI RETURN_ADDR_REGNUM))]
   ""
-{
-  switch (which_alternative)
-    {
-    case 0:
-      return "jirl\t$r1,%0,0";
-    case 1:
-      if (TARGET_CMODEL_LARGE)
-	return "pcaddu18i\t$r1,%%pcrel(%0+0x20000)>>18\n\t"
-	       "jirl\t$r1,$r1,%%pcrel(%0+4)-(%%pcrel(%0+4+0x20000)>>18<<18)";
-      else if (TARGET_CMODEL_EXTREME)
-	return "la.local\t$r1,$r12,%0\n\tjirl\t$r1,$r1,0";
-      else
-	return "bl\t%0";
-    case 2:
-      if (TARGET_CMODEL_TINY_STATIC)
-	return "bl\t%0";
-      else if (TARGET_CMODEL_EXTREME)
-	return "la.global\t$r1,$r12,%0\n\tjirl\t$r1,$r1,0";
-      else
-	return "la.global\t$r1,%0\n\tjirl\t$r1,$r1,0";
-    case 3:
-      if (TARGET_CMODEL_EXTREME)
-	return "la.global\t$r1,$r12,%0\n\tjirl\t$r1,$r1,0";
-      else
-	return "la.global\t$r1,%0\n\tjirl\t$r1,$r1,0";
-    case 4:
-      if (TARGET_CMODEL_LARGE)
-	return "pcaddu18i\t$r1,(%%plt(%0)+0x20000)>>18\n\t"
-	       "jirl\t$r1,$r1,%%plt(%0)+4-((%%plt(%0)+(4+0x20000))>>18<<18)";
-      else if (TARGET_CMODEL_NORMAL || TARGET_CMODEL_TINY)
-	return "bl\t%%plt(%0)";
-      else
-	/* Cmodel extreme and tiny static not support plt.  */
-	gcc_unreachable ();
-    default:
-      gcc_unreachable ();
-    }
-}
-  [(set_attr "jirl" "indirect,direct,direct,direct,direct")
-   (set_attr "insn_count" "1,2,3,3,2")])
+  "@
+   jirl\t$r1,%0,0
+   bl\t%0
+   bl\t%%plt(%0)"
+  [(set_attr "jirl" "indirect,direct,direct")])
 
 (define_expand "call_value"
   [(parallel [(set (match_operand 0 "")
@@ -3101,100 +2964,30 @@
 
 (define_insn "call_value_internal"
   [(set (match_operand 0 "register_operand" "")
-	(call (mem:SI (match_operand 1 "call_insn_operand" "e,c,a,t,h"))
+	(call (mem:SI (match_operand 1 "call_insn_operand" "e,c,b"))
 	      (match_operand 2 "" "")))
    (clobber (reg:SI RETURN_ADDR_REGNUM))]
   ""
-{
-  switch (which_alternative)
-    {
-    case 0:
-      return "jirl\t$r1,%1,0";
-    case 1:
-      if (TARGET_CMODEL_LARGE)
-	return "pcaddu18i\t$r1,%%pcrel(%1+0x20000)>>18\n\t"
-	       "jirl\t$r1,$r1,%%pcrel(%1+4)-(%%pcrel(%1+4+0x20000)>>18<<18)";
-      else if (TARGET_CMODEL_EXTREME)
-	return "la.local\t$r1,$r12,%1\n\tjirl\t$r1,$r1,0";
-      else
-	return "bl\t%1";
-    case 2:
-      if (TARGET_CMODEL_TINY_STATIC)
-	return "bl\t%1";
-      else if (TARGET_CMODEL_EXTREME)
-	return "la.global\t$r1,$r12,%1\n\tjirl\t$r1,$r1,0";
-      else
-	return "la.global\t$r1,%1\n\tjirl\t$r1,$r1,0";
-    case 3:
-      if (TARGET_CMODEL_EXTREME)
-	return "la.global\t$r1,$r12,%1\n\tjirl\t$r1,$r1,0";
-      else
-	return "la.global\t$r1,%1\n\tjirl\t$r1,$r1,0";
-    case 4:
-      if (TARGET_CMODEL_LARGE)
-	return "pcaddu18i\t$r1,(%%plt(%1)+0x20000)>>18\n\t"
-	       "jirl\t$r1,$r1,%%plt(%1)+4-((%%plt(%1)+(4+0x20000))>>18<<18)";
-      else if (TARGET_CMODEL_NORMAL || TARGET_CMODEL_TINY)
-	return "bl\t%%plt(%1)";
-      else
-	/* Cmodel extreme and tiny static not support plt.  */
-	gcc_unreachable ();
-    default:
-      gcc_unreachable ();
-    }
-}
-  [(set_attr "jirl" "indirect,direct,direct,direct,direct")
-   (set_attr "insn_count" "1,2,3,3,2")])
+  "@
+   jirl\t$r1,%1,0
+   bl\t%1
+   bl\t%%plt(%1)"
+  [(set_attr "jirl" "indirect,direct,direct")])
 
 (define_insn "call_value_multiple_internal"
   [(set (match_operand 0 "register_operand" "")
-	(call (mem:SI (match_operand 1 "call_insn_operand" "e,c,a,t,h"))
+	(call (mem:SI (match_operand 1 "call_insn_operand" "e,c,b"))
 	      (match_operand 2 "" "")))
    (set (match_operand 3 "register_operand" "")
 	(call (mem:SI (match_dup 1))
 	      (match_dup 2)))
    (clobber (reg:SI RETURN_ADDR_REGNUM))]
   ""
-{
-  switch (which_alternative)
-    {
-    case 0:
-      return "jirl\t$r1,%1,0";
-    case 1:
-      if (TARGET_CMODEL_LARGE)
-	return "pcaddu18i\t$r1,%%pcrel(%1+0x20000)>>18\n\t"
-	       "jirl\t$r1,$r1,%%pcrel(%1+4)-(%%pcrel(%1+4+0x20000)>>18<<18)";
-      else if (TARGET_CMODEL_EXTREME)
-	return "la.local\t$r1,$r12,%1\n\tjirl\t$r1,$r1,0";
-      else
-	return "bl\t%1";
-    case 2:
-      if (TARGET_CMODEL_TINY_STATIC)
-	return "bl\t%1";
-      else if (TARGET_CMODEL_EXTREME)
-	return "la.global\t$r1,$r12,%1\n\tjirl\t$r1,$r1,0 ";
-      else
-	return "la.global\t$r1,%1\n\tjirl\t$r1,$r1,0";
-    case 3:
-      if (TARGET_CMODEL_EXTREME)
-	return "la.global\t$r1,$r12,%1\n\tjirl\t$r1,$r1,0";
-      else
-	return "la.global\t$r1,%1\n\tjirl\t$r1,$r1,0";
-    case 4:
-      if (TARGET_CMODEL_LARGE)
-	return "pcaddu18i\t$r1,(%%plt(%1)+0x20000)>>18\n\t"
-	       "jirl\t$r1,$r1,%%plt(%1)+4-((%%plt(%1)+(4+0x20000))>>18<<18)";
-      else if (TARGET_CMODEL_NORMAL || TARGET_CMODEL_TINY)
-	return "bl\t%%plt(%1)";
-      else
-	/* Cmodel extreme and tiny static not support plt.  */
-	gcc_unreachable ();
-    default:
-      gcc_unreachable ();
-    }
-}
-  [(set_attr "jirl" "indirect,direct,direct,direct,direct")
-   (set_attr "insn_count" "1,2,3,3,2")])
+  "@
+   jirl\t$r1,%1,0
+   bl\t%1
+   bl\t%%plt(%1)"
+  [(set_attr "jirl" "indirect,direct,direct")])
 
 
 ;; Call subroutine returning any type.
diff --git a/gcc/config/loongarch/predicates.md b/gcc/config/loongarch/predicates.md
index edd74d4783d..2243ef71c1a 100644
--- a/gcc/config/loongarch/predicates.md
+++ b/gcc/config/loongarch/predicates.md
@@ -111,20 +111,25 @@
   (match_code "const,symbol_ref,label_ref")
 {
   enum loongarch_symbol_type symbol_type;
+  loongarch_symbolic_constant_p (op, &symbol_type);
 
-  if (!loongarch_symbolic_constant_p (op, &symbol_type))
+  rtx offset, x = op;
+  split_const (x, &x, &offset);
+
+  if (offset != const0_rtx)
     return false;
 
   switch (symbol_type)
     {
-    case SYMBOL_GOT_DISP:
-      /* Without explicit relocs, there is no special syntax for
-	 loading the address of a call destination into a register.
-	 Using "la.global JIRL_REGS,foo; jirl JIRL_REGS" would prevent the lazy
-	 binding of "foo", so keep the address of global symbols with the jirl
-	 macro.  */
+    case SYMBOL_PCREL:
       return 1;
 
+    case SYMBOL_GOT_DISP:
+      if (!flag_plt)
+	return false;
+      else
+	return 1;
+
     default:
       return false;
     }
@@ -140,22 +145,11 @@
 	    (match_test "loongarch_symbol_binds_local_p (op) != 0"))
        (match_test "CONSTANT_P (op)")))
 
-(define_predicate "is_const_call_weak_symbol"
-  (and (match_operand 0 "const_call_insn_operand")
-       (not (match_operand 0 "is_const_call_local_symbol"))
-       (match_test "loongarch_weak_symbol_p (op) != 0")
-       (match_test "CONSTANT_P (op)")))
-
-(define_predicate "is_const_call_plt_symbol"
-  (and (match_operand 0 "const_call_insn_operand")
-       (match_test "flag_plt != 0")
-       (match_test "loongarch_global_symbol_noweak_p (op) != 0")
-       (match_test "CONSTANT_P (op)")))
-
-(define_predicate "is_const_call_global_noplt_symbol"
+(define_predicate "is_const_call_no_local_symbol"
   (and (match_operand 0 "const_call_insn_operand")
-       (match_test "flag_plt == 0")
-       (match_test "loongarch_global_symbol_noweak_p (op) != 0")
+       (ior (match_test "loongarch_global_symbol_p (op) != 0")
+	    (match_test "loongarch_symbol_binds_local_p (op) == 0")
+       (match_test "loongarch_weak_symbol_p (op) != 0"))
        (match_test "CONSTANT_P (op)")))
 
 ;; A legitimate CONST_INT operand that takes more than one instruction
@@ -219,7 +213,7 @@
     case CONST:
     case SYMBOL_REF:
     case LABEL_REF:
-      return (loongarch_symbolic_constant_p (op, &symbol_type));
+      return loongarch_symbolic_constant_p (op, &symbol_type);
     default:
       return true;
     }
diff --git a/gcc/testsuite/gcc.target/loongarch/func-call-1.c b/gcc/testsuite/gcc.target/loongarch/func-call-1.c
new file mode 100644
index 00000000000..b0482761aab
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/func-call-1.c
@@ -0,0 +1,32 @@
+/* { dg-do compile } */
+/* { dg-options "-mabi=lp64d -O0 -fpic -fplt" } */
+/* { dg-final { scan-assembler "test:.*bl\t%plt\\(g\\)\n" } } */
+/* { dg-final { scan-assembler "test1:.*bl\t%plt\\(f\\)\n" } } */
+/* { dg-final { scan-assembler "test2:.*bl\tl\n" } } */
+
+extern void g (void);
+void
+f (void)
+{}
+
+static void
+l (void)
+{}
+
+void
+test (void)
+{
+  g ();
+}
+
+void
+test1 (void)
+{
+  f ();
+}
+
+void
+test2 (void)
+{
+  l ();
+}
diff --git a/gcc/testsuite/gcc.target/loongarch/func-call-2.c b/gcc/testsuite/gcc.target/loongarch/func-call-2.c
new file mode 100644
index 00000000000..f5e061c299c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/func-call-2.c
@@ -0,0 +1,32 @@
+/* { dg-do compile } */
+/* { dg-options "-mabi=lp64d -O0 -fno-pic -fplt" } */
+/* { dg-final { scan-assembler "test:.*bl\t%plt\\(g\\)\n" } } */
+/* { dg-final { scan-assembler "test1:.*bl\tf\n" } } */
+/* { dg-final { scan-assembler "test2:.*bl\tl\n" } } */
+
+extern void g (void);
+void
+f (void)
+{}
+
+static void
+l (void)
+{}
+
+void
+test (void)
+{
+  g ();
+}
+
+void
+test1 (void)
+{
+  f ();
+}
+
+void
+test2 (void)
+{
+  l ();
+}
diff --git a/gcc/testsuite/gcc.target/loongarch/func-call-3.c b/gcc/testsuite/gcc.target/loongarch/func-call-3.c
new file mode 100644
index 00000000000..75082c57466
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/func-call-3.c
@@ -0,0 +1,32 @@
+/* { dg-do compile } */
+/* { dg-options "-mabi=lp64d -O0 -fpic -fno-plt" } */
+/* { dg-final { scan-assembler "test:.*la\.global\t.*g\n\tjirl" } } */
+/* { dg-final { scan-assembler "test1:.*la\.global\t.*f\n\tjirl" } } */
+/* { dg-final { scan-assembler "test2:.*bl\tl\n" } } */
+
+extern void g (void);
+void
+f (void)
+{}
+
+static void
+l (void)
+{}
+
+void
+test (void)
+{
+  g ();
+}
+
+void
+test1 (void)
+{
+  f ();
+}
+
+void
+test2 (void)
+{
+  l ();
+}
diff --git a/gcc/testsuite/gcc.target/loongarch/func-call-4.c b/gcc/testsuite/gcc.target/loongarch/func-call-4.c
new file mode 100644
index 00000000000..e8a8395493e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/func-call-4.c
@@ -0,0 +1,32 @@
+/* { dg-do compile } */
+/* { dg-options "-mabi=lp64d -O0 -fno-pic -fno-plt" } */
+/* { dg-final { scan-assembler "test:.*la\.global\t.*g\n\tjirl" } } */
+/* { dg-final { scan-assembler "test1:.*bl\tf\n" } } */
+/* { dg-final { scan-assembler "test2:.*bl\tl\n" } } */
+
+extern void g (void);
+void
+f (void)
+{}
+
+static void
+l (void)
+{}
+
+void
+test (void)
+{
+  g ();
+}
+
+void
+test1 (void)
+{
+  f ();
+}
+
+void
+test2 (void)
+{
+  l ();
+}
-- 
2.38.1

From 3b6116b75ecacf69a428bfbd53efb15fde9becf1 Mon Sep 17 00:00:00 2001
From: Lulu Cheng <chenglulu@loongson.cn>
Date: Thu, 21 Jul 2022 11:04:08 +0800
Subject: [PATCH 04/36] LoongArch: Support split symbol.

Add compilation option '-mexplicit-relocs', and if enable '-mexplicit-relocs'
the symbolic address load instruction 'la.*' will be split into two instructions.
This compilation option enabled by default.

gcc/ChangeLog:

	* common/config/loongarch/loongarch-common.cc:
	Enable '-fsection-anchors' when O1 and more advanced optimization.
	* config/loongarch/genopts/loongarch.opt.in: Add new option
	'-mexplicit-relocs', and enable by default.
	* config/loongarch/loongarch-protos.h (loongarch_split_move_insn_p):
	Delete function declaration.
	(loongarch_split_move_insn): Delete function declaration.
	(loongarch_split_symbol_type): Add function declaration.
	* config/loongarch/loongarch.cc (enum loongarch_address_type):
	Add new address type 'ADDRESS_LO_SUM'.
	(loongarch_classify_symbolic_expression): New function definitions.
	Classify the base of symbolic expression X, given that X appears in
	context CONTEXT.
	(loongarch_symbol_insns): Add a judgment condition TARGET_EXPLICIT_RELOCS.
	(loongarch_split_symbol_type): New function definitions.
	Determines whether the symbol load should be split into two instructions.
	(loongarch_valid_lo_sum_p): New function definitions.
	Return true if a LO_SUM can address a value of mode MODE when the LO_SUM
	symbol has type SYMBOL_TYPE.
	(loongarch_classify_address): Add handling of 'LO_SUM'.
	(loongarch_address_insns): Add handling of 'ADDRESS_LO_SUM'.
	(loongarch_signed_immediate_p): Sort code.
	(loongarch_12bit_offset_address_p): Return true if address type is ADDRESS_LO_SUM.
	(loongarch_const_insns): Add handling of 'HIGH'.
	(loongarch_split_move_insn_p): Add the static attribute to the function.
	(loongarch_emit_set): New function definitions.
	(loongarch_call_tls_get_addr): Add symbol handling when defining TARGET_EXPLICIT_RELOCS.
	(loongarch_legitimize_tls_address): Add symbol handling when defining the
	TARGET_EXPLICIT_RELOCS macro.
	(loongarch_split_symbol): New function definitions. Split symbol.
	(loongarch_legitimize_address): Add codes see if the address can split into a high part
	and a LO_SUM.
	(loongarch_legitimize_const_move): Add codes split moves of symbolic constants into
	high and low.
	(loongarch_split_move_insn): Delete function definitions.
	(loongarch_output_move): Add support for HIGH and LO_SUM.
	(loongarch_print_operand_reloc): New function definitions.
	Print symbolic operand OP, which is part of a HIGH or LO_SUM in context CONTEXT.
	(loongarch_memmodel_needs_release_fence): Sort code.
	(loongarch_print_operand): Rearrange alphabetical order and add H and L to support HIGH
	and LOW output.
	(loongarch_print_operand_address): Add handling of 'ADDRESS_LO_SUM'.
	(TARGET_MIN_ANCHOR_OFFSET): Define macro to -IMM_REACH/2.
	(TARGET_MAX_ANCHOR_OFFSET): Define macro to IMM_REACH/2-1.
	* config/loongarch/loongarch.md (movti): Delete the template.
	(*movti): Delete the template.
	(movtf): Delete the template.
	(*movtf): Delete the template.
	(*low<mode>): New template of normal symbol low address.
	(@tls_low<mode>): New template of tls symbol low address.
	(@ld_from_got<mode>): New template load address from got table.
	(@ori_l_lo12<mode>): New template.
	* config/loongarch/loongarch.opt: Update from loongarch.opt.in.
	* config/loongarch/predicates.md: Add support for symbol_type HIGH.

gcc/testsuite/ChangeLog:

	* gcc.target/loongarch/func-call-1.c: Add build option '-mno-explicit-relocs'.
	* gcc.target/loongarch/func-call-2.c: Add build option '-mno-explicit-relocs'.
	* gcc.target/loongarch/func-call-3.c: Add build option '-mno-explicit-relocs'.
	* gcc.target/loongarch/func-call-4.c: Add build option '-mno-explicit-relocs'.
	* gcc.target/loongarch/func-call-5.c: New test.
	* gcc.target/loongarch/func-call-6.c: New test.
	* gcc.target/loongarch/func-call-7.c: New test.
	* gcc.target/loongarch/func-call-8.c: New test.
	* gcc.target/loongarch/relocs-symbol-noaddend.c: New test.
---
 .../config/loongarch/loongarch-common.cc      |   1 +
 gcc/config/loongarch/genopts/loongarch.opt.in |   4 +
 gcc/config/loongarch/loongarch-protos.h       |   3 +-
 gcc/config/loongarch/loongarch.cc             | 412 ++++++++++++++++--
 gcc/config/loongarch/loongarch.md             | 122 +++---
 gcc/config/loongarch/loongarch.opt            |   4 +
 gcc/config/loongarch/predicates.md            |  20 +-
 .../gcc.target/loongarch/func-call-1.c        |   2 +-
 .../gcc.target/loongarch/func-call-2.c        |   2 +-
 .../gcc.target/loongarch/func-call-3.c        |   2 +-
 .../gcc.target/loongarch/func-call-4.c        |   2 +-
 .../gcc.target/loongarch/func-call-5.c        |  33 ++
 .../gcc.target/loongarch/func-call-6.c        |  33 ++
 .../gcc.target/loongarch/func-call-7.c        |  34 ++
 .../gcc.target/loongarch/func-call-8.c        |  33 ++
 .../loongarch/relocs-symbol-noaddend.c        |  23 +
 16 files changed, 614 insertions(+), 116 deletions(-)
 create mode 100644 gcc/testsuite/gcc.target/loongarch/func-call-5.c
 create mode 100644 gcc/testsuite/gcc.target/loongarch/func-call-6.c
 create mode 100644 gcc/testsuite/gcc.target/loongarch/func-call-7.c
 create mode 100644 gcc/testsuite/gcc.target/loongarch/func-call-8.c
 create mode 100644 gcc/testsuite/gcc.target/loongarch/relocs-symbol-noaddend.c

diff --git a/gcc/common/config/loongarch/loongarch-common.cc b/gcc/common/config/loongarch/loongarch-common.cc
index ed3730fce8b..f8b4660fabf 100644
--- a/gcc/common/config/loongarch/loongarch-common.cc
+++ b/gcc/common/config/loongarch/loongarch-common.cc
@@ -34,6 +34,7 @@ along with GCC; see the file COPYING3.  If not see
 static const struct default_options loongarch_option_optimization_table[] =
 {
   { OPT_LEVELS_ALL, OPT_fasynchronous_unwind_tables, NULL, 1 },
+  { OPT_LEVELS_1_PLUS, OPT_fsection_anchors, NULL, 1 },
   { OPT_LEVELS_NONE, 0, NULL, 0 }
 };
 
diff --git a/gcc/config/loongarch/genopts/loongarch.opt.in b/gcc/config/loongarch/genopts/loongarch.opt.in
index 61e7d72a0a1..6f39500935d 100644
--- a/gcc/config/loongarch/genopts/loongarch.opt.in
+++ b/gcc/config/loongarch/genopts/loongarch.opt.in
@@ -154,6 +154,10 @@ mmax-inline-memcpy-size=
 Target Joined RejectNegative UInteger Var(loongarch_max_inline_memcpy_size) Init(1024)
 -mmax-inline-memcpy-size=SIZE	Set the max size of memcpy to inline, default is 1024.
 
+mexplicit-relocs
+Target Var(TARGET_EXPLICIT_RELOCS) Init(1)
+Use %reloc() assembly operators.
+
 ; The code model option names for -mcmodel.
 Enum
 Name(cmodel) Type(int)
diff --git a/gcc/config/loongarch/loongarch-protos.h b/gcc/config/loongarch/loongarch-protos.h
index 080766250d1..cadaad7519c 100644
--- a/gcc/config/loongarch/loongarch-protos.h
+++ b/gcc/config/loongarch/loongarch-protos.h
@@ -77,8 +77,6 @@ extern rtx loongarch_legitimize_call_address (rtx);
 extern rtx loongarch_subword (rtx, bool);
 extern bool loongarch_split_move_p (rtx, rtx);
 extern void loongarch_split_move (rtx, rtx, rtx);
-extern bool loongarch_split_move_insn_p (rtx, rtx);
-extern void loongarch_split_move_insn (rtx, rtx, rtx);
 extern const char *loongarch_output_move (rtx, rtx);
 extern bool loongarch_cfun_has_cprestore_slot_p (void);
 #ifdef RTX_CODE
@@ -160,6 +158,7 @@ extern rtx loongarch_expand_thread_pointer (rtx);
 extern bool loongarch_eh_uses (unsigned int);
 extern bool loongarch_epilogue_uses (unsigned int);
 extern bool loongarch_load_store_bonding_p (rtx *, machine_mode, bool);
+extern bool loongarch_split_symbol_type (enum loongarch_symbol_type);
 
 typedef rtx (*mulsidi3_gen_fn) (rtx, rtx, rtx);
 
diff --git a/gcc/config/loongarch/loongarch.cc b/gcc/config/loongarch/loongarch.cc
index 1cb5742f6dd..79687340dfd 100644
--- a/gcc/config/loongarch/loongarch.cc
+++ b/gcc/config/loongarch/loongarch.cc
@@ -100,6 +100,10 @@ along with GCC; see the file COPYING3.  If not see
    ADDRESS_REG_REG
        A base register indexed by (optionally scaled) register.
 
+   ADDRESS_LO_SUM
+       A LO_SUM rtx.  The first operand is a valid base register and the second
+       operand is a symbolic address.
+
    ADDRESS_CONST_INT
        A signed 16-bit constant address.
 
@@ -109,6 +113,7 @@ enum loongarch_address_type
 {
   ADDRESS_REG,
   ADDRESS_REG_REG,
+  ADDRESS_LO_SUM,
   ADDRESS_CONST_INT,
   ADDRESS_SYMBOLIC
 };
@@ -1641,6 +1646,21 @@ loongarch_classify_symbol (const_rtx x)
   return SYMBOL_PCREL;
 }
 
+/* Classify the base of symbolic expression X, given that X appears in
+   context CONTEXT.  */
+
+static enum loongarch_symbol_type
+loongarch_classify_symbolic_expression (rtx x)
+{
+  rtx offset;
+
+  split_const (x, &x, &offset);
+  if (UNSPEC_ADDRESS_P (x))
+    return UNSPEC_ADDRESS_TYPE (x);
+
+  return loongarch_classify_symbol (x);
+}
+
 /* Return true if X is a symbolic constant.  If it is,
    store the type of the symbol in *SYMBOL_TYPE.  */
 
@@ -1696,7 +1716,7 @@ loongarch_symbol_insns (enum loongarch_symbol_type type, machine_mode mode)
     case SYMBOL_GOT_DISP:
       /* The constant will have to be loaded from the GOT before it
 	 is used in an address.  */
-      if (mode != MAX_MACHINE_MODE)
+      if (!TARGET_EXPLICIT_RELOCS && mode != MAX_MACHINE_MODE)
 	return 0;
 
       return 3;
@@ -1814,6 +1834,84 @@ loongarch_valid_offset_p (rtx x, machine_mode mode)
   return true;
 }
 
+/* Should a symbol of type SYMBOL_TYPE should be split in two?  */
+
+bool
+loongarch_split_symbol_type (enum loongarch_symbol_type symbol_type)
+{
+  switch (symbol_type)
+    {
+    case SYMBOL_PCREL:
+    case SYMBOL_GOT_DISP:
+    case SYMBOL_TLS_IE:
+    case SYMBOL_TLS_LE:
+    case SYMBOL_TLSGD:
+    case SYMBOL_TLSLDM:
+      return true;
+
+    case SYMBOL_TLS:
+      return false;
+
+    default:
+      gcc_unreachable ();
+    }
+}
+
+/* Return true if a LO_SUM can address a value of mode MODE when the
+   LO_SUM symbol has type SYMBOL_TYPE.  */
+
+static bool
+loongarch_valid_lo_sum_p (enum loongarch_symbol_type symbol_type,
+			  machine_mode mode, rtx x)
+{
+  int align, size;
+
+  /* Check that symbols of type SYMBOL_TYPE can be used to access values
+     of mode MODE.  */
+  if (loongarch_symbol_insns (symbol_type, mode) == 0)
+    return false;
+
+  /* Check that there is a known low-part relocation.  */
+  if (!loongarch_split_symbol_type (symbol_type))
+    return false;
+
+  /* We can't tell size or alignment when we have BLKmode, so try extracing a
+     decl from the symbol if possible.  */
+  if (mode == BLKmode)
+    {
+      rtx offset;
+
+      /* Extract the symbol from the LO_SUM operand, if any.  */
+      split_const (x, &x, &offset);
+
+      /* Might be a CODE_LABEL.  We can compute align but not size for that,
+	 so don't bother trying to handle it.  */
+      if (!SYMBOL_REF_P (x))
+	return false;
+
+      /* Use worst case assumptions if we don't have a SYMBOL_REF_DECL.  */
+      align = (SYMBOL_REF_DECL (x)
+	       ? DECL_ALIGN (SYMBOL_REF_DECL (x))
+	       : 1);
+      size = (SYMBOL_REF_DECL (x) && DECL_SIZE (SYMBOL_REF_DECL (x))
+	      ? tree_to_uhwi (DECL_SIZE (SYMBOL_REF_DECL (x)))
+	      : 2*BITS_PER_WORD);
+    }
+  else
+    {
+      align = GET_MODE_ALIGNMENT (mode);
+      size = GET_MODE_BITSIZE (mode);
+    }
+
+  /* We may need to split multiword moves, so make sure that each word
+     can be accessed without inducing a carry.  */
+  if (size > BITS_PER_WORD
+      && (!TARGET_STRICT_ALIGN || size > align))
+    return false;
+
+  return true;
+}
+
 static bool
 loongarch_valid_index_p (struct loongarch_address_info *info, rtx x,
 			  machine_mode mode, bool strict_p)
@@ -1880,6 +1978,26 @@ loongarch_classify_address (struct loongarch_address_info *info, rtx x,
       info->offset = XEXP (x, 1);
       return (loongarch_valid_base_register_p (info->reg, mode, strict_p)
 	      && loongarch_valid_offset_p (info->offset, mode));
+
+    case LO_SUM:
+      info->type = ADDRESS_LO_SUM;
+      info->reg = XEXP (x, 0);
+      info->offset = XEXP (x, 1);
+      /* We have to trust the creator of the LO_SUM to do something vaguely
+	 sane.  Target-independent code that creates a LO_SUM should also
+	 create and verify the matching HIGH.  Target-independent code that
+	 adds an offset to a LO_SUM must prove that the offset will not
+	 induce a carry.  Failure to do either of these things would be
+	 a bug, and we are not required to check for it here.  The MIPS
+	 backend itself should only create LO_SUMs for valid symbolic
+	 constants, with the high part being either a HIGH or a copy
+	 of _gp. */
+      info->symbol_type
+	= loongarch_classify_symbolic_expression (info->offset);
+      return (loongarch_valid_base_register_p (info->reg, mode, strict_p)
+	      && loongarch_valid_lo_sum_p (info->symbol_type, mode,
+					   info->offset));
+
     default:
       return false;
     }
@@ -1940,6 +2058,9 @@ loongarch_address_insns (rtx x, machine_mode mode, bool might_split_p)
       case ADDRESS_CONST_INT:
 	return factor;
 
+      case ADDRESS_LO_SUM:
+	return factor + 1;
+
       case ADDRESS_SYMBOLIC:
 	return factor * loongarch_symbol_insns (addr.symbol_type, mode);
       }
@@ -1967,7 +2088,8 @@ loongarch_signed_immediate_p (unsigned HOST_WIDE_INT x, int bits,
   return loongarch_unsigned_immediate_p (x, bits, shift);
 }
 
-/* Return true if X is a legitimate address with a 12-bit offset.
+/* Return true if X is a legitimate address with a 12-bit offset
+   or addr.type is ADDRESS_LO_SUM.
    MODE is the mode of the value being accessed.  */
 
 bool
@@ -1976,9 +2098,10 @@ loongarch_12bit_offset_address_p (rtx x, machine_mode mode)
   struct loongarch_address_info addr;
 
   return (loongarch_classify_address (&addr, x, mode, false)
-	  && addr.type == ADDRESS_REG
-	  && CONST_INT_P (addr.offset)
-	  && LARCH_12BIT_OFFSET_P (INTVAL (addr.offset)));
+	  && ((addr.type == ADDRESS_REG
+	       && CONST_INT_P (addr.offset)
+	       && LARCH_12BIT_OFFSET_P (INTVAL (addr.offset)))
+	      || addr.type == ADDRESS_LO_SUM));
 }
 
 /* Return true if X is a legitimate address with a 14-bit offset shifted 2.
@@ -2020,6 +2143,14 @@ loongarch_const_insns (rtx x)
 
   switch (GET_CODE (x))
     {
+    case HIGH:
+      if (!loongarch_symbolic_constant_p (XEXP (x, 0), &symbol_type)
+	  || !loongarch_split_symbol_type (symbol_type))
+	return 0;
+
+      /* This is simply a PCALAU12I.  */
+      return 1;
+
     case CONST_INT:
       return loongarch_integer_cost (INTVAL (x));
 
@@ -2080,6 +2211,8 @@ loongarch_split_const_insns (rtx x)
   return low + high;
 }
 
+static bool loongarch_split_move_insn_p (rtx dest, rtx src);
+
 /* Return the number of instructions needed to implement INSN,
    given that it loads from or stores to MEM.  */
 
@@ -2197,6 +2330,15 @@ loongarch_unspec_address (rtx address, enum loongarch_symbol_type symbol_type)
   return loongarch_unspec_address_offset (base, offset, symbol_type);
 }
 
+/* Emit an instruction of the form (set TARGET SRC).  */
+
+static rtx
+loongarch_emit_set (rtx target, rtx src)
+{
+  emit_insn (gen_rtx_SET (target, src));
+  return target;
+}
+
 /* If OP is an UNSPEC address, return the address to which it refers,
    otherwise return OP itself.  */
 
@@ -2278,6 +2420,7 @@ loongarch_call_tls_get_addr (rtx sym, enum loongarch_symbol_type type, rtx v0)
 {
   rtx loc, a0;
   rtx_insn *insn;
+  rtx tmp = gen_reg_rtx (Pmode);
 
   a0 = gen_rtx_REG (Pmode, GP_ARG_FIRST);
 
@@ -2288,12 +2431,22 @@ loongarch_call_tls_get_addr (rtx sym, enum loongarch_symbol_type type, rtx v0)
 
   start_sequence ();
 
-  if (type == SYMBOL_TLSLDM)
-    emit_insn (loongarch_got_load_tls_ld (a0, loc));
-  else if (type == SYMBOL_TLSGD)
-    emit_insn (loongarch_got_load_tls_gd (a0, loc));
+  if (TARGET_EXPLICIT_RELOCS)
+    {
+      /* Split tls symbol to high and low.  */
+      rtx high = gen_rtx_HIGH (Pmode, copy_rtx (loc));
+      high = loongarch_force_temporary (tmp, high);
+      emit_insn (gen_tls_low (Pmode, a0, high, loc));
+    }
   else
-    gcc_unreachable ();
+    {
+      if (type == SYMBOL_TLSLDM)
+	emit_insn (loongarch_got_load_tls_ld (a0, loc));
+      else if (type == SYMBOL_TLSGD)
+	emit_insn (loongarch_got_load_tls_gd (a0, loc));
+      else
+	gcc_unreachable ();
+    }
 
   insn = emit_call_insn (gen_call_value_internal (v0, loongarch_tls_symbol,
 						  const0_rtx));
@@ -2308,12 +2461,12 @@ loongarch_call_tls_get_addr (rtx sym, enum loongarch_symbol_type type, rtx v0)
 
 /* Generate the code to access LOC, a thread-local SYMBOL_REF, and return
    its address.  The return value will be both a valid address and a valid
-   SET_SRC.  */
+   SET_SRC (either a REG or a LO_SUM).  */
 
 static rtx
 loongarch_legitimize_tls_address (rtx loc)
 {
-  rtx dest, tp, tmp;
+  rtx dest, tp, tmp, tmp1, tmp2, tmp3;
   enum tls_model model = SYMBOL_REF_TLS_MODEL (loc);
   rtx_insn *insn;
 
@@ -2334,21 +2487,45 @@ loongarch_legitimize_tls_address (rtx loc)
       break;
 
     case TLS_MODEL_INITIAL_EXEC:
-      /* la.tls.ie; tp-relative add.  */
-      tp = gen_rtx_REG (Pmode, THREAD_POINTER_REGNUM);
-      tmp = gen_reg_rtx (Pmode);
-      emit_insn (loongarch_got_load_tls_ie (tmp, loc));
-      dest = gen_reg_rtx (Pmode);
-      emit_insn (gen_add3_insn (dest, tmp, tp));
+	{
+	  /* la.tls.ie; tp-relative add.  */
+	  tp = gen_rtx_REG (Pmode, THREAD_POINTER_REGNUM);
+	  tmp1 = gen_reg_rtx (Pmode);
+	  dest = gen_reg_rtx (Pmode);
+	  if (TARGET_EXPLICIT_RELOCS)
+	    {
+	      tmp2 = loongarch_unspec_address (loc, SYMBOL_TLS_IE);
+	      tmp3 = gen_reg_rtx (Pmode);
+	      rtx high = gen_rtx_HIGH (Pmode, copy_rtx (tmp2));
+	      high = loongarch_force_temporary (tmp3, high);
+	      emit_insn (gen_ld_from_got (Pmode, tmp1, high, tmp2));
+	    }
+	  else
+	    emit_insn (loongarch_got_load_tls_ie (tmp1, loc));
+	  emit_insn (gen_add3_insn (dest, tmp1, tp));
+	}
       break;
 
     case TLS_MODEL_LOCAL_EXEC:
-      /* la.tls.le; tp-relative add.  */
-      tp = gen_rtx_REG (Pmode, THREAD_POINTER_REGNUM);
-      tmp = gen_reg_rtx (Pmode);
-      emit_insn (loongarch_got_load_tls_le (tmp, loc));
-      dest = gen_reg_rtx (Pmode);
-      emit_insn (gen_add3_insn (dest, tmp, tp));
+	{
+	  /* la.tls.le; tp-relative add.  */
+	  tp = gen_rtx_REG (Pmode, THREAD_POINTER_REGNUM);
+	  tmp1 = gen_reg_rtx (Pmode);
+	  dest = gen_reg_rtx (Pmode);
+
+	  if (TARGET_EXPLICIT_RELOCS)
+	    {
+	      tmp2 = loongarch_unspec_address (loc, SYMBOL_TLS_LE);
+	      tmp3 = gen_reg_rtx (Pmode);
+	      rtx high = gen_rtx_HIGH (Pmode, copy_rtx (tmp2));
+	      high = loongarch_force_temporary (tmp3, high);
+	      emit_insn (gen_ori_l_lo12 (Pmode, tmp1, high, tmp2));
+	    }
+	  else
+	    emit_insn (loongarch_got_load_tls_le (tmp1, loc));
+	  emit_insn (gen_add3_insn (dest, tmp1, tp));
+
+	}
       break;
 
     default:
@@ -2397,6 +2574,68 @@ loongarch_force_address (rtx x, machine_mode mode)
   return x;
 }
 
+/* If MODE is MAX_MACHINE_MODE, ADDR appears as a move operand, otherwise
+   it appears in a MEM of that mode.  Return true if ADDR is a legitimate
+   constant in that context and can be split into high and low parts.
+   If so, and if LOW_OUT is nonnull, emit the high part and store the
+   low part in *LOW_OUT.  Leave *LOW_OUT unchanged otherwise.
+
+   Return false if build with '-mno-explicit-relocs'.
+
+   TEMP is as for loongarch_force_temporary and is used to load the high
+   part into a register.
+
+   When MODE is MAX_MACHINE_MODE, the low part is guaranteed to be
+   a legitimize SET_SRC for an .md pattern, otherwise the low part
+   is guaranteed to be a legitimate address for mode MODE.  */
+
+bool
+loongarch_split_symbol (rtx temp, rtx addr, machine_mode mode, rtx *low_out)
+{
+  enum loongarch_symbol_type symbol_type;
+  rtx high;
+
+  /* If build with '-mno-explicit-relocs', don't split symbol.  */
+  if (!TARGET_EXPLICIT_RELOCS)
+    return false;
+
+  if ((GET_CODE (addr) == HIGH && mode == MAX_MACHINE_MODE)
+      || !loongarch_symbolic_constant_p (addr, &symbol_type)
+      || loongarch_symbol_insns (symbol_type, mode) == 0
+      || !loongarch_split_symbol_type (symbol_type))
+    return false;
+
+  if (temp == NULL)
+    temp = gen_reg_rtx (Pmode);
+
+  /* Get the 12-31 bits of the address.  */
+  high = gen_rtx_HIGH (Pmode, copy_rtx (addr));
+  high = loongarch_force_temporary (temp, high);
+
+  if (low_out)
+    switch (symbol_type)
+      {
+      case SYMBOL_PCREL:
+	*low_out = gen_rtx_LO_SUM (Pmode, high, addr);
+	break;
+
+      case SYMBOL_GOT_DISP:
+	/* SYMBOL_GOT_DISP symbols are loaded from the GOT.  */
+	{
+	  rtx low = gen_rtx_LO_SUM (Pmode, high, addr);
+	  rtx mem = gen_rtx_MEM (Pmode, low);
+	  *low_out = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, mem),
+				     UNSPEC_LOAD_FROM_GOT);
+	  break;
+	}
+
+      default:
+	gcc_unreachable ();
+      }
+
+  return true;
+}
+
 /* This function is used to implement LEGITIMIZE_ADDRESS.  If X can
    be legitimized in a way that the generic machinery might not expect,
    return a new address, otherwise return NULL.  MODE is the mode of
@@ -2412,6 +2651,10 @@ loongarch_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,
   if (loongarch_tls_symbol_p (x))
     return loongarch_legitimize_tls_address (x);
 
+  /* See if the address can split into a high part and a LO_SUM.  */
+  if (loongarch_split_symbol (NULL, x, mode, &addr))
+    return loongarch_force_address (addr, mode);
+
   /* Handle BASE + OFFSET using loongarch_add_offset.  */
   loongarch_split_plus (x, &base, &offset);
   if (offset != 0)
@@ -2499,6 +2742,13 @@ loongarch_legitimize_const_move (machine_mode mode, rtx dest, rtx src)
       return;
     }
 
+  /* Split moves of symbolic constants into high and low.  */
+  if (loongarch_split_symbol (dest, src, MAX_MACHINE_MODE, &src))
+    {
+      loongarch_emit_set (dest, src);
+      return;
+    }
+
   /* Generate the appropriate access sequences for TLS symbols.  */
   if (loongarch_tls_symbol_p (src))
     {
@@ -3241,21 +3491,12 @@ loongarch_split_move (rtx dest, rtx src, rtx insn_)
 
 /* Return true if a move from SRC to DEST in INSN should be split.  */
 
-bool
+static bool
 loongarch_split_move_insn_p (rtx dest, rtx src)
 {
   return loongarch_split_move_p (dest, src);
 }
 
-/* Split a move from SRC to DEST in INSN, given that
-   loongarch_split_move_insn_p holds.  */
-
-void
-loongarch_split_move_insn (rtx dest, rtx src, rtx insn)
-{
-  loongarch_split_move (dest, src, insn);
-}
-
 /* Implement TARGET_CONSTANT_ALIGNMENT.  */
 
 static HOST_WIDE_INT
@@ -3369,13 +3610,16 @@ loongarch_output_move (rtx dest, rtx src)
 	    case 2:
 	      return "st.h\t%z1,%0";
 	    case 4:
-	      /* Matching address type with a 12bit offset.  */
-	      if (const_arith_operand (offset, Pmode))
+	      /* Matching address type with a 12bit offset and
+		 ADDRESS_LO_SUM.  */
+	      if (const_arith_operand (offset, Pmode)
+		  || GET_CODE (offset) == LO_SUM)
 		return "st.w\t%z1,%0";
 	      else
 		return "stptr.w\t%z1,%0";
 	    case 8:
-	      if (const_arith_operand (offset, Pmode))
+	      if (const_arith_operand (offset, Pmode)
+		  || GET_CODE (offset) == LO_SUM)
 		return "st.d\t%z1,%0";
 	      else
 		return "stptr.d\t%z1,%0";
@@ -3408,13 +3652,16 @@ loongarch_output_move (rtx dest, rtx src)
 	    case 2:
 	      return "ld.hu\t%0,%1";
 	    case 4:
-	      /* Matching address type with a 12bit offset.  */
-	      if (const_arith_operand (offset, Pmode))
+	      /* Matching address type with a 12bit offset and
+		 ADDRESS_LO_SUM.  */
+	      if (const_arith_operand (offset, Pmode)
+		  || GET_CODE (offset) == LO_SUM)
 		return "ld.w\t%0,%1";
 	      else
 		return "ldptr.w\t%0,%1";
 	    case 8:
-	      if (const_arith_operand (offset, Pmode))
+	      if (const_arith_operand (offset, Pmode)
+		  || GET_CODE (offset) == LO_SUM)
 		return "ld.d\t%0,%1";
 	      else
 		return "ldptr.d\t%0,%1";
@@ -3423,6 +3670,21 @@ loongarch_output_move (rtx dest, rtx src)
 	    }
 	}
 
+      if (src_code == HIGH)
+	{
+	  rtx offset, x;
+	  split_const (XEXP (src, 0), &x, &offset);
+	  enum loongarch_symbol_type type = SYMBOL_PCREL;
+
+	  if (UNSPEC_ADDRESS_P (x))
+	     type = UNSPEC_ADDRESS_TYPE (x);
+
+	  if (type == SYMBOL_TLS_LE)
+	    return "lu12i.w\t%0,%h1";
+	  else
+	    return "pcalau12i\t%0,%h1";
+	}
+
       if (src_code == CONST_INT)
 	{
 	  if (LU12I_INT (src))
@@ -3438,7 +3700,8 @@ loongarch_output_move (rtx dest, rtx src)
 	}
     }
 
-  if (dest_code == REG && symbolic_operand (src, VOIDmode))
+  if (!TARGET_EXPLICIT_RELOCS
+      && dest_code == REG && symbolic_operand (src, VOIDmode))
     {
       if (loongarch_classify_symbol (src) == SYMBOL_PCREL)
 	return "la.local\t%0,%1";
@@ -4307,6 +4570,49 @@ loongarch_memmodel_needs_release_fence (enum memmodel model)
     }
 }
 
+/* Print symbolic operand OP, which is part of a HIGH or LO_SUM
+   in context CONTEXT.  HI_RELOC indicates a high-part reloc.  */
+
+static void
+loongarch_print_operand_reloc (FILE *file, rtx op, bool hi_reloc)
+{
+  const char *reloc;
+
+  switch (loongarch_classify_symbolic_expression (op))
+    {
+    case SYMBOL_PCREL:
+      reloc = hi_reloc ? "%pc_hi20" : "%pc_lo12";
+      break;
+
+    case SYMBOL_GOT_DISP:
+      reloc = hi_reloc ? "%got_pc_hi20" : "%got_pc_lo12";
+      break;
+
+    case SYMBOL_TLS_IE:
+      reloc = hi_reloc ? "%ie_pc_hi20" : "%ie_pc_lo12";
+      break;
+
+    case SYMBOL_TLS_LE:
+      reloc = hi_reloc ? "%le_hi20" : "%le_lo12";
+      break;
+
+    case SYMBOL_TLSGD:
+      reloc = hi_reloc ? "%gd_pc_hi20" : "%got_pc_lo12";
+      break;
+
+    case SYMBOL_TLSLDM:
+      reloc = hi_reloc ? "%ld_pc_hi20" : "%got_pc_lo12";
+      break;
+
+    default:
+      gcc_unreachable ();
+    }
+
+  fprintf (file, "%s(", reloc);
+  output_addr_const (file, loongarch_strip_unspec_address (op));
+  fputc (')', file);
+}
+
 /* Implement TARGET_PRINT_OPERAND.  The LoongArch-specific operand codes are:
 
    'A'	Print a _DB suffix if the memory model requires a release.
@@ -4315,7 +4621,10 @@ loongarch_memmodel_needs_release_fence (enum memmodel model)
    'd'	Print CONST_INT OP in decimal.
    'F'	Print the FPU branch condition for comparison OP.
    'G'	Print a DBAR insn if the memory model requires a release.
+   'H'  Print address 52-61bit relocation associated with OP.
+   'h'  Print the high-part relocation associated with OP.
    'i'	Print i if the operand is not a register.
+   'L'  Print the low-part relocation associated with OP.
    'm'	Print one less than CONST_INT OP in decimal.
    'N'	Print the inverse of the integer branch condition for comparison OP.
    'T'	Print 'f' for (eq:CC ...), 't' for (ne:CC ...),
@@ -4372,11 +4681,21 @@ loongarch_print_operand (FILE *file, rtx op, int letter)
 	fputs ("dbar\t0", file);
       break;
 
+    case 'h':
+      if (code == HIGH)
+	op = XEXP (op, 0);
+      loongarch_print_operand_reloc (file, op, true /* hi_reloc */);
+      break;
+
     case 'i':
       if (code != REG)
 	fputs ("i", file);
       break;
 
+    case 'L':
+      loongarch_print_operand_reloc (file, op, false /* lo_reloc */);
+      break;
+
     case 'm':
       if (CONST_INT_P (op))
 	fprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (op) - 1);
@@ -4517,6 +4836,11 @@ loongarch_print_operand_address (FILE *file, machine_mode /* mode  */, rtx x)
 				reg_names[REGNO (addr.offset)]);
 	return;
 
+      case ADDRESS_LO_SUM:
+	fprintf (file, "%s,", reg_names[REGNO (addr.reg)]);
+	loongarch_print_operand_reloc (file, addr.offset, false /* hi_reloc */);
+	return;
+
       case ADDRESS_CONST_INT:
 	fprintf (file, "%s,", reg_names[GP_REG_FIRST]);
 	output_addr_const (file, x);
@@ -5891,6 +6215,12 @@ loongarch_starting_frame_offset (void)
 #undef TARGET_TRAMPOLINE_INIT
 #define TARGET_TRAMPOLINE_INIT loongarch_trampoline_init
 
+#undef TARGET_MIN_ANCHOR_OFFSET
+#define TARGET_MIN_ANCHOR_OFFSET (-IMM_REACH/2)
+
+#undef TARGET_MAX_ANCHOR_OFFSET
+#define TARGET_MAX_ANCHOR_OFFSET (IMM_REACH/2-1)
+
 #undef TARGET_ATOMIC_ASSIGN_EXPAND_FENV
 #define TARGET_ATOMIC_ASSIGN_EXPAND_FENV loongarch_atomic_assign_expand_fenv
 
diff --git a/gcc/config/loongarch/loongarch.md b/gcc/config/loongarch/loongarch.md
index 376879fbccb..6b6df22a5f1 100644
--- a/gcc/config/loongarch/loongarch.md
+++ b/gcc/config/loongarch/loongarch.md
@@ -57,6 +57,10 @@
   ;; CRC
   UNSPEC_CRC
   UNSPEC_CRCC
+
+  UNSPEC_LOAD_FROM_GOT
+  UNSPEC_ORI_L_LO12
+  UNSPEC_TLS_LOW
 ])
 
 (define_c_enum "unspecv" [
@@ -1743,73 +1747,6 @@
   [(set_attr "move_type" "move,load,store")
    (set_attr "mode" "DF")])
 
-
-;; 128-bit integer moves
-
-(define_expand "movti"
-  [(set (match_operand:TI 0)
-	(match_operand:TI 1))]
-  "TARGET_64BIT"
-{
-  if (loongarch_legitimize_move (TImode, operands[0], operands[1]))
-    DONE;
-})
-
-(define_insn "*movti"
-  [(set (match_operand:TI 0 "nonimmediate_operand" "=r,r,r,m")
-	(match_operand:TI 1 "move_operand" "r,i,m,rJ"))]
-  "TARGET_64BIT
-   && (register_operand (operands[0], TImode)
-       || reg_or_0_operand (operands[1], TImode))"
-  { return loongarch_output_move (operands[0], operands[1]); }
-  [(set_attr "move_type" "move,const,load,store")
-   (set (attr "mode")
-    (if_then_else (eq_attr "move_type" "imul")
-		      (const_string "SI")
-		      (const_string "TI")))])
-
-;; 128-bit floating point moves
-
-(define_expand "movtf"
-  [(set (match_operand:TF 0)
-	(match_operand:TF 1))]
-  "TARGET_64BIT"
-{
-  if (loongarch_legitimize_move (TFmode, operands[0], operands[1]))
-    DONE;
-})
-
-;; This pattern handles both hard- and soft-float cases.
-(define_insn "*movtf"
-  [(set (match_operand:TF 0 "nonimmediate_operand" "=r,r,m,f,r,f,m")
-	(match_operand:TF 1 "move_operand" "rG,m,rG,rG,f,m,f"))]
-  "TARGET_64BIT
-   && (register_operand (operands[0], TFmode)
-       || reg_or_0_operand (operands[1], TFmode))"
-  "#"
-  [(set_attr "move_type" "move,load,store,mgtf,mftg,fpload,fpstore")
-   (set_attr "mode" "TF")])
-
-(define_split
-  [(set (match_operand:MOVE64 0 "nonimmediate_operand")
-	(match_operand:MOVE64 1 "move_operand"))]
-  "reload_completed && loongarch_split_move_insn_p (operands[0], operands[1])"
-  [(const_int 0)]
-{
-  loongarch_split_move_insn (operands[0], operands[1], curr_insn);
-  DONE;
-})
-
-(define_split
-  [(set (match_operand:MOVE128 0 "nonimmediate_operand")
-	(match_operand:MOVE128 1 "move_operand"))]
-  "reload_completed && loongarch_split_move_insn_p (operands[0], operands[1])"
-  [(const_int 0)]
-{
-  loongarch_split_move_insn (operands[0], operands[1], curr_insn);
-  DONE;
-})
-
 ;; Emit a doubleword move in which exactly one of the operands is
 ;; a floating-point register.  We can't just emit two normal moves
 ;; because of the constraints imposed by the FPU register model;
@@ -1938,6 +1875,57 @@
   [(set_attr "type" "arith")
    (set_attr "mode" "DI")])
 
+;; Instructions for adding the low 12 bits of an address to a register.
+;; Operand 2 is the address: loongarch_print_operand works out which relocation
+;; should be applied.
+
+(define_insn "*low<mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+ (lo_sum:P (match_operand:P 1 "register_operand" " r")
+     (match_operand:P 2 "symbolic_operand" "")))]
+  "TARGET_EXPLICIT_RELOCS"
+  "addi.<d>\t%0,%1,%L2"
+  [(set_attr "type" "arith")
+   (set_attr "mode" "<MODE>")])
+
+(define_insn "@tls_low<mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+	(unspec:P [(mem:P (lo_sum:P (match_operand:P 1 "register_operand" "r")
+				    (match_operand:P 2 "symbolic_operand" "")))]
+	UNSPEC_TLS_LOW))]
+  "TARGET_EXPLICIT_RELOCS"
+  "addi.<d>\t%0,%1,%L2"
+  [(set_attr "type" "arith")
+   (set_attr "mode" "<MODE>")])
+
+;; Instructions for loading address from GOT entry.
+;; operands[1] is pc plus the high half of the address difference with the got
+;; entry;
+;; operands[2] is low 12 bits for low 12 bit of the address difference with the
+;; got entry.
+;; loongarch_print_operand works out which relocation should be applied.
+
+(define_insn "@ld_from_got<mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+	(unspec:P [(mem:P (lo_sum:P
+				(match_operand:P 1 "register_operand" "r")
+				(match_operand:P 2 "symbolic_operand")))]
+	UNSPEC_LOAD_FROM_GOT))]
+  "TARGET_EXPLICIT_RELOCS"
+  "ld.<d>\t%0,%1,%L2"
+  [(set_attr "type" "move")]
+)
+
+(define_insn "@ori_l_lo12<mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+	(unspec:P [(match_operand:P 1 "register_operand" "r")
+		    (match_operand:P 2 "symbolic_operand")]
+	UNSPEC_ORI_L_LO12))]
+  ""
+  "ori\t%0,%1,%L2"
+  [(set_attr "type" "move")]
+)
+
 ;; Convert floating-point numbers to integers
 (define_insn "frint_<fmt>"
   [(set (match_operand:ANYF 0 "register_operand" "=f")
diff --git a/gcc/config/loongarch/loongarch.opt b/gcc/config/loongarch/loongarch.opt
index 3ff0d860413..7a8c5b44418 100644
--- a/gcc/config/loongarch/loongarch.opt
+++ b/gcc/config/loongarch/loongarch.opt
@@ -161,6 +161,10 @@ mmax-inline-memcpy-size=
 Target Joined RejectNegative UInteger Var(loongarch_max_inline_memcpy_size) Init(1024)
 -mmax-inline-memcpy-size=SIZE	Set the max size of memcpy to inline, default is 1024.
 
+mexplicit-relocs
+Target Var(TARGET_EXPLICIT_RELOCS) Init(1)
+Use %reloc() assembly operators.
+
 ; The code model option names for -mcmodel.
 Enum
 Name(cmodel) Type(int)
diff --git a/gcc/config/loongarch/predicates.md b/gcc/config/loongarch/predicates.md
index 2243ef71c1a..cd3528c7c97 100644
--- a/gcc/config/loongarch/predicates.md
+++ b/gcc/config/loongarch/predicates.md
@@ -110,6 +110,10 @@
 (define_predicate "const_call_insn_operand"
   (match_code "const,symbol_ref,label_ref")
 {
+  /* Split symbol to high and low if return false.
+     If defined TARGET_CMODEL_LARGE, all symbol would be splited,
+     else if offset is not zero, the symbol would be splited.  */
+
   enum loongarch_symbol_type symbol_type;
   loongarch_symbolic_constant_p (op, &symbol_type);
 
@@ -125,7 +129,7 @@
       return 1;
 
     case SYMBOL_GOT_DISP:
-      if (!flag_plt)
+      if (TARGET_CMODEL_LARGE || !flag_plt)
 	return false;
       else
 	return 1;
@@ -213,7 +217,19 @@
     case CONST:
     case SYMBOL_REF:
     case LABEL_REF:
-      return loongarch_symbolic_constant_p (op, &symbol_type);
+      return (loongarch_symbolic_constant_p (op, &symbol_type)
+	      && (!TARGET_EXPLICIT_RELOCS
+		  || !loongarch_split_symbol_type (symbol_type)));
+
+    case HIGH:
+      /* '-mno-explicit-relocs' don't generate high/low pairs.  */
+      if (!TARGET_EXPLICIT_RELOCS)
+	return false;
+
+      op = XEXP (op, 0);
+      return (loongarch_symbolic_constant_p (op, &symbol_type)
+	      && loongarch_split_symbol_type (symbol_type));
+
     default:
       return true;
     }
diff --git a/gcc/testsuite/gcc.target/loongarch/func-call-1.c b/gcc/testsuite/gcc.target/loongarch/func-call-1.c
index b0482761aab..01b8ea23fb9 100644
--- a/gcc/testsuite/gcc.target/loongarch/func-call-1.c
+++ b/gcc/testsuite/gcc.target/loongarch/func-call-1.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-mabi=lp64d -O0 -fpic -fplt" } */
+/* { dg-options "-mabi=lp64d -O0 -fpic -fplt -mno-explicit-relocs" } */
 /* { dg-final { scan-assembler "test:.*bl\t%plt\\(g\\)\n" } } */
 /* { dg-final { scan-assembler "test1:.*bl\t%plt\\(f\\)\n" } } */
 /* { dg-final { scan-assembler "test2:.*bl\tl\n" } } */
diff --git a/gcc/testsuite/gcc.target/loongarch/func-call-2.c b/gcc/testsuite/gcc.target/loongarch/func-call-2.c
index f5e061c299c..4565baaec9e 100644
--- a/gcc/testsuite/gcc.target/loongarch/func-call-2.c
+++ b/gcc/testsuite/gcc.target/loongarch/func-call-2.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-mabi=lp64d -O0 -fno-pic -fplt" } */
+/* { dg-options "-mabi=lp64d -O0 -fno-pic -fplt -mno-explicit-relocs" } */
 /* { dg-final { scan-assembler "test:.*bl\t%plt\\(g\\)\n" } } */
 /* { dg-final { scan-assembler "test1:.*bl\tf\n" } } */
 /* { dg-final { scan-assembler "test2:.*bl\tl\n" } } */
diff --git a/gcc/testsuite/gcc.target/loongarch/func-call-3.c b/gcc/testsuite/gcc.target/loongarch/func-call-3.c
index 75082c57466..4f669a029e7 100644
--- a/gcc/testsuite/gcc.target/loongarch/func-call-3.c
+++ b/gcc/testsuite/gcc.target/loongarch/func-call-3.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-mabi=lp64d -O0 -fpic -fno-plt" } */
+/* { dg-options "-mabi=lp64d -O0 -fpic -fno-plt -mno-explicit-relocs" } */
 /* { dg-final { scan-assembler "test:.*la\.global\t.*g\n\tjirl" } } */
 /* { dg-final { scan-assembler "test1:.*la\.global\t.*f\n\tjirl" } } */
 /* { dg-final { scan-assembler "test2:.*bl\tl\n" } } */
diff --git a/gcc/testsuite/gcc.target/loongarch/func-call-4.c b/gcc/testsuite/gcc.target/loongarch/func-call-4.c
index e8a8395493e..943adb6403f 100644
--- a/gcc/testsuite/gcc.target/loongarch/func-call-4.c
+++ b/gcc/testsuite/gcc.target/loongarch/func-call-4.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-mabi=lp64d -O0 -fno-pic -fno-plt" } */
+/* { dg-options "-mabi=lp64d -O0 -fno-pic -fno-plt -mno-explicit-relocs" } */
 /* { dg-final { scan-assembler "test:.*la\.global\t.*g\n\tjirl" } } */
 /* { dg-final { scan-assembler "test1:.*bl\tf\n" } } */
 /* { dg-final { scan-assembler "test2:.*bl\tl\n" } } */
diff --git a/gcc/testsuite/gcc.target/loongarch/func-call-5.c b/gcc/testsuite/gcc.target/loongarch/func-call-5.c
new file mode 100644
index 00000000000..2c2a1c8a1b6
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/func-call-5.c
@@ -0,0 +1,33 @@
+/* { dg-do compile } */
+/* { dg-options "-mabi=lp64d -O0 -fpic -fplt -mexplicit-relocs" } */
+/* { dg-final { scan-assembler "test:.*bl\t%plt\\(g\\)\n" } } */
+/* { dg-final { scan-assembler "test1:.*bl\t%plt\\(f\\)\n" } } */
+/* { dg-final { scan-assembler "test2:.*bl\tl\n" } } */
+
+extern void g (void);
+
+void
+f (void)
+{}
+
+static void
+l (void)
+{}
+
+void
+test (void)
+{
+  g ();
+}
+
+void
+test1 (void)
+{
+  f ();
+}
+
+void
+test2 (void)
+{
+  l ();
+}
diff --git a/gcc/testsuite/gcc.target/loongarch/func-call-6.c b/gcc/testsuite/gcc.target/loongarch/func-call-6.c
new file mode 100644
index 00000000000..4b0e4266ec8
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/func-call-6.c
@@ -0,0 +1,33 @@
+/* { dg-do compile } */
+/* { dg-options "-mabi=lp64d -O0 -fno-pic -fplt -mexplicit-relocs" } */
+/* { dg-final { scan-assembler "test:.*bl\t%plt\\(g\\)\n" } } */
+/* { dg-final { scan-assembler "test1:.*bl\tf\n" } } */
+/* { dg-final { scan-assembler "test2:.*bl\tl\n" } } */
+
+extern void g (void);
+
+void
+f (void)
+{}
+
+static void
+l (void)
+{}
+
+void
+test (void)
+{
+  g ();
+}
+
+void
+test1 (void)
+{
+  f ();
+}
+
+void
+test2 (void)
+{
+  l ();
+}
diff --git a/gcc/testsuite/gcc.target/loongarch/func-call-7.c b/gcc/testsuite/gcc.target/loongarch/func-call-7.c
new file mode 100644
index 00000000000..51792711f72
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/func-call-7.c
@@ -0,0 +1,34 @@
+/* { dg-do compile } */
+/* { dg-options "-mabi=lp64d -O0 -fpic -fno-plt -mexplicit-relocs" } */
+/* { dg-final { scan-assembler "test:.*pcalau12i\t.*%got_pc_hi20\\(g\\)\n\tld\.d\t.*%got_pc_lo12\\(g\\)\n\tjirl" } } */
+/* { dg-final { scan-assembler "test1:.*pcalau12i\t.*%got_pc_hi20\\(f\\)\n\tld\.d\t.*%got_pc_lo12\\(f\\)\n\tjirl" } } */
+/* { dg-final { scan-assembler "test2:.*bl\tl\n" } } */
+
+
+extern void g (void);
+
+void
+f (void)
+{}
+
+static void
+l (void)
+{}
+
+void
+test (void)
+{
+  g ();
+}
+
+void
+test1 (void)
+{
+  f ();
+}
+
+void
+test2 (void)
+{
+  l ();
+}
diff --git a/gcc/testsuite/gcc.target/loongarch/func-call-8.c b/gcc/testsuite/gcc.target/loongarch/func-call-8.c
new file mode 100644
index 00000000000..330140d883d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/func-call-8.c
@@ -0,0 +1,33 @@
+/* { dg-do compile } */
+/* { dg-options "-mabi=lp64d -O0 -fno-pic -fno-plt -mexplicit-relocs" } */
+/* { dg-final { scan-assembler "test:.*pcalau12i\t.*%got_pc_hi20\\(g\\)\n\tld\.d\t.*%got_pc_lo12\\(g\\)\n\tjirl" } } */
+/* { dg-final { scan-assembler "test1:.*bl\tf\n" } } */
+/* { dg-final { scan-assembler "test2:.*bl\tl\n" } } */
+
+extern void g (void);
+
+void
+f (void)
+{}
+
+static void
+l (void)
+{}
+
+void
+test (void)
+{
+  g ();
+}
+
+void
+test1 (void)
+{
+  f ();
+}
+
+void
+test2 (void)
+{
+  l ();
+}
diff --git a/gcc/testsuite/gcc.target/loongarch/relocs-symbol-noaddend.c b/gcc/testsuite/gcc.target/loongarch/relocs-symbol-noaddend.c
new file mode 100644
index 00000000000..bfcc9bc338f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/relocs-symbol-noaddend.c
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-options "-mabi=lp64d -mexplicit-relocs -fno-pic -O2" } */
+/* { dg-final { scan-assembler "pcalau12i.*%pc_hi20\\(\.LANCHOR0\\)\n" } } */
+/* { dg-final { scan-assembler "addi\.d.*%pc_lo12\\(\.LANCHOR0\\)\n" } } */
+/* { dg-final { scan-assembler "ldptr.d\t\\\$r4,.*,0\n" } } */
+/* { dg-final { scan-assembler "ld.d\t\\\$r5,.*,8\n" } } */
+/* { dg-final { scan-assembler-not  "\.LANCHOR0+8" } } */
+
+
+struct S
+{
+  char *a;
+  unsigned short int b;
+};
+
+struct S s1;
+
+void test(struct S);
+void test1(void)
+{
+  test(s1);
+}
+
-- 
2.38.1

From f0861d3cf0b3f189cbb7d31b78934bf554960f83 Mon Sep 17 00:00:00 2001
From: Lulu Cheng <chenglulu@loongson.cn>
Date: Tue, 26 Jul 2022 21:03:52 +0800
Subject: [PATCH 05/36] LoongArch: Modify the output message string of the
 warning.

Fix bug for "error: spurious trailing punctuation sequence '.' in format [-Werror=format-diag]".

gcc/ChangeLog:

	* config/loongarch/loongarch-opts.cc: Modify the output message string
	of the warning.
---
 gcc/config/loongarch/loongarch-opts.cc | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/gcc/config/loongarch/loongarch-opts.cc b/gcc/config/loongarch/loongarch-opts.cc
index fc477bfd4bb..3f70943ded6 100644
--- a/gcc/config/loongarch/loongarch-opts.cc
+++ b/gcc/config/loongarch/loongarch-opts.cc
@@ -378,8 +378,8 @@ fallback:
   t.cmodel = constrained.cmodel ? opt_cmodel : CMODEL_NORMAL;
   if (t.cmodel != CMODEL_NORMAL)
     {
-      warning (0, "%qs is not supported, now cmodel is set to 'normal'.",
-	       loongarch_cmodel_strings[t.cmodel]);
+      warning (0, "%qs is not supported, now cmodel is set to %qs",
+	       loongarch_cmodel_strings[t.cmodel], "normal");
       t.cmodel = CMODEL_NORMAL;
     }
 
-- 
2.38.1

From 398cc12c0c4c19d52f74410b7a75673a87bea6af Mon Sep 17 00:00:00 2001
From: Xi Ruoyao <xry111@xry111.site>
Date: Tue, 26 Jul 2022 21:46:20 +0800
Subject: [PATCH 06/36] LoongArch: adjust the default of -mexplicit-relocs by
 checking gas feature

The assembly produced with -mexplicit-relocs is not supported by gas <=
2.39.  Check if the assembler supports explicit relocations and set the
default accordingly.

gcc/ChangeLog:

	* configure.ac (HAVE_AS_EXPLICIT_RELOCS): Define to 1 if the
	assembler supports explicit relocation for LoongArch.
	* configure: Regenerate.
	* config/loongarch/loongarch-opts.h (HAVE_AS_EXPLICIT_RELOCS):
	Define to 0 if not defined.
	* config/loongarch/genopts/loongarch.opt.in
	(TARGET_EXPLICIT_RELOCS): Default to HAVE_AS_EXPLICIT_RELOCS.
	* config/loongarch/loongarch.opt: Regenerate.
---
 gcc/config/loongarch/genopts/loongarch.opt.in |  2 +-
 gcc/config/loongarch/loongarch-opts.h         |  4 +++
 gcc/config/loongarch/loongarch.opt            |  2 +-
 gcc/configure                                 | 33 ++++++++++++++++++-
 gcc/configure.ac                              |  7 +++-
 5 files changed, 44 insertions(+), 4 deletions(-)

diff --git a/gcc/config/loongarch/genopts/loongarch.opt.in b/gcc/config/loongarch/genopts/loongarch.opt.in
index 6f39500935d..a571b6b7524 100644
--- a/gcc/config/loongarch/genopts/loongarch.opt.in
+++ b/gcc/config/loongarch/genopts/loongarch.opt.in
@@ -155,7 +155,7 @@ Target Joined RejectNegative UInteger Var(loongarch_max_inline_memcpy_size) Init
 -mmax-inline-memcpy-size=SIZE	Set the max size of memcpy to inline, default is 1024.
 
 mexplicit-relocs
-Target Var(TARGET_EXPLICIT_RELOCS) Init(1)
+Target Var(TARGET_EXPLICIT_RELOCS) Init(HAVE_AS_EXPLICIT_RELOCS)
 Use %reloc() assembly operators.
 
 ; The code model option names for -mcmodel.
diff --git a/gcc/config/loongarch/loongarch-opts.h b/gcc/config/loongarch/loongarch-opts.h
index eaa6fc07448..da24ecd2b50 100644
--- a/gcc/config/loongarch/loongarch-opts.h
+++ b/gcc/config/loongarch/loongarch-opts.h
@@ -87,4 +87,8 @@ loongarch_config_target (struct loongarch_target *target,
    while -m[no]-memcpy imposes a global constraint.  */
 #define TARGET_DO_OPTIMIZE_BLOCK_MOVE_P  loongarch_do_optimize_block_move_p()
 
+#ifndef HAVE_AS_EXPLICIT_RELOCS
+#define HAVE_AS_EXPLICIT_RELOCS 0
+#endif
+
 #endif /* LOONGARCH_OPTS_H */
diff --git a/gcc/config/loongarch/loongarch.opt b/gcc/config/loongarch/loongarch.opt
index 7a8c5b44418..9df7e187283 100644
--- a/gcc/config/loongarch/loongarch.opt
+++ b/gcc/config/loongarch/loongarch.opt
@@ -162,7 +162,7 @@ Target Joined RejectNegative UInteger Var(loongarch_max_inline_memcpy_size) Init
 -mmax-inline-memcpy-size=SIZE	Set the max size of memcpy to inline, default is 1024.
 
 mexplicit-relocs
-Target Var(TARGET_EXPLICIT_RELOCS) Init(1)
+Target Var(TARGET_EXPLICIT_RELOCS) Init(HAVE_AS_EXPLICIT_RELOCS)
 Use %reloc() assembly operators.
 
 ; The code model option names for -mcmodel.
diff --git a/gcc/configure b/gcc/configure
index 5ce0557719a..160785e3b3a 100755
--- a/gcc/configure
+++ b/gcc/configure
@@ -28797,7 +28797,7 @@ $as_echo "#define HAVE_AS_MARCH_ZIFENCEI 1" >>confdefs.h
 fi
 
     ;;
-  loongarch*-*-*)
+    loongarch*-*-*)
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking assembler for .dtprelword support" >&5
 $as_echo_n "checking assembler for .dtprelword support... " >&6; }
 if ${gcc_cv_as_loongarch_dtprelword+:} false; then :
@@ -28833,6 +28833,37 @@ if test $gcc_cv_as_loongarch_dtprelword != yes; then
 $as_echo "#define HAVE_AS_DTPRELWORD 1" >>confdefs.h
 
 fi
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking assembler for explicit relocation support" >&5
+$as_echo_n "checking assembler for explicit relocation support... " >&6; }
+if ${gcc_cv_as_loongarch_explicit_relocs+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  gcc_cv_as_loongarch_explicit_relocs=no
+  if test x$gcc_cv_as != x; then
+    $as_echo 'a:pcalau12i $t0,%pc_hi20(a)' > conftest.s
+    if { ac_try='$gcc_cv_as $gcc_cv_as_flags  -o conftest.o conftest.s >&5'
+  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; }
+    then
+	gcc_cv_as_loongarch_explicit_relocs=yes
+    else
+      echo "configure: failed program was" >&5
+      cat conftest.s >&5
+    fi
+    rm -f conftest.o conftest.s
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $gcc_cv_as_loongarch_explicit_relocs" >&5
+$as_echo "$gcc_cv_as_loongarch_explicit_relocs" >&6; }
+if test $gcc_cv_as_loongarch_explicit_relocs = yes; then
+
+$as_echo "#define HAVE_AS_EXPLICIT_RELOCS 1" >>confdefs.h
+
+fi
+
     ;;
     s390*-*-*)
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking assembler for .gnu_attribute support" >&5
diff --git a/gcc/configure.ac b/gcc/configure.ac
index 23bee7010a3..2ae67f58b5e 100644
--- a/gcc/configure.ac
+++ b/gcc/configure.ac
@@ -5314,7 +5314,7 @@ configured with --enable-newlib-nano-formatted-io.])
       [AC_DEFINE(HAVE_AS_MARCH_ZIFENCEI, 1,
 		 [Define if the assembler understands -march=rv*_zifencei.])])
     ;;
-  loongarch*-*-*)
+    loongarch*-*-*)
     gcc_GAS_CHECK_FEATURE([.dtprelword support],
       gcc_cv_as_loongarch_dtprelword, [2,18,0],,
       [.section .tdata,"awT",@progbits
@@ -5324,6 +5324,11 @@ x:
 	.dtprelword x+0x8000],,
       [AC_DEFINE(HAVE_AS_DTPRELWORD, 1,
 	  [Define if your assembler supports .dtprelword.])])
+    gcc_GAS_CHECK_FEATURE([explicit relocation support],
+      gcc_cv_as_loongarch_explicit_relocs,,
+      [a:pcalau12i $t0,%pc_hi20(a)],,
+      [AC_DEFINE(HAVE_AS_EXPLICIT_RELOCS, 1,
+	  [Define if your assembler supports explicit relocation.])])
     ;;
     s390*-*-*)
     gcc_GAS_CHECK_FEATURE([.gnu_attribute support],
-- 
2.38.1

From eeb9c70a2cc12fe9e356d94d81c247591a440fd5 Mon Sep 17 00:00:00 2001
From: WANG Xuerui <i@xen0n.name>
Date: Wed, 27 Jul 2022 15:01:17 +0800
Subject: [PATCH 07/36] LoongArch: document -m[no-]explicit-relocs

gcc/ChangeLog:

	* doc/invoke.texi: Document -m[no-]explicit-relocs for
	LoongArch.
---
 gcc/doc/invoke.texi | 13 +++++++++++++
 1 file changed, 13 insertions(+)

diff --git a/gcc/doc/invoke.texi b/gcc/doc/invoke.texi
index ff6c338bedb..71408d80ad8 100644
--- a/gcc/doc/invoke.texi
+++ b/gcc/doc/invoke.texi
@@ -24618,6 +24618,19 @@ global symbol: The data got table must be within +/-8EiB addressing space.
 @end itemize
 @end table
 The default code model is @code{normal}.
+
+@item -mexplicit-relocs
+@itemx -mno-explicit-relocs
+@opindex mexplicit-relocs
+@opindex mno-explicit-relocs
+Use or do not use assembler relocation operators when dealing with symbolic
+addresses.  The alternative is to use assembler macros instead, which may
+limit optimization.  The default value for the option is determined during
+GCC build-time by detecting corresponding assembler support:
+@code{-mexplicit-relocs} if said support is present,
+@code{-mno-explicit-relocs} otherwise.  This option is mostly useful for
+debugging, or interoperation with assemblers different from the build-time
+one.
 @end table
 
 @node M32C Options
-- 
2.38.1

From e5b7a0a987d68f2c9b3bc1d874d95244420127ac Mon Sep 17 00:00:00 2001
From: Lulu Cheng <chenglulu@loongson.cn>
Date: Fri, 29 Jul 2022 09:44:52 +0800
Subject: [PATCH 08/36] LoongArch: Define the macro
 ASM_PREFERRED_EH_DATA_FORMAT by checking the assembler's support for eh_frame
 encoding.

.eh_frame DW_EH_PE_pcrel encoding format is not supported by gas <= 2.39.
Check if the assembler support DW_EH_PE_PCREL encoding and define .eh_frame
encoding type.

gcc/ChangeLog:

	* config.in: Regenerate.
	* config/loongarch/loongarch.h (ASM_PREFERRED_EH_DATA_FORMAT):
	Select the value of the macro definition according to whether
	HAVE_AS_EH_FRAME_PCREL_ENCODING_SUPPORT is defined.
	* configure: Regenerate.
	* configure.ac: Reinstate HAVE_AS_EH_FRAME_PCREL_ENCODING_SUPPORT test.
---
 gcc/config.in                    |  8 +++++++-
 gcc/config/loongarch/loongarch.h |  5 +++++
 gcc/configure                    | 34 ++++++++++++++++++++++++++++++++
 gcc/configure.ac                 |  8 ++++++++
 4 files changed, 54 insertions(+), 1 deletion(-)

diff --git a/gcc/config.in b/gcc/config.in
index 64c27c9cfac..67ce422f2a0 100644
--- a/gcc/config.in
+++ b/gcc/config.in
@@ -404,13 +404,19 @@
 #endif
 
 
+/* Define if your assembler supports eh_frame pcrel encoding. */
+#ifndef USED_FOR_TARGET
+#undef HAVE_AS_EH_FRAME_PCREL_ENCODING_SUPPORT
+#endif
+
+
 /* Define if your assembler supports the R_PPC64_ENTRY relocation. */
 #ifndef USED_FOR_TARGET
 #undef HAVE_AS_ENTRY_MARKERS
 #endif
 
 
-/* Define if your assembler supports explicit relocations. */
+/* Define if your assembler supports explicit relocation. */
 #ifndef USED_FOR_TARGET
 #undef HAVE_AS_EXPLICIT_RELOCS
 #endif
diff --git a/gcc/config/loongarch/loongarch.h b/gcc/config/loongarch/loongarch.h
index 89a5bd728fe..8b1288961e4 100644
--- a/gcc/config/loongarch/loongarch.h
+++ b/gcc/config/loongarch/loongarch.h
@@ -1127,8 +1127,13 @@ struct GTY (()) machine_function
 };
 #endif
 
+#ifdef HAVE_AS_EH_FRAME_PCREL_ENCODING_SUPPORT
+#define ASM_PREFERRED_EH_DATA_FORMAT(CODE, GLOBAL) \
+  (((GLOBAL) ? DW_EH_PE_indirect : 0) | DW_EH_PE_pcrel | DW_EH_PE_sdata4)
+#else
 #define ASM_PREFERRED_EH_DATA_FORMAT(CODE, GLOBAL) \
   (((GLOBAL) ? DW_EH_PE_indirect : 0) | DW_EH_PE_absptr)
+#endif
 
 /* Do emit .note.GNU-stack by default.  */
 #ifndef NEED_INDICATE_EXEC_STACK
diff --git a/gcc/configure b/gcc/configure
index 160785e3b3a..b53cc16c71f 100755
--- a/gcc/configure
+++ b/gcc/configure
@@ -28862,6 +28862,40 @@ if test $gcc_cv_as_loongarch_explicit_relocs = yes; then
 
 $as_echo "#define HAVE_AS_EXPLICIT_RELOCS 1" >>confdefs.h
 
+fi
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking assembler for eh_frame pcrel encoding support" >&5
+$as_echo_n "checking assembler for eh_frame pcrel encoding support... " >&6; }
+if ${gcc_cv_as_loongarch_eh_frame_pcrel_encoding_support+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  gcc_cv_as_loongarch_eh_frame_pcrel_encoding_support=no
+  if test x$gcc_cv_as != x; then
+    $as_echo '.cfi_startproc
+       .cfi_personality 0x9b,a
+       .cfi_lsda 0x1b,b
+       .cfi_endproc' > conftest.s
+    if { ac_try='$gcc_cv_as $gcc_cv_as_flags  -o conftest.o conftest.s >&5'
+  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; }
+    then
+	gcc_cv_as_loongarch_eh_frame_pcrel_encoding_support=yes
+    else
+      echo "configure: failed program was" >&5
+      cat conftest.s >&5
+    fi
+    rm -f conftest.o conftest.s
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $gcc_cv_as_loongarch_eh_frame_pcrel_encoding_support" >&5
+$as_echo "$gcc_cv_as_loongarch_eh_frame_pcrel_encoding_support" >&6; }
+if test $gcc_cv_as_loongarch_eh_frame_pcrel_encoding_support = yes; then
+
+$as_echo "#define HAVE_AS_EH_FRAME_PCREL_ENCODING_SUPPORT 1" >>confdefs.h
+
 fi
 
     ;;
diff --git a/gcc/configure.ac b/gcc/configure.ac
index 2ae67f58b5e..8b8e6efffe8 100644
--- a/gcc/configure.ac
+++ b/gcc/configure.ac
@@ -5329,6 +5329,14 @@ x:
       [a:pcalau12i $t0,%pc_hi20(a)],,
       [AC_DEFINE(HAVE_AS_EXPLICIT_RELOCS, 1,
 	  [Define if your assembler supports explicit relocation.])])
+    gcc_GAS_CHECK_FEATURE([eh_frame pcrel encoding support],
+      gcc_cv_as_loongarch_eh_frame_pcrel_encoding_support,,
+      [.cfi_startproc
+       .cfi_personality 0x9b,a
+       .cfi_lsda 0x1b,b
+       .cfi_endproc],,
+      [AC_DEFINE(HAVE_AS_EH_FRAME_PCREL_ENCODING_SUPPORT, 1,
+	  [Define if your assembler supports eh_frame pcrel encoding.])])
     ;;
     s390*-*-*)
     gcc_GAS_CHECK_FEATURE([.gnu_attribute support],
-- 
2.38.1

From 4d5142c8531b87bb0374c5a49bfe4496ca95e40a Mon Sep 17 00:00:00 2001
From: Xi Ruoyao <xry111@xry111.site>
Date: Tue, 16 Aug 2022 15:34:36 +0800
Subject: [PATCH 09/36] LoongArch: Provide fmin/fmax RTL pattern

We already had smin/smax RTL pattern using fmin/fmax instruction.  But
for smin/smax, it's unspecified what will happen if either operand is
NaN.  So we would generate calls to libc fmin/fmax functions with
-fno-finite-math-only (the default for all optimization levels expect
-Ofast).

But, LoongArch fmin/fmax instruction is IEEE-754-2008 conformant so we
can also use the instruction for fmin/fmax pattern and avoid the library
function call.

gcc/ChangeLog:

	* config/loongarch/loongarch.md (fmax<mode>3): New RTL pattern.
	(fmin<mode>3): Likewise.

gcc/testsuite/ChangeLog:

	* gcc.target/loongarch/fmax-fmin.c: New test.
---
 gcc/config/loongarch/loongarch.md             | 18 +++++++++++
 .../gcc.target/loongarch/fmax-fmin.c          | 30 +++++++++++++++++++
 2 files changed, 48 insertions(+)
 create mode 100644 gcc/testsuite/gcc.target/loongarch/fmax-fmin.c

diff --git a/gcc/config/loongarch/loongarch.md b/gcc/config/loongarch/loongarch.md
index 6b6df22a5f1..8e8868de9f5 100644
--- a/gcc/config/loongarch/loongarch.md
+++ b/gcc/config/loongarch/loongarch.md
@@ -1023,6 +1023,24 @@
   [(set_attr "type" "fmove")
    (set_attr "mode" "<MODE>")])
 
+(define_insn "fmax<mode>3"
+  [(set (match_operand:ANYF 0 "register_operand" "=f")
+	(smax:ANYF (match_operand:ANYF 1 "register_operand" "f")
+		   (match_operand:ANYF 2 "register_operand" "f")))]
+  ""
+  "fmax.<fmt>\t%0,%1,%2"
+  [(set_attr "type" "fmove")
+   (set_attr "mode" "<MODE>")])
+
+(define_insn "fmin<mode>3"
+  [(set (match_operand:ANYF 0 "register_operand" "=f")
+	(smin:ANYF (match_operand:ANYF 1 "register_operand" "f")
+		   (match_operand:ANYF 2 "register_operand" "f")))]
+  ""
+  "fmin.<fmt>\t%0,%1,%2"
+  [(set_attr "type" "fmove")
+   (set_attr "mode" "<MODE>")])
+
 (define_insn "smaxa<mode>3"
   [(set (match_operand:ANYF 0 "register_operand" "=f")
 	(if_then_else:ANYF
diff --git a/gcc/testsuite/gcc.target/loongarch/fmax-fmin.c b/gcc/testsuite/gcc.target/loongarch/fmax-fmin.c
new file mode 100644
index 00000000000..92cf8a1501d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/fmax-fmin.c
@@ -0,0 +1,30 @@
+/* { dg-do compile } */
+/* { dg-options "-mdouble-float -fno-finite-math-only" } */
+/* { dg-final { scan-assembler "fmin\\.s" } } */
+/* { dg-final { scan-assembler "fmin\\.d" } } */
+/* { dg-final { scan-assembler "fmax\\.s" } } */
+/* { dg-final { scan-assembler "fmax\\.d" } } */
+
+double
+_fmax(double a, double b)
+{
+  return __builtin_fmax(a, b);
+}
+
+float
+_fmaxf(float a, float b)
+{
+  return __builtin_fmaxf(a, b);
+}
+
+double
+_fmin(double a, double b)
+{
+  return __builtin_fmin(a, b);
+}
+
+float
+_fminf(float a, float b)
+{
+  return __builtin_fminf(a, b);
+}
-- 
2.38.1

From 9e374bef25b3b3942ef4e2a7fb4cd49c5b36e989 Mon Sep 17 00:00:00 2001
From: Lulu Cheng <chenglulu@loongson.cn>
Date: Thu, 18 Aug 2022 09:57:14 +0800
Subject: [PATCH 10/36] LoongArch: Get __tls_get_addr address through got table
 when disable plt.

Fix bug, ICE with tls gd/ld var with -fno-plt.

gcc/ChangeLog:

	* config/loongarch/loongarch.cc (loongarch_call_tls_get_addr):
	Get __tls_get_addr address through got table when disable plt.

gcc/testsuite/ChangeLog:

	* gcc.target/loongarch/tls-gd-noplt.c: New test.
---
 gcc/config/loongarch/loongarch.cc                 | 14 ++++++++++++--
 gcc/testsuite/gcc.target/loongarch/tls-gd-noplt.c | 12 ++++++++++++
 2 files changed, 24 insertions(+), 2 deletions(-)
 create mode 100644 gcc/testsuite/gcc.target/loongarch/tls-gd-noplt.c

diff --git a/gcc/config/loongarch/loongarch.cc b/gcc/config/loongarch/loongarch.cc
index 79687340dfd..24378143641 100644
--- a/gcc/config/loongarch/loongarch.cc
+++ b/gcc/config/loongarch/loongarch.cc
@@ -2448,8 +2448,18 @@ loongarch_call_tls_get_addr (rtx sym, enum loongarch_symbol_type type, rtx v0)
 	gcc_unreachable ();
     }
 
-  insn = emit_call_insn (gen_call_value_internal (v0, loongarch_tls_symbol,
-						  const0_rtx));
+  if (flag_plt)
+    insn = emit_call_insn (gen_call_value_internal (v0, loongarch_tls_symbol,
+						    const0_rtx));
+  else
+    {
+      rtx dest = gen_reg_rtx (Pmode);
+      rtx high = gen_reg_rtx (Pmode);
+      loongarch_emit_move (high, gen_rtx_HIGH (Pmode, loongarch_tls_symbol));
+      emit_insn (gen_ld_from_got (Pmode, dest, high, loongarch_tls_symbol));
+      insn = emit_call_insn (gen_call_value_internal (v0, dest, const0_rtx));
+    }
+
   RTL_CONST_CALL_P (insn) = 1;
   use_reg (&CALL_INSN_FUNCTION_USAGE (insn), a0);
   insn = get_insns ();
diff --git a/gcc/testsuite/gcc.target/loongarch/tls-gd-noplt.c b/gcc/testsuite/gcc.target/loongarch/tls-gd-noplt.c
new file mode 100644
index 00000000000..32a0acf9b18
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/tls-gd-noplt.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fno-plt -mcmodel=normal" } */
+/* { dg-final { scan-assembler "pcalau12i\t.*%got_pc_hi20\\(__tls_get_addr\\)" } } */
+
+__attribute__ ((tls_model ("global-dynamic"))) __thread int a;
+
+void
+test (void)
+{
+  a = 10;
+}
+
-- 
2.38.1

From 84b3dda359cae6c035f53831e5df1c08b2f56bd5 Mon Sep 17 00:00:00 2001
From: Lulu Cheng <chenglulu@loongson.cn>
Date: Thu, 18 Aug 2022 17:26:13 +0800
Subject: [PATCH 11/36] LoongArch: Add support code model extreme.

Use five instructions to calculate a signed 64-bit offset relative to the pc.

gcc/ChangeLog:

	* config/loongarch/loongarch-opts.cc: Allow cmodel to be extreme.
	* config/loongarch/loongarch.cc (loongarch_call_tls_get_addr):
	Add extreme support for TLS GD and LD types.
	(loongarch_legitimize_tls_address): Add extreme support for TLS LE
	and IE.
	(loongarch_split_symbol): When compiling with -mcmodel=extreme,
	the symbol address will be obtained through five instructions.
	(loongarch_print_operand_reloc): Add support.
	(loongarch_print_operand): Add support.
	(loongarch_print_operand_address): Add support.
	(loongarch_option_override_internal): Set '-mcmodel=extreme' option
	incompatible with '-mno-explicit-relocs'.
	* config/loongarch/loongarch.md (@lui_l_hi20<mode>):
	Loads bits 12-31 of data into registers.
	(lui_h_lo20): Load bits 32-51 of the data and spell bits 0-31 of
	the source register.
	(lui_h_hi12): Load bits 52-63 of the data and spell bits 0-51 of
	the source register.
	* config/loongarch/predicates.md: Symbols need to be decomposed
	when defining the macro TARGET_CMODEL_EXTREME
	* doc/invoke.texi: Modify the description information of cmodel in the document.
	Document -W[no-]extreme-plt.

gcc/testsuite/ChangeLog:

	* gcc.target/loongarch/func-call-1.c: Add option '-mcmodel=normal'.
	* gcc.target/loongarch/func-call-2.c: Likewise.
	* gcc.target/loongarch/func-call-3.c: Likewise.
	* gcc.target/loongarch/func-call-4.c: Likewise.
	* gcc.target/loongarch/func-call-5.c: Likewise.
	* gcc.target/loongarch/func-call-6.c: Likewise.
	* gcc.target/loongarch/func-call-7.c: Likewise.
	* gcc.target/loongarch/func-call-8.c: Likewise.
	* gcc.target/loongarch/relocs-symbol-noaddend.c: Likewise.
	* gcc.target/loongarch/func-call-extreme-1.c: New test.
	* gcc.target/loongarch/func-call-extreme-2.c: New test.
---
 gcc/config/loongarch/loongarch-opts.cc        |   3 +-
 gcc/config/loongarch/loongarch.cc             | 222 +++++++++++++++---
 gcc/config/loongarch/loongarch.md             |  34 ++-
 gcc/config/loongarch/predicates.md            |   9 +-
 gcc/doc/invoke.texi                           |  50 +---
 .../gcc.target/loongarch/func-call-1.c        |   2 +-
 .../gcc.target/loongarch/func-call-2.c        |   2 +-
 .../gcc.target/loongarch/func-call-3.c        |   2 +-
 .../gcc.target/loongarch/func-call-4.c        |   2 +-
 .../gcc.target/loongarch/func-call-5.c        |   2 +-
 .../gcc.target/loongarch/func-call-6.c        |   2 +-
 .../gcc.target/loongarch/func-call-7.c        |   2 +-
 .../gcc.target/loongarch/func-call-8.c        |   2 +-
 .../loongarch/func-call-extreme-1.c           |  32 +++
 .../loongarch/func-call-extreme-2.c           |  32 +++
 .../loongarch/relocs-symbol-noaddend.c        |   2 +-
 16 files changed, 318 insertions(+), 82 deletions(-)
 create mode 100644 gcc/testsuite/gcc.target/loongarch/func-call-extreme-1.c
 create mode 100644 gcc/testsuite/gcc.target/loongarch/func-call-extreme-2.c

diff --git a/gcc/config/loongarch/loongarch-opts.cc b/gcc/config/loongarch/loongarch-opts.cc
index 3f70943ded6..2ae89f23443 100644
--- a/gcc/config/loongarch/loongarch-opts.cc
+++ b/gcc/config/loongarch/loongarch-opts.cc
@@ -376,14 +376,13 @@ fallback:
 
   /* 5.  Target code model */
   t.cmodel = constrained.cmodel ? opt_cmodel : CMODEL_NORMAL;
-  if (t.cmodel != CMODEL_NORMAL)
+  if (t.cmodel != CMODEL_NORMAL && t.cmodel != CMODEL_EXTREME)
     {
       warning (0, "%qs is not supported, now cmodel is set to %qs",
 	       loongarch_cmodel_strings[t.cmodel], "normal");
       t.cmodel = CMODEL_NORMAL;
     }
 
-
   /* Cleanup and return.  */
   obstack_free (&msg_obstack, NULL);
   *target = t;
diff --git a/gcc/config/loongarch/loongarch.cc b/gcc/config/loongarch/loongarch.cc
index 24378143641..207ac2762c6 100644
--- a/gcc/config/loongarch/loongarch.cc
+++ b/gcc/config/loongarch/loongarch.cc
@@ -2436,7 +2436,19 @@ loongarch_call_tls_get_addr (rtx sym, enum loongarch_symbol_type type, rtx v0)
       /* Split tls symbol to high and low.  */
       rtx high = gen_rtx_HIGH (Pmode, copy_rtx (loc));
       high = loongarch_force_temporary (tmp, high);
-      emit_insn (gen_tls_low (Pmode, a0, high, loc));
+
+      if (TARGET_CMODEL_EXTREME)
+	{
+	  gcc_assert (TARGET_EXPLICIT_RELOCS);
+
+	  rtx tmp1 = gen_reg_rtx (Pmode);
+	  emit_insn (gen_tls_low (Pmode, tmp1, gen_rtx_REG (Pmode, 0), loc));
+	  emit_insn (gen_lui_h_lo20 (tmp1, tmp1, loc));
+	  emit_insn (gen_lui_h_hi12 (tmp1, tmp1, loc));
+	  emit_move_insn (a0, gen_rtx_PLUS (Pmode, high, tmp1));
+	}
+      else
+	emit_insn (gen_tls_low (Pmode, a0, high, loc));
     }
   else
     {
@@ -2449,14 +2461,44 @@ loongarch_call_tls_get_addr (rtx sym, enum loongarch_symbol_type type, rtx v0)
     }
 
   if (flag_plt)
-    insn = emit_call_insn (gen_call_value_internal (v0, loongarch_tls_symbol,
+    insn = emit_call_insn (gen_call_value_internal (v0,
+						    loongarch_tls_symbol,
 						    const0_rtx));
   else
     {
       rtx dest = gen_reg_rtx (Pmode);
-      rtx high = gen_reg_rtx (Pmode);
-      loongarch_emit_move (high, gen_rtx_HIGH (Pmode, loongarch_tls_symbol));
-      emit_insn (gen_ld_from_got (Pmode, dest, high, loongarch_tls_symbol));
+
+      if (TARGET_CMODEL_EXTREME)
+	{
+	  gcc_assert (TARGET_EXPLICIT_RELOCS);
+
+	  rtx tmp1 = gen_reg_rtx (Pmode);
+	  rtx high = gen_reg_rtx (Pmode);
+
+	  loongarch_emit_move (high,
+			       gen_rtx_HIGH (Pmode, loongarch_tls_symbol));
+	  loongarch_emit_move (tmp1, gen_rtx_LO_SUM (Pmode,
+						     gen_rtx_REG (Pmode, 0),
+						     loongarch_tls_symbol));
+	  emit_insn (gen_lui_h_lo20 (tmp1, tmp1, loongarch_tls_symbol));
+	  emit_insn (gen_lui_h_hi12 (tmp1, tmp1, loongarch_tls_symbol));
+	  loongarch_emit_move (dest,
+			       gen_rtx_MEM (Pmode,
+					    gen_rtx_PLUS (Pmode, high, tmp1)));
+	}
+      else
+	{
+	  if (TARGET_EXPLICIT_RELOCS)
+	    {
+	      rtx high = gen_reg_rtx (Pmode);
+	      loongarch_emit_move (high,
+				   gen_rtx_HIGH (Pmode, loongarch_tls_symbol));
+	      emit_insn (gen_ld_from_got (Pmode, dest, high,
+					  loongarch_tls_symbol));
+	    }
+	  else
+	    loongarch_emit_move (dest, loongarch_tls_symbol);
+	}
       insn = emit_call_insn (gen_call_value_internal (v0, dest, const0_rtx));
     }
 
@@ -2508,7 +2550,23 @@ loongarch_legitimize_tls_address (rtx loc)
 	      tmp3 = gen_reg_rtx (Pmode);
 	      rtx high = gen_rtx_HIGH (Pmode, copy_rtx (tmp2));
 	      high = loongarch_force_temporary (tmp3, high);
-	      emit_insn (gen_ld_from_got (Pmode, tmp1, high, tmp2));
+
+	      if (TARGET_CMODEL_EXTREME)
+		{
+		  gcc_assert (TARGET_EXPLICIT_RELOCS);
+
+		  rtx tmp3 = gen_reg_rtx (Pmode);
+		  emit_insn (gen_tls_low (Pmode, tmp3,
+					  gen_rtx_REG (Pmode, 0), tmp2));
+		  emit_insn (gen_lui_h_lo20 (tmp3, tmp3, tmp2));
+		  emit_insn (gen_lui_h_hi12 (tmp3, tmp3, tmp2));
+		  emit_move_insn (tmp1,
+				  gen_rtx_MEM (Pmode,
+					       gen_rtx_PLUS (Pmode,
+							     high, tmp3)));
+		}
+	      else
+		emit_insn (gen_ld_from_got (Pmode, tmp1, high, tmp2));
 	    }
 	  else
 	    emit_insn (loongarch_got_load_tls_ie (tmp1, loc));
@@ -2530,11 +2588,18 @@ loongarch_legitimize_tls_address (rtx loc)
 	      rtx high = gen_rtx_HIGH (Pmode, copy_rtx (tmp2));
 	      high = loongarch_force_temporary (tmp3, high);
 	      emit_insn (gen_ori_l_lo12 (Pmode, tmp1, high, tmp2));
+
+	      if (TARGET_CMODEL_EXTREME)
+		{
+		  gcc_assert (TARGET_EXPLICIT_RELOCS);
+
+		  emit_insn (gen_lui_h_lo20 (tmp1, tmp1, tmp2));
+		  emit_insn (gen_lui_h_hi12 (tmp1, tmp1, tmp2));
+		}
 	    }
 	  else
 	    emit_insn (loongarch_got_load_tls_le (tmp1, loc));
 	  emit_insn (gen_add3_insn (dest, tmp1, tp));
-
 	}
       break;
 
@@ -2603,7 +2668,6 @@ bool
 loongarch_split_symbol (rtx temp, rtx addr, machine_mode mode, rtx *low_out)
 {
   enum loongarch_symbol_type symbol_type;
-  rtx high;
 
   /* If build with '-mno-explicit-relocs', don't split symbol.  */
   if (!TARGET_EXPLICIT_RELOCS)
@@ -2615,6 +2679,8 @@ loongarch_split_symbol (rtx temp, rtx addr, machine_mode mode, rtx *low_out)
       || !loongarch_split_symbol_type (symbol_type))
     return false;
 
+  rtx high, temp1 = NULL;
+
   if (temp == NULL)
     temp = gen_reg_rtx (Pmode);
 
@@ -2622,20 +2688,42 @@ loongarch_split_symbol (rtx temp, rtx addr, machine_mode mode, rtx *low_out)
   high = gen_rtx_HIGH (Pmode, copy_rtx (addr));
   high = loongarch_force_temporary (temp, high);
 
+  if (TARGET_CMODEL_EXTREME && can_create_pseudo_p ())
+    {
+      gcc_assert (TARGET_EXPLICIT_RELOCS);
+
+      temp1 = gen_reg_rtx (Pmode);
+      emit_move_insn (temp1, gen_rtx_LO_SUM (Pmode, gen_rtx_REG (Pmode, 0),
+					     addr));
+      emit_insn (gen_lui_h_lo20 (temp1, temp1, addr));
+      emit_insn (gen_lui_h_hi12 (temp1, temp1, addr));
+    }
+
   if (low_out)
     switch (symbol_type)
       {
       case SYMBOL_PCREL:
-	*low_out = gen_rtx_LO_SUM (Pmode, high, addr);
-	break;
+	{
+	  if (TARGET_CMODEL_EXTREME && can_create_pseudo_p ())
+	    *low_out = gen_rtx_PLUS (Pmode, high, temp1);
+	  else
+	    *low_out = gen_rtx_LO_SUM (Pmode, high, addr);
+	  break;
+	}
 
       case SYMBOL_GOT_DISP:
 	/* SYMBOL_GOT_DISP symbols are loaded from the GOT.  */
 	{
-	  rtx low = gen_rtx_LO_SUM (Pmode, high, addr);
-	  rtx mem = gen_rtx_MEM (Pmode, low);
-	  *low_out = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, mem),
-				     UNSPEC_LOAD_FROM_GOT);
+	  if (TARGET_CMODEL_EXTREME && can_create_pseudo_p ())
+	    *low_out = gen_rtx_MEM (Pmode, gen_rtx_PLUS (Pmode, high, temp1));
+	  else
+	    {
+	      rtx low = gen_rtx_LO_SUM (Pmode, high, addr);
+	      rtx mem = gen_rtx_MEM (Pmode, low);
+	      *low_out = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, mem),
+					 UNSPEC_LOAD_FROM_GOT);
+	    }
+
 	  break;
 	}
 
@@ -4584,34 +4672,86 @@ loongarch_memmodel_needs_release_fence (enum memmodel model)
    in context CONTEXT.  HI_RELOC indicates a high-part reloc.  */
 
 static void
-loongarch_print_operand_reloc (FILE *file, rtx op, bool hi_reloc)
+loongarch_print_operand_reloc (FILE *file, rtx op, bool hi64_part,
+			       bool hi_reloc)
 {
   const char *reloc;
 
+  if (TARGET_CMODEL_EXTREME)
+    gcc_assert (TARGET_EXPLICIT_RELOCS);
+
   switch (loongarch_classify_symbolic_expression (op))
     {
     case SYMBOL_PCREL:
-      reloc = hi_reloc ? "%pc_hi20" : "%pc_lo12";
+      if (hi64_part)
+	{
+	  if (TARGET_CMODEL_EXTREME)
+	    reloc = hi_reloc ? "%pc64_hi12" : "%pc64_lo20";
+	  else
+	    gcc_unreachable ();
+	}
+      else
+	reloc = hi_reloc ? "%pc_hi20" : "%pc_lo12";
       break;
 
     case SYMBOL_GOT_DISP:
-      reloc = hi_reloc ? "%got_pc_hi20" : "%got_pc_lo12";
+      if (hi64_part)
+	{
+	  if (TARGET_CMODEL_EXTREME)
+	    reloc = hi_reloc ? "%got64_pc_hi12" : "%got64_pc_lo20";
+	  else
+	    gcc_unreachable ();
+	}
+      else
+	reloc = hi_reloc ? "%got_pc_hi20" : "%got_pc_lo12";
       break;
 
     case SYMBOL_TLS_IE:
-      reloc = hi_reloc ? "%ie_pc_hi20" : "%ie_pc_lo12";
+      if (hi64_part)
+	{
+	  if (TARGET_CMODEL_EXTREME)
+	    reloc = hi_reloc ? "%ie64_pc_hi12" : "%ie64_pc_lo20";
+	  else
+	    gcc_unreachable ();
+	}
+      else
+	reloc = hi_reloc ? "%ie_pc_hi20" : "%ie_pc_lo12";
       break;
 
     case SYMBOL_TLS_LE:
-      reloc = hi_reloc ? "%le_hi20" : "%le_lo12";
+      if (hi64_part)
+	{
+	  if (TARGET_CMODEL_EXTREME)
+	    reloc = hi_reloc ? "%le64_hi12" : "%le64_lo20";
+	  else
+	    gcc_unreachable ();
+	}
+      else
+	reloc = hi_reloc ? "%le_hi20" : "%le_lo12";
       break;
 
     case SYMBOL_TLSGD:
-      reloc = hi_reloc ? "%gd_pc_hi20" : "%got_pc_lo12";
+      if (hi64_part)
+	{
+	  if (TARGET_CMODEL_EXTREME)
+	    reloc = hi_reloc ? "%got64_pc_hi12" : "%got64_pc_lo20";
+	  else
+	    gcc_unreachable ();
+	}
+      else
+	reloc = hi_reloc ? "%gd_pc_hi20" : "%got_pc_lo12";
       break;
 
     case SYMBOL_TLSLDM:
-      reloc = hi_reloc ? "%ld_pc_hi20" : "%got_pc_lo12";
+      if (hi64_part)
+	{
+	  if (TARGET_CMODEL_EXTREME)
+	    reloc = hi_reloc ? "%got64_pc_hi12" : "%got64_pc_lo20";
+	  else
+	    gcc_unreachable ();
+	}
+      else
+	reloc = hi_reloc ? "%ld_pc_hi20" : "%got_pc_lo12";
       break;
 
     default:
@@ -4637,6 +4777,8 @@ loongarch_print_operand_reloc (FILE *file, rtx op, bool hi_reloc)
    'L'  Print the low-part relocation associated with OP.
    'm'	Print one less than CONST_INT OP in decimal.
    'N'	Print the inverse of the integer branch condition for comparison OP.
+   'r'  Print address 12-31bit relocation associated with OP.
+   'R'  Print address 32-51bit relocation associated with OP.
    'T'	Print 'f' for (eq:CC ...), 't' for (ne:CC ...),
 	      'z' for (eq:?I ...), 'n' for (ne:?I ...).
    't'	Like 'T', but with the EQ/NE cases reversed
@@ -4694,7 +4836,13 @@ loongarch_print_operand (FILE *file, rtx op, int letter)
     case 'h':
       if (code == HIGH)
 	op = XEXP (op, 0);
-      loongarch_print_operand_reloc (file, op, true /* hi_reloc */);
+      loongarch_print_operand_reloc (file, op, false /* hi64_part */,
+				     true /* hi_reloc */);
+      break;
+
+    case 'H':
+      loongarch_print_operand_reloc (file, op, true /* hi64_part */,
+				     true /* hi_reloc */);
       break;
 
     case 'i':
@@ -4703,7 +4851,8 @@ loongarch_print_operand (FILE *file, rtx op, int letter)
       break;
 
     case 'L':
-      loongarch_print_operand_reloc (file, op, false /* lo_reloc */);
+      loongarch_print_operand_reloc (file, op, false /* hi64_part*/,
+				     false /* lo_reloc */);
       break;
 
     case 'm':
@@ -4718,6 +4867,16 @@ loongarch_print_operand (FILE *file, rtx op, int letter)
 					    letter);
       break;
 
+    case 'r':
+      loongarch_print_operand_reloc (file, op, false /* hi64_part */,
+				     true /* lo_reloc */);
+      break;
+
+    case 'R':
+      loongarch_print_operand_reloc (file, op, true /* hi64_part */,
+				     false /* lo_reloc */);
+      break;
+
     case 't':
     case 'T':
       {
@@ -4848,7 +5007,8 @@ loongarch_print_operand_address (FILE *file, machine_mode /* mode  */, rtx x)
 
       case ADDRESS_LO_SUM:
 	fprintf (file, "%s,", reg_names[REGNO (addr.reg)]);
-	loongarch_print_operand_reloc (file, addr.offset, false /* hi_reloc */);
+	loongarch_print_operand_reloc (file, addr.offset, false /* hi64_part */,
+				       false /* hi_reloc */);
 	return;
 
       case ADDRESS_CONST_INT:
@@ -5821,13 +5981,21 @@ loongarch_option_override_internal (struct gcc_options *opts)
 
   switch (la_target.cmodel)
     {
-      case CMODEL_TINY_STATIC:
       case CMODEL_EXTREME:
+	if (!TARGET_EXPLICIT_RELOCS)
+	  error ("code model %qs needs %s",
+		 "extreme", "-mexplicit-relocs");
+
 	if (opts->x_flag_plt)
-	  error ("code model %qs and %qs not support %s mode",
-		 "tiny-static", "extreme", "plt");
+	  {
+	    if (global_options_set.x_flag_plt)
+	      error ("code model %qs is not compatible with %s",
+		     "extreme", "-fplt");
+	    opts->x_flag_plt = 0;
+	  }
 	break;
 
+      case CMODEL_TINY_STATIC:
       case CMODEL_NORMAL:
       case CMODEL_TINY:
       case CMODEL_LARGE:
diff --git a/gcc/config/loongarch/loongarch.md b/gcc/config/loongarch/loongarch.md
index 8e8868de9f5..8fc10444c2a 100644
--- a/gcc/config/loongarch/loongarch.md
+++ b/gcc/config/loongarch/loongarch.md
@@ -60,6 +60,9 @@
 
   UNSPEC_LOAD_FROM_GOT
   UNSPEC_ORI_L_LO12
+  UNSPEC_LUI_L_HI20
+  UNSPEC_LUI_H_LO20
+  UNSPEC_LUI_H_HI12
   UNSPEC_TLS_LOW
 ])
 
@@ -1934,16 +1937,45 @@
   [(set_attr "type" "move")]
 )
 
+(define_insn "@lui_l_hi20<mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+	(unspec:P [(match_operand:P 1 "symbolic_operand")]
+	UNSPEC_LUI_L_HI20))]
+  ""
+  "lu12i.w\t%0,%r1"
+  [(set_attr "type" "move")]
+)
+
 (define_insn "@ori_l_lo12<mode>"
   [(set (match_operand:P 0 "register_operand" "=r")
 	(unspec:P [(match_operand:P 1 "register_operand" "r")
-		    (match_operand:P 2 "symbolic_operand")]
+		   (match_operand:P 2 "symbolic_operand")]
 	UNSPEC_ORI_L_LO12))]
   ""
   "ori\t%0,%1,%L2"
   [(set_attr "type" "move")]
 )
 
+(define_insn "lui_h_lo20"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(unspec:DI [(match_operand:DI 1 "register_operand" "0")
+		    (match_operand:DI 2 "symbolic_operand")]
+	UNSPEC_LUI_H_LO20))]
+  "TARGET_64BIT"
+  "lu32i.d\t%0,%R2"
+  [(set_attr "type" "move")]
+)
+
+(define_insn "lui_h_hi12"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(unspec:DI [(match_operand:DI 1 "register_operand" "r")
+		    (match_operand:DI 2 "symbolic_operand")]
+	UNSPEC_LUI_H_HI12))]
+  "TARGET_64BIT"
+  "lu52i.d\t%0,%1,%H2"
+  [(set_attr "type" "move")]
+)
+
 ;; Convert floating-point numbers to integers
 (define_insn "frint_<fmt>"
   [(set (match_operand:ANYF 0 "register_operand" "=f")
diff --git a/gcc/config/loongarch/predicates.md b/gcc/config/loongarch/predicates.md
index cd3528c7c97..e38c6fbdd5f 100644
--- a/gcc/config/loongarch/predicates.md
+++ b/gcc/config/loongarch/predicates.md
@@ -111,7 +111,7 @@
   (match_code "const,symbol_ref,label_ref")
 {
   /* Split symbol to high and low if return false.
-     If defined TARGET_CMODEL_LARGE, all symbol would be splited,
+     If defined TARGET_CMODEL_EXTREME, all symbol would be splited,
      else if offset is not zero, the symbol would be splited.  */
 
   enum loongarch_symbol_type symbol_type;
@@ -126,10 +126,13 @@
   switch (symbol_type)
     {
     case SYMBOL_PCREL:
-      return 1;
+      if (TARGET_CMODEL_EXTREME)
+	return false;
+      else
+	return 1;
 
     case SYMBOL_GOT_DISP:
-      if (TARGET_CMODEL_LARGE || !flag_plt)
+      if (TARGET_CMODEL_EXTREME || !flag_plt)
 	return false;
       else
 	return 1;
diff --git a/gcc/doc/invoke.texi b/gcc/doc/invoke.texi
index 71408d80ad8..7f87a70d9f0 100644
--- a/gcc/doc/invoke.texi
+++ b/gcc/doc/invoke.texi
@@ -1004,6 +1004,7 @@ Objective-C and Objective-C++ Dialects}.
 -mcond-move-float  -mno-cond-move-float @gol
 -memcpy  -mno-memcpy -mstrict-align -mno-strict-align @gol
 -mmax-inline-memcpy-size=@var{n} @gol
+-mexplicit-relocs -mno-explicit-relocs @gol
 -mcmodel=@var{code-model}}
 
 @emph{M32R/D Options}
@@ -24572,50 +24573,19 @@ less than or equal to @var{n} bytes.  The default value of @var{n} is 1024.
 @item -mcmodel=@var{code-model}
 Set the code model to one of:
 @table @samp
-@item tiny-static
-@itemize @bullet
-@item
-local symbol and global strong symbol: The data section must be within +/-2MiB addressing space.
-The text section must be within +/-128MiB addressing space.
-@item
-global weak symbol: The got table must be within +/-2GiB addressing space.
-@end itemize
-
-@item tiny
-@itemize @bullet
-@item
-local symbol: The data section must be within +/-2MiB addressing space.
-The text section must be within +/-128MiB
-addressing space.
-@item
-global symbol: The got table must be within +/-2GiB addressing space.
-@end itemize
+@item tiny-static (Not implemented yet)
+@item tiny (Not implemented yet)
 
 @item normal
-@itemize @bullet
-@item
-local symbol: The data section must be within +/-2GiB addressing space.
-The text section must be within +/-128MiB addressing space.
-@item
-global symbol: The got table must be within +/-2GiB addressing space.
-@end itemize
+The text segment must be within 128MB addressing space.  The data segment must
+be within 2GB addressing space.
 
-@item large
-@itemize @bullet
-@item
-local symbol: The data section must be within +/-2GiB addressing space.
-The text section must be within +/-128GiB addressing space.
-@item
-global symbol: The got table must be within +/-2GiB addressing space.
-@end itemize
+@item large (Not implemented yet)
 
-@item extreme(Not implemented yet)
-@itemize @bullet
-@item
-local symbol: The data and text section must be within +/-8EiB addressing space.
-@item
-global symbol: The data got table must be within +/-8EiB addressing space.
-@end itemize
+@item extreme
+This mode does not limit the size of the code segment and data segment.
+The @option{-mcmodel=extreme} option is incompatible with @option{-fplt} and
+@option{-mno-explicit-relocs}.
 @end table
 The default code model is @code{normal}.
 
diff --git a/gcc/testsuite/gcc.target/loongarch/func-call-1.c b/gcc/testsuite/gcc.target/loongarch/func-call-1.c
index 01b8ea23fb9..76bf11b0c03 100644
--- a/gcc/testsuite/gcc.target/loongarch/func-call-1.c
+++ b/gcc/testsuite/gcc.target/loongarch/func-call-1.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-mabi=lp64d -O0 -fpic -fplt -mno-explicit-relocs" } */
+/* { dg-options "-mabi=lp64d -O0 -fpic -fplt -mno-explicit-relocs -mcmodel=normal" } */
 /* { dg-final { scan-assembler "test:.*bl\t%plt\\(g\\)\n" } } */
 /* { dg-final { scan-assembler "test1:.*bl\t%plt\\(f\\)\n" } } */
 /* { dg-final { scan-assembler "test2:.*bl\tl\n" } } */
diff --git a/gcc/testsuite/gcc.target/loongarch/func-call-2.c b/gcc/testsuite/gcc.target/loongarch/func-call-2.c
index 4565baaec9e..4b468fef8b4 100644
--- a/gcc/testsuite/gcc.target/loongarch/func-call-2.c
+++ b/gcc/testsuite/gcc.target/loongarch/func-call-2.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-mabi=lp64d -O0 -fno-pic -fplt -mno-explicit-relocs" } */
+/* { dg-options "-mabi=lp64d -O0 -fno-pic -fplt -mno-explicit-relocs -mcmodel=normal" } */
 /* { dg-final { scan-assembler "test:.*bl\t%plt\\(g\\)\n" } } */
 /* { dg-final { scan-assembler "test1:.*bl\tf\n" } } */
 /* { dg-final { scan-assembler "test2:.*bl\tl\n" } } */
diff --git a/gcc/testsuite/gcc.target/loongarch/func-call-3.c b/gcc/testsuite/gcc.target/loongarch/func-call-3.c
index 4f669a029e7..dd3a4882d60 100644
--- a/gcc/testsuite/gcc.target/loongarch/func-call-3.c
+++ b/gcc/testsuite/gcc.target/loongarch/func-call-3.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-mabi=lp64d -O0 -fpic -fno-plt -mno-explicit-relocs" } */
+/* { dg-options "-mabi=lp64d -O0 -fpic -fno-plt -mno-explicit-relocs -mcmodel=normal" } */
 /* { dg-final { scan-assembler "test:.*la\.global\t.*g\n\tjirl" } } */
 /* { dg-final { scan-assembler "test1:.*la\.global\t.*f\n\tjirl" } } */
 /* { dg-final { scan-assembler "test2:.*bl\tl\n" } } */
diff --git a/gcc/testsuite/gcc.target/loongarch/func-call-4.c b/gcc/testsuite/gcc.target/loongarch/func-call-4.c
index 943adb6403f..f8158ec349f 100644
--- a/gcc/testsuite/gcc.target/loongarch/func-call-4.c
+++ b/gcc/testsuite/gcc.target/loongarch/func-call-4.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-mabi=lp64d -O0 -fno-pic -fno-plt -mno-explicit-relocs" } */
+/* { dg-options "-mabi=lp64d -O0 -fno-pic -fno-plt -mno-explicit-relocs -mcmodel=normal" } */
 /* { dg-final { scan-assembler "test:.*la\.global\t.*g\n\tjirl" } } */
 /* { dg-final { scan-assembler "test1:.*bl\tf\n" } } */
 /* { dg-final { scan-assembler "test2:.*bl\tl\n" } } */
diff --git a/gcc/testsuite/gcc.target/loongarch/func-call-5.c b/gcc/testsuite/gcc.target/loongarch/func-call-5.c
index 2c2a1c8a1b6..37994af430d 100644
--- a/gcc/testsuite/gcc.target/loongarch/func-call-5.c
+++ b/gcc/testsuite/gcc.target/loongarch/func-call-5.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-mabi=lp64d -O0 -fpic -fplt -mexplicit-relocs" } */
+/* { dg-options "-mabi=lp64d -O0 -fpic -fplt -mexplicit-relocs -mcmodel=normal" } */
 /* { dg-final { scan-assembler "test:.*bl\t%plt\\(g\\)\n" } } */
 /* { dg-final { scan-assembler "test1:.*bl\t%plt\\(f\\)\n" } } */
 /* { dg-final { scan-assembler "test2:.*bl\tl\n" } } */
diff --git a/gcc/testsuite/gcc.target/loongarch/func-call-6.c b/gcc/testsuite/gcc.target/loongarch/func-call-6.c
index 4b0e4266ec8..8e366e376e7 100644
--- a/gcc/testsuite/gcc.target/loongarch/func-call-6.c
+++ b/gcc/testsuite/gcc.target/loongarch/func-call-6.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-mabi=lp64d -O0 -fno-pic -fplt -mexplicit-relocs" } */
+/* { dg-options "-mabi=lp64d -O0 -fno-pic -fplt -mexplicit-relocs -mcmodel=normal" } */
 /* { dg-final { scan-assembler "test:.*bl\t%plt\\(g\\)\n" } } */
 /* { dg-final { scan-assembler "test1:.*bl\tf\n" } } */
 /* { dg-final { scan-assembler "test2:.*bl\tl\n" } } */
diff --git a/gcc/testsuite/gcc.target/loongarch/func-call-7.c b/gcc/testsuite/gcc.target/loongarch/func-call-7.c
index 51792711f72..4177c3d962e 100644
--- a/gcc/testsuite/gcc.target/loongarch/func-call-7.c
+++ b/gcc/testsuite/gcc.target/loongarch/func-call-7.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-mabi=lp64d -O0 -fpic -fno-plt -mexplicit-relocs" } */
+/* { dg-options "-mabi=lp64d -O0 -fpic -fno-plt -mexplicit-relocs -mcmodel=normal" } */
 /* { dg-final { scan-assembler "test:.*pcalau12i\t.*%got_pc_hi20\\(g\\)\n\tld\.d\t.*%got_pc_lo12\\(g\\)\n\tjirl" } } */
 /* { dg-final { scan-assembler "test1:.*pcalau12i\t.*%got_pc_hi20\\(f\\)\n\tld\.d\t.*%got_pc_lo12\\(f\\)\n\tjirl" } } */
 /* { dg-final { scan-assembler "test2:.*bl\tl\n" } } */
diff --git a/gcc/testsuite/gcc.target/loongarch/func-call-8.c b/gcc/testsuite/gcc.target/loongarch/func-call-8.c
index 330140d883d..4254eaa16d4 100644
--- a/gcc/testsuite/gcc.target/loongarch/func-call-8.c
+++ b/gcc/testsuite/gcc.target/loongarch/func-call-8.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-mabi=lp64d -O0 -fno-pic -fno-plt -mexplicit-relocs" } */
+/* { dg-options "-mabi=lp64d -O0 -fno-pic -fno-plt -mexplicit-relocs -mcmodel=normal" } */
 /* { dg-final { scan-assembler "test:.*pcalau12i\t.*%got_pc_hi20\\(g\\)\n\tld\.d\t.*%got_pc_lo12\\(g\\)\n\tjirl" } } */
 /* { dg-final { scan-assembler "test1:.*bl\tf\n" } } */
 /* { dg-final { scan-assembler "test2:.*bl\tl\n" } } */
diff --git a/gcc/testsuite/gcc.target/loongarch/func-call-extreme-1.c b/gcc/testsuite/gcc.target/loongarch/func-call-extreme-1.c
new file mode 100644
index 00000000000..db1e0f85396
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/func-call-extreme-1.c
@@ -0,0 +1,32 @@
+/* { dg-do compile } */
+/* { dg-options "-mabi=lp64d -O0 -fno-pic -fno-plt -mexplicit-relocs -mcmodel=extreme" } */
+/* { dg-final { scan-assembler "test:.*pcalau12i.*%got_pc_hi20.*\n\taddi\.d.*%got_pc_lo12.*\n\tlu32i\.d.*%got64_pc_lo20.*\n\tlu52i\.d.*%got64_pc_hi12.*\n\tldx\.d" } } */
+/* { dg-final { scan-assembler "test1:.*pcalau12i.*%pc_hi20.*\n\taddi\.d.*%pc_lo12.*\n\tlu32i\.d.*%pc64_lo20.*\n\tlu52i\.d.*pc64_hi12.*\n\tadd\.d" } } */
+/* { dg-final { scan-assembler "test2:.*pcalau12i.*%pc_hi20.*\n\taddi\.d.*%pc_lo12.*\n\tlu32i\.d.*%pc64_lo20.*\n\tlu52i\.d.*pc64_hi12.*\n\tadd\.d" } } */
+
+extern void g (void);
+void
+f (void)
+{}
+
+static void
+l (void)
+{}
+
+void
+test (void)
+{
+  g ();
+}
+
+void
+test1 (void)
+{
+  f ();
+}
+
+void
+test2 (void)
+{
+  l ();
+}
diff --git a/gcc/testsuite/gcc.target/loongarch/func-call-extreme-2.c b/gcc/testsuite/gcc.target/loongarch/func-call-extreme-2.c
new file mode 100644
index 00000000000..21bf81ae837
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/func-call-extreme-2.c
@@ -0,0 +1,32 @@
+/* { dg-do compile } */
+/* { dg-options "-mabi=lp64d -O0 -fpic -fno-plt -mexplicit-relocs -mcmodel=extreme" } */
+/* { dg-final { scan-assembler "test:.*pcalau12i.*%got_pc_hi20.*\n\taddi\.d.*%got_pc_lo12.*\n\tlu32i\.d.*%got64_pc_lo20.*\n\tlu52i\.d.*%got64_pc_hi12.*\n\tldx\.d" } } */
+/* { dg-final { scan-assembler "test1:.*pcalau12i.*%got_pc_hi20.*\n\taddi\.d.*%got_pc_lo12.*\n\tlu32i\.d.*%got64_pc_lo20.*\n\tlu52i\.d.*%got64_pc_hi12.*\n\tldx\.d" } } */
+/* { dg-final { scan-assembler "test2:.*pcalau12i.*%pc_hi20.*\n\taddi\.d.*%pc_lo12.*\n\tlu32i\.d.*%pc64_lo20.*\n\tlu52i\.d.*pc64_hi12.*\n\tadd\.d" } } */
+
+extern void g (void);
+void
+f (void)
+{}
+
+static void
+l (void)
+{}
+
+void
+test (void)
+{
+  g ();
+}
+
+void
+test1 (void)
+{
+  f ();
+}
+
+void
+test2 (void)
+{
+  l ();
+}
diff --git a/gcc/testsuite/gcc.target/loongarch/relocs-symbol-noaddend.c b/gcc/testsuite/gcc.target/loongarch/relocs-symbol-noaddend.c
index bfcc9bc338f..3ec8bd229fd 100644
--- a/gcc/testsuite/gcc.target/loongarch/relocs-symbol-noaddend.c
+++ b/gcc/testsuite/gcc.target/loongarch/relocs-symbol-noaddend.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-mabi=lp64d -mexplicit-relocs -fno-pic -O2" } */
+/* { dg-options "-mabi=lp64d -mexplicit-relocs -fno-pic -O2 -mcmodel=normal" } */
 /* { dg-final { scan-assembler "pcalau12i.*%pc_hi20\\(\.LANCHOR0\\)\n" } } */
 /* { dg-final { scan-assembler "addi\.d.*%pc_lo12\\(\.LANCHOR0\\)\n" } } */
 /* { dg-final { scan-assembler "ldptr.d\t\\\$r4,.*,0\n" } } */
-- 
2.38.1

From ba0712b84a79714f808c2be35196d2caf32d500b Mon Sep 17 00:00:00 2001
From: Lulu Cheng <chenglulu@loongson.cn>
Date: Sat, 20 Aug 2022 15:19:51 +0800
Subject: [PATCH 12/36] LoongArch: Add new code model 'medium'.

The function jump instruction in normal mode is 'bl',
so the scope of the function jump is +-128MB.

Now we've added support for 'medium' mode, this mode is
to complete the function jump through two instructions:
	pcalau12i + jirl
So in this mode the function jump range is increased to +-2GB.

Compared with 'normal' mode, 'medium' mode only affects the
jump range of functions.

gcc/ChangeLog:

	* config/loongarch/genopts/loongarch-strings: Support code model medium.
	* config/loongarch/genopts/loongarch.opt.in: Likewise.
	* config/loongarch/loongarch-def.c: Likewise.
	* config/loongarch/loongarch-def.h (CMODEL_LARGE): Likewise.
	(CMODEL_EXTREME): Likewise.
	(N_CMODEL_TYPES): Likewise.
	(CMODEL_MEDIUM): Likewise.
	* config/loongarch/loongarch-opts.cc: Likewise.
	* config/loongarch/loongarch-opts.h (TARGET_CMODEL_MEDIUM): Likewise.
	* config/loongarch/loongarch-str.h (STR_CMODEL_MEDIUM): Likewise.
	* config/loongarch/loongarch.cc (loongarch_call_tls_get_addr):
	Tls symbol Loading support medium mode.
	(loongarch_legitimize_call_address): When medium mode, make a symbolic
	jump with two instructions.
	(loongarch_option_override_internal): Support medium.
	* config/loongarch/loongarch.md (@pcalau12i<mode>): New template.
	(@sibcall_internal_1<mode>): New function call templates added to support
	medium mode.
	(@sibcall_value_internal_1<mode>): Likewise.
	(@sibcall_value_multiple_internal_1<mode>): Likewise.
	(@call_internal_1<mode>): Likewise.
	(@call_value_internal_1<mode>): Likewise.
	(@call_value_multiple_internal_1<mode>): Likewise.
	* config/loongarch/loongarch.opt: Support medium.
	* config/loongarch/predicates.md: Add processing about medium mode.
	* doc/invoke.texi: Document for '-mcmodel=medium'.

gcc/testsuite/ChangeLog:

	* gcc.target/loongarch/func-call-medium-1.c: New test.
	* gcc.target/loongarch/func-call-medium-2.c: New test.
	* gcc.target/loongarch/func-call-medium-3.c: New test.
	* gcc.target/loongarch/func-call-medium-4.c: New test.
	* gcc.target/loongarch/func-call-medium-5.c: New test.
	* gcc.target/loongarch/func-call-medium-6.c: New test.
	* gcc.target/loongarch/func-call-medium-7.c: New test.
	* gcc.target/loongarch/func-call-medium-8.c: New test.
	* gcc.target/loongarch/tls-gd-noplt.c: Add compile parameter '-mexplicit-relocs'.
---
 .../loongarch/genopts/loongarch-strings       |   1 +
 gcc/config/loongarch/genopts/loongarch.opt.in |   3 +
 gcc/config/loongarch/loongarch-def.c          |   1 +
 gcc/config/loongarch/loongarch-def.h          |   7 +-
 gcc/config/loongarch/loongarch-opts.cc        |  15 ++-
 gcc/config/loongarch/loongarch-opts.h         |   1 +
 gcc/config/loongarch/loongarch-str.h          |   1 +
 gcc/config/loongarch/loongarch.cc             | 123 +++++++++++++----
 gcc/config/loongarch/loongarch.md             | 125 +++++++++++++++++-
 gcc/config/loongarch/loongarch.opt            |   3 +
 gcc/config/loongarch/predicates.md            |  15 ++-
 gcc/doc/invoke.texi                           |   3 +
 .../gcc.target/loongarch/func-call-medium-1.c |  41 ++++++
 .../gcc.target/loongarch/func-call-medium-2.c |  41 ++++++
 .../gcc.target/loongarch/func-call-medium-3.c |  41 ++++++
 .../gcc.target/loongarch/func-call-medium-4.c |  41 ++++++
 .../gcc.target/loongarch/func-call-medium-5.c |  42 ++++++
 .../gcc.target/loongarch/func-call-medium-6.c |  42 ++++++
 .../gcc.target/loongarch/func-call-medium-7.c |  43 ++++++
 .../gcc.target/loongarch/func-call-medium-8.c |  42 ++++++
 .../gcc.target/loongarch/tls-gd-noplt.c       |   4 +-
 21 files changed, 595 insertions(+), 40 deletions(-)
 create mode 100644 gcc/testsuite/gcc.target/loongarch/func-call-medium-1.c
 create mode 100644 gcc/testsuite/gcc.target/loongarch/func-call-medium-2.c
 create mode 100644 gcc/testsuite/gcc.target/loongarch/func-call-medium-3.c
 create mode 100644 gcc/testsuite/gcc.target/loongarch/func-call-medium-4.c
 create mode 100644 gcc/testsuite/gcc.target/loongarch/func-call-medium-5.c
 create mode 100644 gcc/testsuite/gcc.target/loongarch/func-call-medium-6.c
 create mode 100644 gcc/testsuite/gcc.target/loongarch/func-call-medium-7.c
 create mode 100644 gcc/testsuite/gcc.target/loongarch/func-call-medium-8.c

diff --git a/gcc/config/loongarch/genopts/loongarch-strings b/gcc/config/loongarch/genopts/loongarch-strings
index cb88ed56b68..44ebb7ab10b 100644
--- a/gcc/config/loongarch/genopts/loongarch-strings
+++ b/gcc/config/loongarch/genopts/loongarch-strings
@@ -54,5 +54,6 @@ OPTSTR_CMODEL	      cmodel
 STR_CMODEL_NORMAL     normal
 STR_CMODEL_TINY	      tiny
 STR_CMODEL_TS	      tiny-static
+STR_CMODEL_MEDIUM     medium
 STR_CMODEL_LARGE      large
 STR_CMODEL_EXTREME    extreme
diff --git a/gcc/config/loongarch/genopts/loongarch.opt.in b/gcc/config/loongarch/genopts/loongarch.opt.in
index a571b6b7524..ebdd9538d48 100644
--- a/gcc/config/loongarch/genopts/loongarch.opt.in
+++ b/gcc/config/loongarch/genopts/loongarch.opt.in
@@ -172,6 +172,9 @@ Enum(cmodel) String(@@STR_CMODEL_TINY@@) Value(CMODEL_TINY)
 EnumValue
 Enum(cmodel) String(@@STR_CMODEL_TS@@) Value(CMODEL_TINY_STATIC)
 
+EnumValue
+Enum(cmodel) String(@@STR_CMODEL_MEDIUM@@) Value(CMODEL_MEDIUM)
+
 EnumValue
 Enum(cmodel) String(@@STR_CMODEL_LARGE@@) Value(CMODEL_LARGE)
 
diff --git a/gcc/config/loongarch/loongarch-def.c b/gcc/config/loongarch/loongarch-def.c
index c8769b7d65e..cbf995d81b5 100644
--- a/gcc/config/loongarch/loongarch-def.c
+++ b/gcc/config/loongarch/loongarch-def.c
@@ -152,6 +152,7 @@ loongarch_cmodel_strings[] = {
   [CMODEL_NORMAL]	  = STR_CMODEL_NORMAL,
   [CMODEL_TINY]		  = STR_CMODEL_TINY,
   [CMODEL_TINY_STATIC]	  = STR_CMODEL_TS,
+  [CMODEL_MEDIUM]	  = STR_CMODEL_MEDIUM,
   [CMODEL_LARGE]	  = STR_CMODEL_LARGE,
   [CMODEL_EXTREME]	  = STR_CMODEL_EXTREME,
 };
diff --git a/gcc/config/loongarch/loongarch-def.h b/gcc/config/loongarch/loongarch-def.h
index c2c35b6ba5c..b5985f07052 100644
--- a/gcc/config/loongarch/loongarch-def.h
+++ b/gcc/config/loongarch/loongarch-def.h
@@ -82,9 +82,10 @@ extern const char* loongarch_cmodel_strings[];
 #define CMODEL_NORMAL	      0
 #define CMODEL_TINY	      1
 #define CMODEL_TINY_STATIC    2
-#define CMODEL_LARGE	      3
-#define CMODEL_EXTREME	      4
-#define N_CMODEL_TYPES	      5
+#define CMODEL_MEDIUM	      3
+#define CMODEL_LARGE	      4
+#define CMODEL_EXTREME	      5
+#define N_CMODEL_TYPES	      6
 
 /* enum switches */
 /* The "SW_" codes represent command-line switches (options that
diff --git a/gcc/config/loongarch/loongarch-opts.cc b/gcc/config/loongarch/loongarch-opts.cc
index 2ae89f23443..e13eafb5882 100644
--- a/gcc/config/loongarch/loongarch-opts.cc
+++ b/gcc/config/loongarch/loongarch-opts.cc
@@ -376,11 +376,24 @@ fallback:
 
   /* 5.  Target code model */
   t.cmodel = constrained.cmodel ? opt_cmodel : CMODEL_NORMAL;
-  if (t.cmodel != CMODEL_NORMAL && t.cmodel != CMODEL_EXTREME)
+
+  switch (t.cmodel)
     {
+    case CMODEL_TINY:
+    case CMODEL_TINY_STATIC:
+    case CMODEL_LARGE:
       warning (0, "%qs is not supported, now cmodel is set to %qs",
 	       loongarch_cmodel_strings[t.cmodel], "normal");
       t.cmodel = CMODEL_NORMAL;
+      break;
+
+    case CMODEL_NORMAL:
+    case CMODEL_MEDIUM:
+    case CMODEL_EXTREME:
+      break;
+
+    default:
+      gcc_unreachable ();
     }
 
   /* Cleanup and return.  */
diff --git a/gcc/config/loongarch/loongarch-opts.h b/gcc/config/loongarch/loongarch-opts.h
index da24ecd2b50..3523a4cf78d 100644
--- a/gcc/config/loongarch/loongarch-opts.h
+++ b/gcc/config/loongarch/loongarch-opts.h
@@ -46,6 +46,7 @@ loongarch_config_target (struct loongarch_target *target,
 #define TARGET_CMODEL_NORMAL	    (la_target.cmodel == CMODEL_NORMAL)
 #define TARGET_CMODEL_TINY	    (la_target.cmodel == CMODEL_TINY)
 #define TARGET_CMODEL_TINY_STATIC   (la_target.cmodel == CMODEL_TINY_STATIC)
+#define TARGET_CMODEL_MEDIUM	    (la_target.cmodel == CMODEL_MEDIUM)
 #define TARGET_CMODEL_LARGE	    (la_target.cmodel == CMODEL_LARGE)
 #define TARGET_CMODEL_EXTREME	    (la_target.cmodel == CMODEL_EXTREME)
 
diff --git a/gcc/config/loongarch/loongarch-str.h b/gcc/config/loongarch/loongarch-str.h
index 0e8889b8c96..9f1b0989c82 100644
--- a/gcc/config/loongarch/loongarch-str.h
+++ b/gcc/config/loongarch/loongarch-str.h
@@ -53,6 +53,7 @@ along with GCC; see the file COPYING3.  If not see
 #define STR_CMODEL_NORMAL "normal"
 #define STR_CMODEL_TINY "tiny"
 #define STR_CMODEL_TS "tiny-static"
+#define STR_CMODEL_MEDIUM "medium"
 #define STR_CMODEL_LARGE "large"
 #define STR_CMODEL_EXTREME "extreme"
 
diff --git a/gcc/config/loongarch/loongarch.cc b/gcc/config/loongarch/loongarch.cc
index 207ac2762c6..16fd4acc970 100644
--- a/gcc/config/loongarch/loongarch.cc
+++ b/gcc/config/loongarch/loongarch.cc
@@ -2461,44 +2461,96 @@ loongarch_call_tls_get_addr (rtx sym, enum loongarch_symbol_type type, rtx v0)
     }
 
   if (flag_plt)
-    insn = emit_call_insn (gen_call_value_internal (v0,
-						    loongarch_tls_symbol,
-						    const0_rtx));
-  else
     {
-      rtx dest = gen_reg_rtx (Pmode);
-
-      if (TARGET_CMODEL_EXTREME)
+      switch (la_opt_cmodel)
 	{
-	  gcc_assert (TARGET_EXPLICIT_RELOCS);
+	case CMODEL_NORMAL:
+	  insn = emit_call_insn (gen_call_value_internal (v0,
+							  loongarch_tls_symbol,
+							  const0_rtx));
+	  break;
 
-	  rtx tmp1 = gen_reg_rtx (Pmode);
-	  rtx high = gen_reg_rtx (Pmode);
+	case CMODEL_MEDIUM:
+	    {
+	      rtx reg = gen_reg_rtx (Pmode);
+	      if (TARGET_EXPLICIT_RELOCS)
+		{
+		  emit_insn (gen_pcalau12i (Pmode, reg, loongarch_tls_symbol));
+		  rtx call = gen_call_value_internal_1 (Pmode, v0, reg,
+							loongarch_tls_symbol,
+							const0_rtx);
+		  insn = emit_call_insn (call);
+		}
+	      else
+		{
+		  emit_move_insn (reg, loongarch_tls_symbol);
+		  insn = emit_call_insn (gen_call_value_internal (v0,
+								  reg,
+								  const0_rtx));
+		}
+	      break;
+	    }
 
-	  loongarch_emit_move (high,
-			       gen_rtx_HIGH (Pmode, loongarch_tls_symbol));
-	  loongarch_emit_move (tmp1, gen_rtx_LO_SUM (Pmode,
-						     gen_rtx_REG (Pmode, 0),
-						     loongarch_tls_symbol));
-	  emit_insn (gen_lui_h_lo20 (tmp1, tmp1, loongarch_tls_symbol));
-	  emit_insn (gen_lui_h_hi12 (tmp1, tmp1, loongarch_tls_symbol));
-	  loongarch_emit_move (dest,
-			       gen_rtx_MEM (Pmode,
-					    gen_rtx_PLUS (Pmode, high, tmp1)));
+	/* code model extreme not support plt.  */
+	case CMODEL_EXTREME:
+	case CMODEL_LARGE:
+	case CMODEL_TINY:
+	case CMODEL_TINY_STATIC:
+	default:
+	  gcc_unreachable ();
 	}
-      else
+    }
+  else
+    {
+      rtx dest = gen_reg_rtx (Pmode);
+
+      switch (la_opt_cmodel)
 	{
-	  if (TARGET_EXPLICIT_RELOCS)
+	case CMODEL_NORMAL:
+	case CMODEL_MEDIUM:
+	    {
+	      if (TARGET_EXPLICIT_RELOCS)
+		{
+		  rtx high = gen_reg_rtx (Pmode);
+		  loongarch_emit_move (high,
+				       gen_rtx_HIGH (Pmode,
+						     loongarch_tls_symbol));
+		  emit_insn (gen_ld_from_got (Pmode, dest, high,
+					      loongarch_tls_symbol));
+		}
+	      else
+		loongarch_emit_move (dest, loongarch_tls_symbol);
+	      break;
+	    }
+
+	case CMODEL_EXTREME:
 	    {
+	      gcc_assert (TARGET_EXPLICIT_RELOCS);
+
+	      rtx tmp1 = gen_reg_rtx (Pmode);
 	      rtx high = gen_reg_rtx (Pmode);
+
 	      loongarch_emit_move (high,
 				   gen_rtx_HIGH (Pmode, loongarch_tls_symbol));
-	      emit_insn (gen_ld_from_got (Pmode, dest, high,
-					  loongarch_tls_symbol));
+	      loongarch_emit_move (tmp1, gen_rtx_LO_SUM (Pmode,
+							 gen_rtx_REG (Pmode, 0),
+							 loongarch_tls_symbol));
+	      emit_insn (gen_lui_h_lo20 (tmp1, tmp1, loongarch_tls_symbol));
+	      emit_insn (gen_lui_h_hi12 (tmp1, tmp1, loongarch_tls_symbol));
+	      loongarch_emit_move (dest,
+				   gen_rtx_MEM (Pmode,
+						gen_rtx_PLUS (Pmode,
+							      high, tmp1)));
 	    }
-	  else
-	    loongarch_emit_move (dest, loongarch_tls_symbol);
+	  break;
+
+	case CMODEL_LARGE:
+	case CMODEL_TINY:
+	case CMODEL_TINY_STATIC:
+	default:
+	  gcc_unreachable ();
 	}
+
       insn = emit_call_insn (gen_call_value_internal (v0, dest, const0_rtx));
     }
 
@@ -2618,6 +2670,24 @@ loongarch_legitimize_call_address (rtx addr)
       loongarch_emit_move (reg, addr);
       return reg;
     }
+
+  enum loongarch_symbol_type symbol_type = loongarch_classify_symbol (addr);
+
+  /* Split function call insn 'bl sym' or 'bl %plt(sym)' to :
+     pcalau12i $rd, %pc_hi20(sym)
+     jr $rd, %pc_lo12(sym).  */
+
+  if (TARGET_CMODEL_MEDIUM
+      && TARGET_EXPLICIT_RELOCS
+      && (SYMBOL_REF_P (addr) || LABEL_REF_P (addr))
+      && (symbol_type == SYMBOL_PCREL
+	  || (symbol_type == SYMBOL_GOT_DISP && flag_plt)))
+    {
+      rtx reg = gen_reg_rtx (Pmode);
+      emit_insn (gen_pcalau12i (Pmode, reg, addr));
+      return gen_rtx_LO_SUM (Pmode, reg, addr);
+    }
+
   return addr;
 }
 
@@ -5996,6 +6066,7 @@ loongarch_option_override_internal (struct gcc_options *opts)
 	break;
 
       case CMODEL_TINY_STATIC:
+      case CMODEL_MEDIUM:
       case CMODEL_NORMAL:
       case CMODEL_TINY:
       case CMODEL_LARGE:
diff --git a/gcc/config/loongarch/loongarch.md b/gcc/config/loongarch/loongarch.md
index 8fc10444c2a..3787fd8230f 100644
--- a/gcc/config/loongarch/loongarch.md
+++ b/gcc/config/loongarch/loongarch.md
@@ -59,11 +59,15 @@
   UNSPEC_CRCC
 
   UNSPEC_LOAD_FROM_GOT
+  UNSPEC_PCALAU12I
   UNSPEC_ORI_L_LO12
   UNSPEC_LUI_L_HI20
   UNSPEC_LUI_H_LO20
   UNSPEC_LUI_H_HI12
   UNSPEC_TLS_LOW
+
+  UNSPEC_SIBCALL_VALUE_MULTIPLE_INTERNAL_1
+  UNSPEC_CALL_VALUE_MULTIPLE_INTERNAL_1
 ])
 
 (define_c_enum "unspecv" [
@@ -1946,6 +1950,14 @@
   [(set_attr "type" "move")]
 )
 
+(define_insn "@pcalau12i<mode>"
+  [(set (match_operand:P 0 "register_operand" "=j")
+	(unspec:P [(match_operand:P 1 "symbolic_operand" "")]
+	UNSPEC_PCALAU12I))]
+  ""
+  "pcalau12i\t%0,%%pc_hi20(%1)"
+  [(set_attr "type" "move")])
+
 (define_insn "@ori_l_lo12<mode>"
   [(set (match_operand:P 0 "register_operand" "=r")
 	(unspec:P [(match_operand:P 1 "register_operand" "r")
@@ -2877,7 +2889,12 @@
 {
   rtx target = loongarch_legitimize_call_address (XEXP (operands[0], 0));
 
-  emit_call_insn (gen_sibcall_internal (target, operands[1]));
+  if (GET_CODE (target) == LO_SUM)
+    emit_call_insn (gen_sibcall_internal_1 (Pmode, XEXP (target, 0),
+					    XEXP (target, 1),
+					    operands[1]));
+  else
+    emit_call_insn (gen_sibcall_internal (target, operands[1]));
   DONE;
 })
 
@@ -2891,6 +2908,14 @@
    b\t%%plt(%0)"
   [(set_attr "jirl" "indirect,direct,direct")])
 
+(define_insn "@sibcall_internal_1<mode>"
+  [(call (mem:P (lo_sum:P (match_operand:P 0 "register_operand" "j")
+			  (match_operand:P 1 "symbolic_operand" "")))
+	 (match_operand 2 "" ""))]
+  "SIBLING_CALL_P (insn) && TARGET_CMODEL_MEDIUM"
+  "jirl\t$r0,%0,%%pc_lo12(%1)"
+  [(set_attr "jirl" "indirect")])
+
 (define_expand "sibcall_value"
   [(parallel [(set (match_operand 0 "")
 		   (call (match_operand 1 "")
@@ -2906,7 +2931,14 @@
       rtx arg1 = XEXP (XVECEXP (operands[0],0, 0), 0);
       rtx arg2 = XEXP (XVECEXP (operands[0],0, 1), 0);
 
-      emit_call_insn (gen_sibcall_value_multiple_internal (arg1, target,
+      if (GET_CODE (target) == LO_SUM)
+	emit_call_insn (gen_sibcall_value_multiple_internal_1 (Pmode, arg1,
+							   XEXP (target, 0),
+							   XEXP (target, 1),
+							   operands[2],
+							   arg2));
+      else
+	emit_call_insn (gen_sibcall_value_multiple_internal (arg1, target,
 							   operands[2],
 							   arg2));
     }
@@ -2916,7 +2948,13 @@
       if (GET_CODE (operands[0]) == PARALLEL && XVECLEN (operands[0], 0) == 1)
 	operands[0] = XEXP (XVECEXP (operands[0], 0, 0), 0);
 
-      emit_call_insn (gen_sibcall_value_internal (operands[0], target,
+      if (GET_CODE (target) == LO_SUM)
+	emit_call_insn (gen_sibcall_value_internal_1 (Pmode, operands[0],
+						  XEXP (target, 0),
+						  XEXP (target, 1),
+						  operands[2]));
+      else
+	emit_call_insn (gen_sibcall_value_internal (operands[0], target,
 						  operands[2]));
     }
   DONE;
@@ -2933,6 +2971,15 @@
    b\t%%plt(%1)"
   [(set_attr "jirl" "indirect,direct,direct")])
 
+(define_insn "@sibcall_value_internal_1<mode>"
+  [(set (match_operand 0 "register_operand" "")
+	(call (mem:P (lo_sum:P (match_operand:P 1 "register_operand" "j")
+			       (match_operand:P 2 "symbolic_operand" "")))
+	      (match_operand 3 "" "")))]
+  "SIBLING_CALL_P (insn) && TARGET_CMODEL_MEDIUM"
+  "jirl\t$r0,%1,%%pc_lo12(%2)"
+  [(set_attr "jirl" "indirect")])
+
 (define_insn "sibcall_value_multiple_internal"
   [(set (match_operand 0 "register_operand" "")
 	(call (mem:SI (match_operand 1 "call_insn_operand" "j,c,b"))
@@ -2947,6 +2994,21 @@
    b\t%%plt(%1)"
   [(set_attr "jirl" "indirect,direct,direct")])
 
+(define_insn "@sibcall_value_multiple_internal_1<mode>"
+  [(set (match_operand 0 "register_operand" "")
+	(call (mem:P (unspec:P [(match_operand:P 1 "register_operand" "j")
+			        (match_operand:P 2 "symbolic_operand" "")]
+		      UNSPEC_SIBCALL_VALUE_MULTIPLE_INTERNAL_1))
+	      (match_operand 3 "" "")))
+   (set (match_operand 4 "register_operand" "")
+	(call (mem:P (unspec:P [(match_dup 1)
+			        (match_dup 2)]
+		      UNSPEC_SIBCALL_VALUE_MULTIPLE_INTERNAL_1))
+	      (match_dup 3)))]
+  "SIBLING_CALL_P (insn) && TARGET_CMODEL_MEDIUM"
+  "jirl\t$r0,%1,%%pc_lo12(%2)"
+  [(set_attr "jirl" "indirect")])
+
 (define_expand "call"
   [(parallel [(call (match_operand 0 "")
 		    (match_operand 1 ""))
@@ -2956,7 +3018,11 @@
 {
   rtx target = loongarch_legitimize_call_address (XEXP (operands[0], 0));
 
-  emit_call_insn (gen_call_internal (target, operands[1]));
+  if (GET_CODE (target) == LO_SUM)
+    emit_call_insn (gen_call_internal_1 (Pmode, XEXP (target, 0),
+					 XEXP (target, 1), operands[1]));
+  else
+    emit_call_insn (gen_call_internal (target, operands[1]));
   DONE;
 })
 
@@ -2971,6 +3037,15 @@
    bl\t%%plt(%0)"
   [(set_attr "jirl" "indirect,direct,direct")])
 
+(define_insn "@call_internal_1<mode>"
+  [(call (mem:P (lo_sum:P (match_operand:P 0 "register_operand" "j")
+			  (match_operand:P 1 "symbolic_operand" "")))
+	 (match_operand 2 "" ""))
+   (clobber (reg:SI RETURN_ADDR_REGNUM))]
+  "TARGET_CMODEL_MEDIUM"
+  "jirl\t$r1,%0,%%pc_lo12(%1)"
+  [(set_attr "jirl" "indirect")])
+
 (define_expand "call_value"
   [(parallel [(set (match_operand 0 "")
 		   (call (match_operand 1 "")
@@ -2985,7 +3060,13 @@
       rtx arg1 = XEXP (XVECEXP (operands[0], 0, 0), 0);
       rtx arg2 = XEXP (XVECEXP (operands[0], 0, 1), 0);
 
-      emit_call_insn (gen_call_value_multiple_internal (arg1, target,
+      if (GET_CODE (target) == LO_SUM)
+	emit_call_insn (gen_call_value_multiple_internal_1 (Pmode, arg1,
+							    XEXP (target, 0),
+							    XEXP (target, 1),
+							    operands[2], arg2));
+      else
+	emit_call_insn (gen_call_value_multiple_internal (arg1, target,
 							operands[2], arg2));
     }
    else
@@ -2994,7 +3075,13 @@
       if (GET_CODE (operands[0]) == PARALLEL && XVECLEN (operands[0], 0) == 1)
 	    operands[0] = XEXP (XVECEXP (operands[0], 0, 0), 0);
 
-      emit_call_insn (gen_call_value_internal (operands[0], target,
+      if (GET_CODE (target) == LO_SUM)
+	emit_call_insn (gen_call_value_internal_1 (Pmode, operands[0],
+						   XEXP (target, 0),
+						   XEXP (target, 1),
+						   operands[2]));
+      else
+	emit_call_insn (gen_call_value_internal (operands[0], target,
 					       operands[2]));
     }
   DONE;
@@ -3012,6 +3099,16 @@
    bl\t%%plt(%1)"
   [(set_attr "jirl" "indirect,direct,direct")])
 
+(define_insn "@call_value_internal_1<mode>"
+  [(set (match_operand 0 "register_operand" "")
+	(call (mem:P (lo_sum:P (match_operand:P 1 "register_operand" "j")
+			       (match_operand:P 2 "symbolic_operand" "")))
+	      (match_operand 3 "" "")))
+   (clobber (reg:SI RETURN_ADDR_REGNUM))]
+  "TARGET_CMODEL_MEDIUM"
+  "jirl\t$r1,%1,%%pc_lo12(%2)"
+  [(set_attr "jirl" "indirect")])
+
 (define_insn "call_value_multiple_internal"
   [(set (match_operand 0 "register_operand" "")
 	(call (mem:SI (match_operand 1 "call_insn_operand" "e,c,b"))
@@ -3027,6 +3124,22 @@
    bl\t%%plt(%1)"
   [(set_attr "jirl" "indirect,direct,direct")])
 
+(define_insn "@call_value_multiple_internal_1<mode>"
+  [(set (match_operand 0 "register_operand" "")
+	(call (mem:P (unspec:P [(match_operand:P 1 "register_operand" "j")
+			        (match_operand:P 2 "symbolic_operand" "")]
+		      UNSPEC_CALL_VALUE_MULTIPLE_INTERNAL_1))
+	      (match_operand 3 "" "")))
+   (set (match_operand 4 "register_operand" "")
+	(call (mem:P (unspec:P [(match_dup 1)
+			        (match_dup 2)]
+		      UNSPEC_CALL_VALUE_MULTIPLE_INTERNAL_1))
+	      (match_dup 3)))
+   (clobber (reg:SI RETURN_ADDR_REGNUM))]
+  "TARGET_CMODEL_MEDIUM"
+  "jirl\t$r1,%1,%%pc_lo12(%2)"
+  [(set_attr "jirl" "indirect")])
+
 
 ;; Call subroutine returning any type.
 (define_expand "untyped_call"
diff --git a/gcc/config/loongarch/loongarch.opt b/gcc/config/loongarch/loongarch.opt
index 9df7e187283..6395234218b 100644
--- a/gcc/config/loongarch/loongarch.opt
+++ b/gcc/config/loongarch/loongarch.opt
@@ -179,6 +179,9 @@ Enum(cmodel) String(tiny) Value(CMODEL_TINY)
 EnumValue
 Enum(cmodel) String(tiny-static) Value(CMODEL_TINY_STATIC)
 
+EnumValue
+Enum(cmodel) String(medium) Value(CMODEL_MEDIUM)
+
 EnumValue
 Enum(cmodel) String(large) Value(CMODEL_LARGE)
 
diff --git a/gcc/config/loongarch/predicates.md b/gcc/config/loongarch/predicates.md
index e38c6fbdd5f..8bd0c1376c9 100644
--- a/gcc/config/loongarch/predicates.md
+++ b/gcc/config/loongarch/predicates.md
@@ -123,16 +123,27 @@
   if (offset != const0_rtx)
     return false;
 
+  /* When compiling with '-mcmodel=medium -mexplicit-relocs'
+     symbols are splited in loongarch_legitimize_call_address.
+
+     When compiling with '-mcmodel=medium -mno-explicit-relocs',
+     first obtain the symbolic address or the address of the
+     plt entry, and then perform an indirect jump, so return false.  */
+
   switch (symbol_type)
     {
     case SYMBOL_PCREL:
-      if (TARGET_CMODEL_EXTREME)
+      if (TARGET_CMODEL_EXTREME
+	  || (TARGET_CMODEL_MEDIUM && !TARGET_EXPLICIT_RELOCS))
 	return false;
       else
 	return 1;
 
     case SYMBOL_GOT_DISP:
-      if (TARGET_CMODEL_EXTREME || !flag_plt)
+      if (TARGET_CMODEL_EXTREME
+	  || !flag_plt
+	  || (flag_plt && TARGET_CMODEL_MEDIUM
+	      && !TARGET_EXPLICIT_RELOCS))
 	return false;
       else
 	return 1;
diff --git a/gcc/doc/invoke.texi b/gcc/doc/invoke.texi
index 7f87a70d9f0..c0a084f6036 100644
--- a/gcc/doc/invoke.texi
+++ b/gcc/doc/invoke.texi
@@ -24580,6 +24580,9 @@ Set the code model to one of:
 The text segment must be within 128MB addressing space.  The data segment must
 be within 2GB addressing space.
 
+@item medium
+The text segment and data segment must be within 2GB addressing space.
+
 @item large (Not implemented yet)
 
 @item extreme
diff --git a/gcc/testsuite/gcc.target/loongarch/func-call-medium-1.c b/gcc/testsuite/gcc.target/loongarch/func-call-medium-1.c
new file mode 100644
index 00000000000..276d73e5ee8
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/func-call-medium-1.c
@@ -0,0 +1,41 @@
+/* { dg-do compile } */
+/* { dg-options "-mabi=lp64d -O0 -fpic -fplt -mno-explicit-relocs -mcmodel=medium" } */
+/* { dg-final { scan-assembler "test:.*la\.global\t.*g\n\tjirl" } } */
+/* { dg-final { scan-assembler "test1:.*la\.global\t.*f\n\tjirl" } } */
+/* { dg-final { scan-assembler "test2:.*la\.local\t.*l\n\tjirl" } } */
+/* { dg-final { scan-assembler "test3:.*la\.global\t.*\_\_tls\_get\_addr" } } */
+
+extern void g (void);
+void
+f (void)
+{}
+
+static void
+l (void)
+{}
+
+void
+test (void)
+{
+  g ();
+}
+
+void
+test1 (void)
+{
+  f ();
+}
+
+void
+test2 (void)
+{
+  l ();
+}
+
+__attribute__ ((tls_model ("global-dynamic"))) __thread int a;
+
+void
+test3 (void)
+{
+  a = 10;
+}
diff --git a/gcc/testsuite/gcc.target/loongarch/func-call-medium-2.c b/gcc/testsuite/gcc.target/loongarch/func-call-medium-2.c
new file mode 100644
index 00000000000..237821c066b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/func-call-medium-2.c
@@ -0,0 +1,41 @@
+/* { dg-do compile } */
+/* { dg-options "-mabi=lp64d -O0 -fno-pic -fplt -mno-explicit-relocs -mcmodel=medium" } */
+/* { dg-final { scan-assembler "test:.*la\.global\t.*g\n\tjirl" } } */
+/* { dg-final { scan-assembler "test1:.*la\.local\t.*f\n\tjirl" } } */
+/* { dg-final { scan-assembler "test2:.*la\.local\t.*l\n\tjirl" } } */
+/* { dg-final { scan-assembler "test3:.*la\.global\t.*\_\_tls\_get\_addr" } } */
+
+extern void g (void);
+void
+f (void)
+{}
+
+static void
+l (void)
+{}
+
+void
+test (void)
+{
+  g ();
+}
+
+void
+test1 (void)
+{
+  f ();
+}
+
+void
+test2 (void)
+{
+  l ();
+}
+
+__attribute__ ((tls_model ("global-dynamic"))) __thread int a;
+
+void
+test3 (void)
+{
+  a = 10;
+}
diff --git a/gcc/testsuite/gcc.target/loongarch/func-call-medium-3.c b/gcc/testsuite/gcc.target/loongarch/func-call-medium-3.c
new file mode 100644
index 00000000000..9a6e16103bc
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/func-call-medium-3.c
@@ -0,0 +1,41 @@
+/* { dg-do compile } */
+/* { dg-options "-mabi=lp64d -O0 -fpic -fno-plt -mno-explicit-relocs -mcmodel=medium" } */
+/* { dg-final { scan-assembler "test:.*la\.global\t.*g\n\tjirl" } } */
+/* { dg-final { scan-assembler "test1:.*la\.global\t.*f\n\tjirl" } } */
+/* { dg-final { scan-assembler "test2:.*la\.local\t.*l\n\tjirl" } } */
+/* { dg-final { scan-assembler "test3:.*la\.global\t.*\_\_tls\_get\_addr" } } */
+
+extern void g (void);
+void
+f (void)
+{}
+
+static void
+l (void)
+{}
+
+void
+test (void)
+{
+  g ();
+}
+
+void
+test1 (void)
+{
+  f ();
+}
+
+void
+test2 (void)
+{
+  l ();
+}
+
+__attribute__ ((tls_model ("global-dynamic"))) __thread int a;
+
+void
+test3 (void)
+{
+  a = 10;
+}
diff --git a/gcc/testsuite/gcc.target/loongarch/func-call-medium-4.c b/gcc/testsuite/gcc.target/loongarch/func-call-medium-4.c
new file mode 100644
index 00000000000..2577e345239
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/func-call-medium-4.c
@@ -0,0 +1,41 @@
+/* { dg-do compile } */
+/* { dg-options "-mabi=lp64d -O0 -fno-pic -fno-plt -mno-explicit-relocs -mcmodel=medium" } */
+/* { dg-final { scan-assembler "test:.*la\.global\t.*g\n\tjirl" } } */
+/* { dg-final { scan-assembler "test1:.*la\.local\t.*f\n\tjirl" } } */
+/* { dg-final { scan-assembler "test2:.*la\.local\t.*l\n\tjirl" } } */
+/* { dg-final { scan-assembler "test3:.*la\.global\t.*\_\_tls\_get\_addr" } } */
+
+extern void g (void);
+void
+f (void)
+{}
+
+static void
+l (void)
+{}
+
+void
+test (void)
+{
+  g ();
+}
+
+void
+test1 (void)
+{
+  f ();
+}
+
+void
+test2 (void)
+{
+  l ();
+}
+
+__attribute__ ((tls_model ("global-dynamic"))) __thread int a;
+
+void
+test3 (void)
+{
+  a = 10;
+}
diff --git a/gcc/testsuite/gcc.target/loongarch/func-call-medium-5.c b/gcc/testsuite/gcc.target/loongarch/func-call-medium-5.c
new file mode 100644
index 00000000000..d70b6ea4663
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/func-call-medium-5.c
@@ -0,0 +1,42 @@
+/* { dg-do compile } */
+/* { dg-options "-mabi=lp64d -O0 -fpic -fplt -mexplicit-relocs -mcmodel=medium" } */
+/* { dg-final { scan-assembler "test:.*pcalau12i.*%pc_hi20\\(g\\)\n\tjirl.*pc_lo12\\(g\\)" } } */
+/* { dg-final { scan-assembler "test1:.*pcalau12i.*%pc_hi20\\(f\\)\n\tjirl.*%pc_lo12\\(f\\)" } } */
+/* { dg-final { scan-assembler "test2:.*pcalau12i.*%pc_hi20\\(l\\)\n\tjirl.*%pc_lo12\\(l\\)" } } */
+/* { dg-final { scan-assembler "test3:.*pcalau12i.*%pc_hi20\\(__tls_get_addr\\)\n\t.*\n\tjirl.*%pc_lo12\\(__tls_get_addr\\)" } } */
+
+extern void g (void);
+
+void
+f (void)
+{}
+
+static void
+l (void)
+{}
+
+void
+test (void)
+{
+  g ();
+}
+
+void
+test1 (void)
+{
+  f ();
+}
+
+void
+test2 (void)
+{
+  l ();
+}
+
+__attribute__ ((tls_model ("global-dynamic"))) __thread int a;
+
+void
+test3 (void)
+{
+  a = 10;
+}
diff --git a/gcc/testsuite/gcc.target/loongarch/func-call-medium-6.c b/gcc/testsuite/gcc.target/loongarch/func-call-medium-6.c
new file mode 100644
index 00000000000..f963a99441a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/func-call-medium-6.c
@@ -0,0 +1,42 @@
+/* { dg-do compile } */
+/* { dg-options "-mabi=lp64d -O0 -fno-pic -fplt -mexplicit-relocs -mcmodel=medium" } */
+/* { dg-final { scan-assembler "test:.*pcalau12i.*%pc_hi20\\(g\\)\n\tjirl.*pc_lo12\\(g\\)" } } */
+/* { dg-final { scan-assembler "test1:.*pcalau12i.*%pc_hi20\\(f\\)\n\tjirl.*%pc_lo12\\(f\\)" } } */
+/* { dg-final { scan-assembler "test2:.*pcalau12i.*%pc_hi20\\(l\\)\n\tjirl.*%pc_lo12\\(l\\)" } } */
+/* { dg-final { scan-assembler "test3:.*pcalau12i.*%pc_hi20\\(__tls_get_addr\\)\n\t.*\n\tjirl.*%pc_lo12\\(__tls_get_addr\\)" } } */
+
+extern void g (void);
+
+void
+f (void)
+{}
+
+static void
+l (void)
+{}
+
+void
+test (void)
+{
+  g ();
+}
+
+void
+test1 (void)
+{
+  f ();
+}
+
+void
+test2 (void)
+{
+  l ();
+}
+
+__attribute__ ((tls_model ("global-dynamic"))) __thread int a;
+
+void
+test3 (void)
+{
+  a = 10;
+}
diff --git a/gcc/testsuite/gcc.target/loongarch/func-call-medium-7.c b/gcc/testsuite/gcc.target/loongarch/func-call-medium-7.c
new file mode 100644
index 00000000000..f2818b2da76
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/func-call-medium-7.c
@@ -0,0 +1,43 @@
+/* { dg-do compile } */
+/* { dg-options "-mabi=lp64d -O0 -fpic -fno-plt -mexplicit-relocs -mcmodel=medium" } */
+/* { dg-final { scan-assembler "test:.*pcalau12i\t.*%got_pc_hi20\\(g\\)\n\tld\.d\t.*%got_pc_lo12\\(g\\)\n\tjirl" } } */
+/* { dg-final { scan-assembler "test1:.*pcalau12i\t.*%got_pc_hi20\\(f\\)\n\tld\.d\t.*%got_pc_lo12\\(f\\)\n\tjirl" } } */
+/* { dg-final { scan-assembler "test2:.*pcalau12i\t.*%pc_hi20\\(l\\)\n\tjirl.*%pc_lo12\\(l\\)" } } */
+/* { dg-final { scan-assembler "test3:.*pcalau12i.*%got_pc_hi20\\(__tls_get_addr\\)\n\tld\.d.*%got_pc_lo12\\(__tls_get_addr\\)" } } */
+
+
+extern void g (void);
+
+void
+f (void)
+{}
+
+static void
+l (void)
+{}
+
+void
+test (void)
+{
+  g ();
+}
+
+void
+test1 (void)
+{
+  f ();
+}
+
+void
+test2 (void)
+{
+  l ();
+}
+
+__attribute__ ((tls_model ("global-dynamic"))) __thread int a;
+
+void
+test3 (void)
+{
+  a = 10;
+}
diff --git a/gcc/testsuite/gcc.target/loongarch/func-call-medium-8.c b/gcc/testsuite/gcc.target/loongarch/func-call-medium-8.c
new file mode 100644
index 00000000000..7fa873d84bb
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/func-call-medium-8.c
@@ -0,0 +1,42 @@
+/* { dg-do compile } */
+/* { dg-options "-mabi=lp64d -O0 -fno-pic -fno-plt -mexplicit-relocs -mcmodel=medium" } */
+/* { dg-final { scan-assembler "test:.*pcalau12i\t.*%got_pc_hi20\\(g\\)\n\tld\.d\t.*%got_pc_lo12\\(g\\)\n\tjirl" } } */
+/* { dg-final { scan-assembler "test1:.*pcalau12i\t.*%pc_hi20\\(f\\)\n\tjirl.*%pc_lo12\\(f\\)" } } */
+/* { dg-final { scan-assembler "test2:.*pcalau12i\t.*%pc_hi20\\(l\\)\n\tjirl.*%pc_lo12\\(l\\)" } } */
+/* { dg-final { scan-assembler "test3:.*pcalau12i.*%got_pc_hi20\\(__tls_get_addr\\)\n\tld\.d.*%got_pc_lo12\\(__tls_get_addr\\)" } } */
+
+extern void g (void);
+
+void
+f (void)
+{}
+
+static void
+l (void)
+{}
+
+void
+test (void)
+{
+  g ();
+}
+
+void
+test1 (void)
+{
+  f ();
+}
+
+void
+test2 (void)
+{
+  l ();
+}
+
+__attribute__ ((tls_model ("global-dynamic"))) __thread int a;
+
+void
+test3 (void)
+{
+  a = 10;
+}
diff --git a/gcc/testsuite/gcc.target/loongarch/tls-gd-noplt.c b/gcc/testsuite/gcc.target/loongarch/tls-gd-noplt.c
index 32a0acf9b18..375663286f0 100644
--- a/gcc/testsuite/gcc.target/loongarch/tls-gd-noplt.c
+++ b/gcc/testsuite/gcc.target/loongarch/tls-gd-noplt.c
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -fno-plt -mcmodel=normal" } */
-/* { dg-final { scan-assembler "pcalau12i\t.*%got_pc_hi20\\(__tls_get_addr\\)" } } */
+/* { dg-options "-O0 -fno-plt -mcmodel=normal -mexplicit-relocs" } */
+/* { dg-final { scan-assembler "pcalau12i\t.*%got_pc_hi20\\(__tls_get_addr\\)\n\tld\.d.*%got_pc_lo12\\(__tls_get_addr\\)" } } */
 
 __attribute__ ((tls_model ("global-dynamic"))) __thread int a;
 
-- 
2.38.1

From 75c579352d9acc82bb22aa48bac7250b104c54ba Mon Sep 17 00:00:00 2001
From: Chenghua Xu <xuchenghua@loongson.cn>
Date: Wed, 24 Aug 2022 15:34:07 +0800
Subject: [PATCH 13/36] LoongArch: Fix pr106459 by use HWIT instead of 1UL.

gcc/ChangeLog:

	PR target/106459
	* config/loongarch/loongarch.cc (loongarch_build_integer):
	Use HOST_WIDE_INT.
	* config/loongarch/loongarch.h (IMM_REACH): Likewise.
	(HWIT_1U): New Defined.
	(LU12I_OPERAND): Use HOST_WIDE_INT.
	(LU32I_OPERAND): Likewise.
	(LU52I_OPERAND): Likewise.
	(HWIT_UC_0xFFF): Likwise.

gcc/testsuite/ChangeLog:

	* gcc.target/loongarch/pr106459.c: New test.
---
 gcc/config/loongarch/loongarch.cc             |  6 +++---
 gcc/config/loongarch/loongarch.h              | 15 +++++++++------
 gcc/testsuite/gcc.target/loongarch/pr106459.c | 13 +++++++++++++
 3 files changed, 25 insertions(+), 9 deletions(-)
 create mode 100644 gcc/testsuite/gcc.target/loongarch/pr106459.c

diff --git a/gcc/config/loongarch/loongarch.cc b/gcc/config/loongarch/loongarch.cc
index 16fd4acc970..04c4ddaedce 100644
--- a/gcc/config/loongarch/loongarch.cc
+++ b/gcc/config/loongarch/loongarch.cc
@@ -1500,8 +1500,8 @@ loongarch_build_integer (struct loongarch_integer_op *codes,
       bool lu32i[2] = {(value & LU32I_B) == 0, (value & LU32I_B) == LU32I_B};
       bool lu52i[2] = {(value & LU52I_B) == 0, (value & LU52I_B) == LU52I_B};
 
-      int sign31 = (value & (1UL << 31)) >> 31;
-      int sign51 = (value & (1UL << 51)) >> 51;
+      int sign31 = (value & (HOST_WIDE_INT_1U << 31)) >> 31;
+      int sign51 = (value & (HOST_WIDE_INT_1U << 51)) >> 51;
       /* Determine whether the upper 32 bits are sign-extended from the lower
 	 32 bits. If it is, the instructions to load the high order can be
 	 ommitted.  */
@@ -1522,7 +1522,7 @@ loongarch_build_integer (struct loongarch_integer_op *codes,
 
       /* Determine whether the 52-61 bits are sign-extended from the low order,
 	 and if not, load the 52-61 bits.  */
-      if (!lu52i[(value & (1ULL << 51)) >> 51])
+      if (!lu52i[(value & (HOST_WIDE_INT_1U << 51)) >> 51])
 	{
 	  codes[cost].method = METHOD_LU52I;
 	  codes[cost].value = value & LU52I_B;
diff --git a/gcc/config/loongarch/loongarch.h b/gcc/config/loongarch/loongarch.h
index 8b1288961e4..f4a9c329fef 100644
--- a/gcc/config/loongarch/loongarch.h
+++ b/gcc/config/loongarch/loongarch.h
@@ -561,7 +561,8 @@ enum reg_class
   64, 65, 66, 67, 68, 69, 70, 71, 72, 73}
 
 #define IMM_BITS 12
-#define IMM_REACH (1LL << IMM_BITS)
+#define IMM_REACH (HOST_WIDE_INT_1 << IMM_BITS)
+#define HWIT_1U HOST_WIDE_INT_1U
 
 /* True if VALUE is an unsigned 6-bit number.  */
 
@@ -589,18 +590,20 @@ enum reg_class
 /* True if VALUE can be loaded into a register using LU12I.  */
 
 #define LU12I_OPERAND(VALUE) \
-  (((VALUE) | ((1UL << 31) - IMM_REACH)) == ((1UL << 31) - IMM_REACH) \
-   || ((VALUE) | ((1UL << 31) - IMM_REACH)) + IMM_REACH == 0)
+  (((VALUE) | ((HWIT_1U << 31) - IMM_REACH)) == ((HWIT_1U << 31) - IMM_REACH) \
+   || ((VALUE) | ((HWIT_1U << 31) - IMM_REACH)) + IMM_REACH == 0)
 
 /* True if VALUE can be loaded into a register using LU32I.  */
 
 #define LU32I_OPERAND(VALUE) \
-  (((VALUE) | (((1ULL << 19) - 1) << 32)) == (((1ULL << 19) - 1) << 32) \
-   || ((VALUE) | (((1ULL << 19) - 1) << 32)) + (1ULL << 32) == 0)
+  (((VALUE) | (((HWIT_1U << 19) - 1) << 32)) == (((HWIT_1U << 19) - 1) << 32) \
+   || ((VALUE) | (((HWIT_1U << 19) - 1) << 32)) + (HWIT_1U << 32) == 0)
 
 /* True if VALUE can be loaded into a register using LU52I.  */
 
-#define LU52I_OPERAND(VALUE) (((VALUE) | (0xfffULL << 52)) == (0xfffULL << 52))
+#define HWIT_UC_0xFFF HOST_WIDE_INT_UC(0xfff)
+#define LU52I_OPERAND(VALUE) \
+  (((VALUE) | (HWIT_UC_0xFFF << 52)) == (HWIT_UC_0xFFF << 52))
 
 /* Return a value X with the low 12 bits clear, and such that
    VALUE - X is a signed 12-bit value.  */
diff --git a/gcc/testsuite/gcc.target/loongarch/pr106459.c b/gcc/testsuite/gcc.target/loongarch/pr106459.c
new file mode 100644
index 00000000000..eb737dc49c1
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/pr106459.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+
+/* https://gcc.gnu.org/bugzilla/show_bug.cgi?id=106459 */
+
+typedef unsigned int UDItype __attribute__((mode(DI)));
+int foo(UDItype x) {
+  x = x & (((UDItype)(((UDItype)(((UDItype)0x0F << 8) | 0x0F) << (2 * 8)) |
+                      (((UDItype)0x0F << 8) | 0x0F))
+            << (4 * 8)) |
+           (((UDItype)(((UDItype)0x0F << 8) | 0x0F) << (2 * 8)) |
+            (((UDItype)0x0F << 8) | 0x0F)));
+  return x;
+}
-- 
2.38.1

From 3260370db61b7c315f5086098473e7b0877a099b Mon Sep 17 00:00:00 2001
From: Xi Ruoyao <xry111@xry111.site>
Date: Wed, 24 Aug 2022 21:31:34 +0800
Subject: [PATCH 14/36] LoongArch: Avoid RTL flag check failure in
 loongarch_classify_symbol

SYMBOL_REF_TLS_MODEL invokes SYMBOL_REF_FLAGS, and SYMBOL_REF_FLAGS
invokes RTL_FLAG_CHECK1 and aborts when RTL code is not SYMBOL_REF.

r13-1833 removed "gcc_assert (SYMBOL_REF_P (x))" before invoking
"SYMBOL_REF_TLS_MODEL (x)", indicating that it's now possible that "x"
is not a SYMBOL_REF.  So we need to check if "x" is SYMBOL_REF first.

This fixes a test failure happening with r13-2173 with RTL flag
checking enabled:

    pr106096.C:26:1: internal compiler error: RTL flag check:
    SYMBOL_REF_FLAGS used with unexpected rtx code 'const' in
    loongarch_classify_symbol

gcc/ChangeLog:

	* config/loongarch/loongarch.cc (loongarch_classify_symbol):
	Return early if the rtx is not SYMBOL_REF.
---
 gcc/config/loongarch/loongarch.cc | 5 ++---
 1 file changed, 2 insertions(+), 3 deletions(-)

diff --git a/gcc/config/loongarch/loongarch.cc b/gcc/config/loongarch/loongarch.cc
index 04c4ddaedce..452aba9d428 100644
--- a/gcc/config/loongarch/loongarch.cc
+++ b/gcc/config/loongarch/loongarch.cc
@@ -1633,14 +1633,13 @@ loongarch_rtx_constant_in_small_data_p (machine_mode mode)
 static enum loongarch_symbol_type
 loongarch_classify_symbol (const_rtx x)
 {
-  if (LABEL_REF_P (x))
+  if (!SYMBOL_REF_P (x))
     return SYMBOL_PCREL;
 
   if (SYMBOL_REF_TLS_MODEL (x))
     return SYMBOL_TLS;
 
-  if (SYMBOL_REF_P (x)
-      && !loongarch_symbol_binds_local_p (x))
+  if (!loongarch_symbol_binds_local_p (x))
     return SYMBOL_GOT_DISP;
 
   return SYMBOL_PCREL;
-- 
2.38.1

From c0dbb8cdf979f82cf932600d5971f4e900d58b47 Mon Sep 17 00:00:00 2001
From: Xi Ruoyao <xry111@xry111.site>
Date: Fri, 29 Jul 2022 21:45:40 +0800
Subject: [PATCH 15/36] LoongArch: add model attribute

A linker script and/or a section attribute may locate some object
specially, so we need to handle the code model for such objects
differently than the -mcmodel setting. This happens when the Linux
kernel loads a module with per-CPU variables.

Add an attribute to override the code model for a specific variable.

gcc/ChangeLog:

	* config/loongarch/loongarch-protos.h (loongarch_symbol_type):
	Add SYMBOL_PCREL64 and change the description for SYMBOL_PCREL.
	* config/loongarch/loongarch.cc (loongarch_attribute_table):
	New attribute table.
	(TARGET_ATTRIBUTE_TABLE): Define the target hook.
	(loongarch_handle_model_attribute): New static function.
	(loongarch_classify_symbol): Take TARGET_CMODEL_EXTREME and the
	model attribute of SYMBOL_REF_DECL into account returning
	SYMBOL_PCREL or SYMBOL_PCREL64.
	(loongarch_use_anchors_for_symbol_p): New static function.
	(TARGET_USE_ANCHORS_FOR_SYMBOL_P): Define the target hook.
	(loongarch_symbol_extreme_p): New static function.
	(loongarch_symbolic_constant_p): Handle SYMBOL_PCREL64.
	(loongarch_symbol_insns): Likewise.
	(loongarch_split_symbol_type): Likewise.
	(loongarch_split_symbol): Check SYMBOL_PCREL64 instead of
	TARGET_CMODEL_EXTREME for PC-relative addressing.
	(loongarch_print_operand_reloc): Likewise.
	* doc/extend.texi (Variable Attributes): Document new
	LoongArch specific attribute.

gcc/testsuite/ChangeLog:

	* gcc.target/loongarch/attr-model-test.c: New test.
	* gcc.target/loongarch/attr-model-1.c: New test.
	* gcc.target/loongarch/attr-model-2.c: New test.
	* gcc.target/loongarch/attr-model-diag.c: New test.
---
 gcc/config/loongarch/loongarch-protos.h       |   8 +-
 gcc/config/loongarch/loongarch.cc             | 190 ++++++++++++++++--
 gcc/doc/extend.texi                           |  17 ++
 .../gcc.target/loongarch/attr-model-1.c       |   6 +
 .../gcc.target/loongarch/attr-model-2.c       |   6 +
 .../gcc.target/loongarch/attr-model-diag.c    |   7 +
 .../gcc.target/loongarch/attr-model-test.c    |  25 +++
 7 files changed, 238 insertions(+), 21 deletions(-)
 create mode 100644 gcc/testsuite/gcc.target/loongarch/attr-model-1.c
 create mode 100644 gcc/testsuite/gcc.target/loongarch/attr-model-2.c
 create mode 100644 gcc/testsuite/gcc.target/loongarch/attr-model-diag.c
 create mode 100644 gcc/testsuite/gcc.target/loongarch/attr-model-test.c

diff --git a/gcc/config/loongarch/loongarch-protos.h b/gcc/config/loongarch/loongarch-protos.h
index cadaad7519c..77b2217247d 100644
--- a/gcc/config/loongarch/loongarch-protos.h
+++ b/gcc/config/loongarch/loongarch-protos.h
@@ -28,7 +28,12 @@ along with GCC; see the file COPYING3.  If not see
        The symbol's value will be loaded directly from the GOT.
 
    SYMBOL_PCREL
-       The symbol's value will be loaded directly from data section.
+       The symbol's value will be loaded directly from data section within
+       +/- 2GiB range.
+
+   SYMBOL_PCREL64
+       The symbol's value will be loaded directly from data section within
+       +/- 8EiB range.
 
    SYMBOL_TLS
        A thread-local symbol.
@@ -42,6 +47,7 @@ along with GCC; see the file COPYING3.  If not see
 enum loongarch_symbol_type {
   SYMBOL_GOT_DISP,
   SYMBOL_PCREL,
+  SYMBOL_PCREL64,
   SYMBOL_TLS,
   SYMBOL_TLS_IE,
   SYMBOL_TLS_LE,
diff --git a/gcc/config/loongarch/loongarch.cc b/gcc/config/loongarch/loongarch.cc
index 452aba9d428..77e3a105390 100644
--- a/gcc/config/loongarch/loongarch.cc
+++ b/gcc/config/loongarch/loongarch.cc
@@ -1633,8 +1633,11 @@ loongarch_rtx_constant_in_small_data_p (machine_mode mode)
 static enum loongarch_symbol_type
 loongarch_classify_symbol (const_rtx x)
 {
+  enum loongarch_symbol_type pcrel =
+    TARGET_CMODEL_EXTREME ? SYMBOL_PCREL64 : SYMBOL_PCREL;
+
   if (!SYMBOL_REF_P (x))
-    return SYMBOL_PCREL;
+    return pcrel;
 
   if (SYMBOL_REF_TLS_MODEL (x))
     return SYMBOL_TLS;
@@ -1642,7 +1645,28 @@ loongarch_classify_symbol (const_rtx x)
   if (!loongarch_symbol_binds_local_p (x))
     return SYMBOL_GOT_DISP;
 
-  return SYMBOL_PCREL;
+  tree t = SYMBOL_REF_DECL (x);
+  if (!t)
+    return pcrel;
+
+  t = lookup_attribute ("model", DECL_ATTRIBUTES (t));
+  if (!t)
+    return pcrel;
+
+  t = TREE_VALUE (TREE_VALUE (t));
+
+  /* loongarch_handle_model_attribute should reject other values.  */
+  gcc_assert (TREE_CODE (t) == STRING_CST);
+
+  const char *model = TREE_STRING_POINTER (t);
+  if (strcmp (model, "normal") == 0)
+    return SYMBOL_PCREL;
+  if (strcmp (model, "extreme") == 0)
+    return SYMBOL_PCREL64;
+
+  /* loongarch_handle_model_attribute should reject unknown model
+     name.  */
+  gcc_unreachable ();
 }
 
 /* Classify the base of symbolic expression X, given that X appears in
@@ -1695,6 +1719,7 @@ loongarch_symbolic_constant_p (rtx x, enum loongarch_symbol_type *symbol_type)
     case SYMBOL_TLSGD:
     case SYMBOL_TLSLDM:
     case SYMBOL_PCREL:
+    case SYMBOL_PCREL64:
       /* GAS rejects offsets outside the range [-2^31, 2^31-1].  */
       return sext_hwi (INTVAL (offset), 32) == INTVAL (offset);
 
@@ -1729,6 +1754,9 @@ loongarch_symbol_insns (enum loongarch_symbol_type type, machine_mode mode)
     case SYMBOL_TLSLDM:
       return 3;
 
+    case SYMBOL_PCREL64:
+      return 5;
+
     case SYMBOL_TLS:
       /* We don't treat a bare TLS symbol as a constant.  */
       return 0;
@@ -1833,7 +1861,7 @@ loongarch_valid_offset_p (rtx x, machine_mode mode)
   return true;
 }
 
-/* Should a symbol of type SYMBOL_TYPE should be split in two?  */
+/* Should a symbol of type SYMBOL_TYPE should be split in two or more?  */
 
 bool
 loongarch_split_symbol_type (enum loongarch_symbol_type symbol_type)
@@ -1841,6 +1869,7 @@ loongarch_split_symbol_type (enum loongarch_symbol_type symbol_type)
   switch (symbol_type)
     {
     case SYMBOL_PCREL:
+    case SYMBOL_PCREL64:
     case SYMBOL_GOT_DISP:
     case SYMBOL_TLS_IE:
     case SYMBOL_TLS_LE:
@@ -2718,6 +2747,20 @@ loongarch_force_address (rtx x, machine_mode mode)
   return x;
 }
 
+static bool
+loongarch_symbol_extreme_p (enum loongarch_symbol_type type)
+{
+  switch (type)
+    {
+      case SYMBOL_PCREL:
+	return false;
+      case SYMBOL_PCREL64:
+	return true;
+      default:
+	return TARGET_CMODEL_EXTREME;
+    }
+}
+
 /* If MODE is MAX_MACHINE_MODE, ADDR appears as a move operand, otherwise
    it appears in a MEM of that mode.  Return true if ADDR is a legitimate
    constant in that context and can be split into high and low parts.
@@ -2757,7 +2800,7 @@ loongarch_split_symbol (rtx temp, rtx addr, machine_mode mode, rtx *low_out)
   high = gen_rtx_HIGH (Pmode, copy_rtx (addr));
   high = loongarch_force_temporary (temp, high);
 
-  if (TARGET_CMODEL_EXTREME && can_create_pseudo_p ())
+  if (loongarch_symbol_extreme_p (symbol_type) && can_create_pseudo_p ())
     {
       gcc_assert (TARGET_EXPLICIT_RELOCS);
 
@@ -2771,14 +2814,16 @@ loongarch_split_symbol (rtx temp, rtx addr, machine_mode mode, rtx *low_out)
   if (low_out)
     switch (symbol_type)
       {
-      case SYMBOL_PCREL:
-	{
-	  if (TARGET_CMODEL_EXTREME && can_create_pseudo_p ())
+      case SYMBOL_PCREL64:
+	if (can_create_pseudo_p ())
+	  {
 	    *low_out = gen_rtx_PLUS (Pmode, high, temp1);
-	  else
-	    *low_out = gen_rtx_LO_SUM (Pmode, high, addr);
-	  break;
-	}
+	    break;
+	  }
+	/* fall through */
+      case SYMBOL_PCREL:
+	*low_out = gen_rtx_LO_SUM (Pmode, high, addr);
+	break;
 
       case SYMBOL_GOT_DISP:
 	/* SYMBOL_GOT_DISP symbols are loaded from the GOT.  */
@@ -4745,22 +4790,23 @@ loongarch_print_operand_reloc (FILE *file, rtx op, bool hi64_part,
 			       bool hi_reloc)
 {
   const char *reloc;
+  enum loongarch_symbol_type symbol_type =
+    loongarch_classify_symbolic_expression (op);
 
-  if (TARGET_CMODEL_EXTREME)
+  if (loongarch_symbol_extreme_p (symbol_type))
     gcc_assert (TARGET_EXPLICIT_RELOCS);
 
-  switch (loongarch_classify_symbolic_expression (op))
+  switch (symbol_type)
     {
-    case SYMBOL_PCREL:
+    case SYMBOL_PCREL64:
       if (hi64_part)
 	{
-	  if (TARGET_CMODEL_EXTREME)
-	    reloc = hi_reloc ? "%pc64_hi12" : "%pc64_lo20";
-	  else
-	    gcc_unreachable ();
+	  reloc = hi_reloc ? "%pc64_hi12" : "%pc64_lo20";
+	  break;
 	}
-      else
-	reloc = hi_reloc ? "%pc_hi20" : "%pc_lo12";
+      /* fall through */
+    case SYMBOL_PCREL:
+      reloc = hi_reloc ? "%pc_hi20" : "%pc_lo12";
       break;
 
     case SYMBOL_GOT_DISP:
@@ -6316,6 +6362,104 @@ loongarch_starting_frame_offset (void)
   return crtl->outgoing_args_size;
 }
 
+static tree
+loongarch_handle_model_attribute (tree *node, tree name, tree arg, int,
+				  bool *no_add_attrs)
+{
+  tree decl = *node;
+  if (TREE_CODE (decl) == VAR_DECL)
+    {
+      if (DECL_THREAD_LOCAL_P (decl))
+	{
+	  error_at (DECL_SOURCE_LOCATION (decl),
+		    "%qE attribute cannot be specified for thread-local "
+		    "variables", name);
+	  *no_add_attrs = true;
+	  return NULL_TREE;
+	}
+      if (DECL_CONTEXT (decl)
+	  && TREE_CODE (DECL_CONTEXT (decl)) == FUNCTION_DECL
+	  && !TREE_STATIC (decl))
+	{
+	  error_at (DECL_SOURCE_LOCATION (decl),
+		    "%qE attribute cannot be specified for local "
+		    "variables", name);
+	  *no_add_attrs = true;
+	  return NULL_TREE;
+	}
+      if (DECL_REGISTER (decl))
+	{
+	  error_at (DECL_SOURCE_LOCATION (decl),
+		    "%qE attribute cannot be specified for register "
+		    "variables", name);
+	  *no_add_attrs = true;
+	  return NULL_TREE;
+	}
+      if (!TARGET_EXPLICIT_RELOCS)
+	{
+	  error_at (DECL_SOURCE_LOCATION (decl),
+		    "%qE attribute requires %s", name, "-mexplicit-relocs");
+	  *no_add_attrs = true;
+	  return NULL_TREE;
+	}
+
+      arg = TREE_VALUE (arg);
+      if (TREE_CODE (arg) != STRING_CST)
+	{
+	  error_at (DECL_SOURCE_LOCATION (decl),
+		    "invalid argument of %qE attribute", name);
+	  *no_add_attrs = true;
+	  return NULL_TREE;
+	}
+
+      const char *model = TREE_STRING_POINTER (arg);
+      if (strcmp (model, "normal") != 0
+	  && strcmp (model, "extreme") != 0)
+	{
+	  error_at (DECL_SOURCE_LOCATION (decl),
+		    "invalid argument of %qE attribute", name);
+	  *no_add_attrs = true;
+	  return NULL_TREE;
+	}
+
+      if (lookup_attribute ("model", DECL_ATTRIBUTES (decl)))
+	{
+	  error_at (DECL_SOURCE_LOCATION (decl),
+		    "multiple %qE attribute", name);
+	  *no_add_attrs = true;
+	  return NULL_TREE;
+	}
+    }
+  else
+    {
+      warning (OPT_Wattributes, "%qE attribute ignored", name);
+      *no_add_attrs = true;
+    }
+  return NULL_TREE;
+}
+
+static const struct attribute_spec loongarch_attribute_table[] =
+{
+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req,
+       affects_type_identity, handler, exclude } */
+  { "model", 1, 1, true, false, false, false,
+    loongarch_handle_model_attribute, NULL },
+  /* The last attribute spec is set to be NULL.  */
+  {}
+};
+
+bool
+loongarch_use_anchors_for_symbol_p (const_rtx symbol)
+{
+  tree decl = SYMBOL_REF_DECL (symbol);
+
+  /* The section anchor optimization may break custom address model.  */
+  if (decl && lookup_attribute ("model", DECL_ATTRIBUTES (decl)))
+    return false;
+
+  return default_use_anchors_for_symbol_p (symbol);
+}
+
 /* Initialize the GCC target structure.  */
 #undef TARGET_ASM_ALIGNED_HI_OP
 #define TARGET_ASM_ALIGNED_HI_OP "\t.half\t"
@@ -6504,6 +6648,12 @@ loongarch_starting_frame_offset (void)
 #undef  TARGET_HAVE_SPECULATION_SAFE_VALUE
 #define TARGET_HAVE_SPECULATION_SAFE_VALUE speculation_safe_value_not_needed
 
+#undef  TARGET_ATTRIBUTE_TABLE
+#define TARGET_ATTRIBUTE_TABLE loongarch_attribute_table
+
+#undef  TARGET_USE_ANCHORS_FOR_SYMBOL_P
+#define TARGET_USE_ANCHORS_FOR_SYMBOL_P loongarch_use_anchors_for_symbol_p
+
 struct gcc_target targetm = TARGET_INITIALIZER;
 
 #include "gt-loongarch.h"
diff --git a/gcc/doc/extend.texi b/gcc/doc/extend.texi
index 84e6f6694ab..e77091607a1 100644
--- a/gcc/doc/extend.texi
+++ b/gcc/doc/extend.texi
@@ -7277,6 +7277,7 @@ attributes.
 * Blackfin Variable Attributes::
 * H8/300 Variable Attributes::
 * IA-64 Variable Attributes::
+* LoongArch Variable Attributes::
 * M32R/D Variable Attributes::
 * MeP Variable Attributes::
 * Microsoft Windows Variable Attributes::
@@ -8061,6 +8062,22 @@ defined by shared libraries.
 
 @end table
 
+@node LoongArch Variable Attributes
+@subsection LoongArch Variable Attributes
+
+One attribute is currently defined for the LoongArch.
+
+@table @code
+@item model("@var{name}")
+@cindex @code{model} variable attribute, LoongArch
+Use this attribute on the LoongArch to use a different code model for
+addressing this variable, than the code model specified by the global
+@option{-mcmodel} option.  This attribute is mostly useful if a
+@code{section} attribute and/or a linker script will locate this object
+specially.  Currently the only supported values of @var{name} are
+@code{normal} and @code{extreme}.
+@end table
+
 @node M32R/D Variable Attributes
 @subsection M32R/D Variable Attributes
 
diff --git a/gcc/testsuite/gcc.target/loongarch/attr-model-1.c b/gcc/testsuite/gcc.target/loongarch/attr-model-1.c
new file mode 100644
index 00000000000..916d715b98b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/attr-model-1.c
@@ -0,0 +1,6 @@
+/* { dg-do compile } */
+/* { dg-options "-mexplicit-relocs -mcmodel=normal -O2" } */
+/* { dg-final { scan-assembler-times "%pc64_hi12" 2 } } */
+
+#define ATTR_MODEL_TEST
+#include "attr-model-test.c"
diff --git a/gcc/testsuite/gcc.target/loongarch/attr-model-2.c b/gcc/testsuite/gcc.target/loongarch/attr-model-2.c
new file mode 100644
index 00000000000..a74c795ac3e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/attr-model-2.c
@@ -0,0 +1,6 @@
+/* { dg-do compile } */
+/* { dg-options "-mexplicit-relocs -mcmodel=extreme -O2" } */
+/* { dg-final { scan-assembler-times "%pc64_hi12" 3 } } */
+
+#define ATTR_MODEL_TEST
+#include "attr-model-test.c"
diff --git a/gcc/testsuite/gcc.target/loongarch/attr-model-diag.c b/gcc/testsuite/gcc.target/loongarch/attr-model-diag.c
new file mode 100644
index 00000000000..88beede74df
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/attr-model-diag.c
@@ -0,0 +1,7 @@
+/* { dg-do compile } */
+/* { dg-options "-mexplicit-relocs" } */
+
+__thread int x __attribute__((model("extreme"))); /* { dg-error "attribute cannot be specified for thread-local variables" } */
+register int y __asm__("tp") __attribute__((model("extreme"))); /* { dg-error "attribute cannot be specified for register variables" } */
+int z __attribute__((model(114))); /* { dg-error "invalid argument" } */
+int t __attribute__((model("good"))); /* { dg-error "invalid argument" } */
diff --git a/gcc/testsuite/gcc.target/loongarch/attr-model-test.c b/gcc/testsuite/gcc.target/loongarch/attr-model-test.c
new file mode 100644
index 00000000000..5b61a7af9c3
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/attr-model-test.c
@@ -0,0 +1,25 @@
+#ifdef ATTR_MODEL_TEST
+int x __attribute__((model("extreme")));
+int y __attribute__((model("normal")));
+int z;
+
+int
+test(void)
+{
+  return x + y + z;
+}
+
+/* The following will be used for kernel per-cpu storage implemention. */
+
+register char *per_cpu_base __asm__("r21");
+static int counter __attribute__((section(".data..percpu"), model("extreme")));
+
+void
+inc_counter(void)
+{
+  int *ptr = (int *)(per_cpu_base + (long)&counter);
+  (*ptr)++;
+}
+#endif
+
+int dummy;
-- 
2.38.1

From 14a44a23c47c644d4b4f74022d00515599cf863e Mon Sep 17 00:00:00 2001
From: Xi Ruoyao <xry111@xry111.site>
Date: Wed, 24 Aug 2022 19:34:47 +0800
Subject: [PATCH 16/36] LoongArch: testsuite: refine __tls_get_addr tests with
 tls_native

If GCC is not built with a working linker for the target (developers
occansionally build such a "minimal" GCC for testing and debugging),
TLS will be emulated and __tls_get_addr won't be used.  Refine those
tests depending on __tls_get_addr with tls_native to avoid test
failures.

gcc/testsuite/ChangeLog:

	* gcc.target/loongarch/func-call-medium-1.c: Refine test
	depending on __tls_get_addr with { target tls_native }.
	* gcc.target/loongarch/func-call-medium-2.c: Likewise.
	* gcc.target/loongarch/func-call-medium-3.c: Likewise.
	* gcc.target/loongarch/func-call-medium-4.c: Likewise.
	* gcc.target/loongarch/func-call-medium-5.c: Likewise.
	* gcc.target/loongarch/func-call-medium-6.c: Likewise.
	* gcc.target/loongarch/func-call-medium-7.c: Likewise.
	* gcc.target/loongarch/func-call-medium-8.c: Likewise.
	* gcc.target/loongarch/tls-gd-noplt.c: Likewise.
---
 gcc/testsuite/gcc.target/loongarch/func-call-medium-1.c | 2 +-
 gcc/testsuite/gcc.target/loongarch/func-call-medium-2.c | 2 +-
 gcc/testsuite/gcc.target/loongarch/func-call-medium-3.c | 2 +-
 gcc/testsuite/gcc.target/loongarch/func-call-medium-4.c | 2 +-
 gcc/testsuite/gcc.target/loongarch/func-call-medium-5.c | 2 +-
 gcc/testsuite/gcc.target/loongarch/func-call-medium-6.c | 2 +-
 gcc/testsuite/gcc.target/loongarch/func-call-medium-7.c | 2 +-
 gcc/testsuite/gcc.target/loongarch/func-call-medium-8.c | 3 ++-
 gcc/testsuite/gcc.target/loongarch/tls-gd-noplt.c       | 2 +-
 9 files changed, 10 insertions(+), 9 deletions(-)

diff --git a/gcc/testsuite/gcc.target/loongarch/func-call-medium-1.c b/gcc/testsuite/gcc.target/loongarch/func-call-medium-1.c
index 276d73e5ee8..6339e832fe5 100644
--- a/gcc/testsuite/gcc.target/loongarch/func-call-medium-1.c
+++ b/gcc/testsuite/gcc.target/loongarch/func-call-medium-1.c
@@ -3,7 +3,7 @@
 /* { dg-final { scan-assembler "test:.*la\.global\t.*g\n\tjirl" } } */
 /* { dg-final { scan-assembler "test1:.*la\.global\t.*f\n\tjirl" } } */
 /* { dg-final { scan-assembler "test2:.*la\.local\t.*l\n\tjirl" } } */
-/* { dg-final { scan-assembler "test3:.*la\.global\t.*\_\_tls\_get\_addr" } } */
+/* { dg-final { scan-assembler "test3:.*la\.global\t.*\_\_tls\_get\_addr" { target tls_native } } } */
 
 extern void g (void);
 void
diff --git a/gcc/testsuite/gcc.target/loongarch/func-call-medium-2.c b/gcc/testsuite/gcc.target/loongarch/func-call-medium-2.c
index 237821c066b..a53e75e0bf9 100644
--- a/gcc/testsuite/gcc.target/loongarch/func-call-medium-2.c
+++ b/gcc/testsuite/gcc.target/loongarch/func-call-medium-2.c
@@ -3,7 +3,7 @@
 /* { dg-final { scan-assembler "test:.*la\.global\t.*g\n\tjirl" } } */
 /* { dg-final { scan-assembler "test1:.*la\.local\t.*f\n\tjirl" } } */
 /* { dg-final { scan-assembler "test2:.*la\.local\t.*l\n\tjirl" } } */
-/* { dg-final { scan-assembler "test3:.*la\.global\t.*\_\_tls\_get\_addr" } } */
+/* { dg-final { scan-assembler "test3:.*la\.global\t.*\_\_tls\_get\_addr" { target tls_native } } } */
 
 extern void g (void);
 void
diff --git a/gcc/testsuite/gcc.target/loongarch/func-call-medium-3.c b/gcc/testsuite/gcc.target/loongarch/func-call-medium-3.c
index 9a6e16103bc..0da7bf98e3c 100644
--- a/gcc/testsuite/gcc.target/loongarch/func-call-medium-3.c
+++ b/gcc/testsuite/gcc.target/loongarch/func-call-medium-3.c
@@ -3,7 +3,7 @@
 /* { dg-final { scan-assembler "test:.*la\.global\t.*g\n\tjirl" } } */
 /* { dg-final { scan-assembler "test1:.*la\.global\t.*f\n\tjirl" } } */
 /* { dg-final { scan-assembler "test2:.*la\.local\t.*l\n\tjirl" } } */
-/* { dg-final { scan-assembler "test3:.*la\.global\t.*\_\_tls\_get\_addr" } } */
+/* { dg-final { scan-assembler "test3:.*la\.global\t.*\_\_tls\_get\_addr" { target tls_native } } } */
 
 extern void g (void);
 void
diff --git a/gcc/testsuite/gcc.target/loongarch/func-call-medium-4.c b/gcc/testsuite/gcc.target/loongarch/func-call-medium-4.c
index 2577e345239..0219688ae80 100644
--- a/gcc/testsuite/gcc.target/loongarch/func-call-medium-4.c
+++ b/gcc/testsuite/gcc.target/loongarch/func-call-medium-4.c
@@ -3,7 +3,7 @@
 /* { dg-final { scan-assembler "test:.*la\.global\t.*g\n\tjirl" } } */
 /* { dg-final { scan-assembler "test1:.*la\.local\t.*f\n\tjirl" } } */
 /* { dg-final { scan-assembler "test2:.*la\.local\t.*l\n\tjirl" } } */
-/* { dg-final { scan-assembler "test3:.*la\.global\t.*\_\_tls\_get\_addr" } } */
+/* { dg-final { scan-assembler "test3:.*la\.global\t.*\_\_tls\_get\_addr" { target tls_native } } } */
 
 extern void g (void);
 void
diff --git a/gcc/testsuite/gcc.target/loongarch/func-call-medium-5.c b/gcc/testsuite/gcc.target/loongarch/func-call-medium-5.c
index d70b6ea4663..8a47b5afcba 100644
--- a/gcc/testsuite/gcc.target/loongarch/func-call-medium-5.c
+++ b/gcc/testsuite/gcc.target/loongarch/func-call-medium-5.c
@@ -3,7 +3,7 @@
 /* { dg-final { scan-assembler "test:.*pcalau12i.*%pc_hi20\\(g\\)\n\tjirl.*pc_lo12\\(g\\)" } } */
 /* { dg-final { scan-assembler "test1:.*pcalau12i.*%pc_hi20\\(f\\)\n\tjirl.*%pc_lo12\\(f\\)" } } */
 /* { dg-final { scan-assembler "test2:.*pcalau12i.*%pc_hi20\\(l\\)\n\tjirl.*%pc_lo12\\(l\\)" } } */
-/* { dg-final { scan-assembler "test3:.*pcalau12i.*%pc_hi20\\(__tls_get_addr\\)\n\t.*\n\tjirl.*%pc_lo12\\(__tls_get_addr\\)" } } */
+/* { dg-final { scan-assembler "test3:.*pcalau12i.*%pc_hi20\\(__tls_get_addr\\)\n\t.*\n\tjirl.*%pc_lo12\\(__tls_get_addr\\)" { target tls_native } } } */
 
 extern void g (void);
 
diff --git a/gcc/testsuite/gcc.target/loongarch/func-call-medium-6.c b/gcc/testsuite/gcc.target/loongarch/func-call-medium-6.c
index f963a99441a..1e75e60e01a 100644
--- a/gcc/testsuite/gcc.target/loongarch/func-call-medium-6.c
+++ b/gcc/testsuite/gcc.target/loongarch/func-call-medium-6.c
@@ -3,7 +3,7 @@
 /* { dg-final { scan-assembler "test:.*pcalau12i.*%pc_hi20\\(g\\)\n\tjirl.*pc_lo12\\(g\\)" } } */
 /* { dg-final { scan-assembler "test1:.*pcalau12i.*%pc_hi20\\(f\\)\n\tjirl.*%pc_lo12\\(f\\)" } } */
 /* { dg-final { scan-assembler "test2:.*pcalau12i.*%pc_hi20\\(l\\)\n\tjirl.*%pc_lo12\\(l\\)" } } */
-/* { dg-final { scan-assembler "test3:.*pcalau12i.*%pc_hi20\\(__tls_get_addr\\)\n\t.*\n\tjirl.*%pc_lo12\\(__tls_get_addr\\)" } } */
+/* { dg-final { scan-assembler "test3:.*pcalau12i.*%pc_hi20\\(__tls_get_addr\\)\n\t.*\n\tjirl.*%pc_lo12\\(__tls_get_addr\\)" { target tls_native } } } */
 
 extern void g (void);
 
diff --git a/gcc/testsuite/gcc.target/loongarch/func-call-medium-7.c b/gcc/testsuite/gcc.target/loongarch/func-call-medium-7.c
index f2818b2da76..9e89085ca19 100644
--- a/gcc/testsuite/gcc.target/loongarch/func-call-medium-7.c
+++ b/gcc/testsuite/gcc.target/loongarch/func-call-medium-7.c
@@ -3,7 +3,7 @@
 /* { dg-final { scan-assembler "test:.*pcalau12i\t.*%got_pc_hi20\\(g\\)\n\tld\.d\t.*%got_pc_lo12\\(g\\)\n\tjirl" } } */
 /* { dg-final { scan-assembler "test1:.*pcalau12i\t.*%got_pc_hi20\\(f\\)\n\tld\.d\t.*%got_pc_lo12\\(f\\)\n\tjirl" } } */
 /* { dg-final { scan-assembler "test2:.*pcalau12i\t.*%pc_hi20\\(l\\)\n\tjirl.*%pc_lo12\\(l\\)" } } */
-/* { dg-final { scan-assembler "test3:.*pcalau12i.*%got_pc_hi20\\(__tls_get_addr\\)\n\tld\.d.*%got_pc_lo12\\(__tls_get_addr\\)" } } */
+/* { dg-final { scan-assembler "test3:.*pcalau12i.*%got_pc_hi20\\(__tls_get_addr\\)\n\tld\.d.*%got_pc_lo12\\(__tls_get_addr\\)" { target tls_native } } } */
 
 
 extern void g (void);
diff --git a/gcc/testsuite/gcc.target/loongarch/func-call-medium-8.c b/gcc/testsuite/gcc.target/loongarch/func-call-medium-8.c
index 7fa873d84bb..fde9c6e0ef4 100644
--- a/gcc/testsuite/gcc.target/loongarch/func-call-medium-8.c
+++ b/gcc/testsuite/gcc.target/loongarch/func-call-medium-8.c
@@ -3,7 +3,8 @@
 /* { dg-final { scan-assembler "test:.*pcalau12i\t.*%got_pc_hi20\\(g\\)\n\tld\.d\t.*%got_pc_lo12\\(g\\)\n\tjirl" } } */
 /* { dg-final { scan-assembler "test1:.*pcalau12i\t.*%pc_hi20\\(f\\)\n\tjirl.*%pc_lo12\\(f\\)" } } */
 /* { dg-final { scan-assembler "test2:.*pcalau12i\t.*%pc_hi20\\(l\\)\n\tjirl.*%pc_lo12\\(l\\)" } } */
-/* { dg-final { scan-assembler "test3:.*pcalau12i.*%got_pc_hi20\\(__tls_get_addr\\)\n\tld\.d.*%got_pc_lo12\\(__tls_get_addr\\)" } } */
+/* { dg-final { scan-assembler "test3:.*pcalau12i.*%got_pc_hi20\\(__tls_get_addr\\)\n\tld\.d.*%got_pc_lo12\\(__tls_get_addr\\)" { target tls_native } } } */
+/* { dg-final { scan-assembler "test3:.*pcalau12i.*%got_pc_hi20\\(__tls_get_addr\\)\n\tld\.d.*%got_pc_lo12\\(__tls_get_addr\\)" { target tls_native } } } */
 
 extern void g (void);
 
diff --git a/gcc/testsuite/gcc.target/loongarch/tls-gd-noplt.c b/gcc/testsuite/gcc.target/loongarch/tls-gd-noplt.c
index 375663286f0..9432c477e9d 100644
--- a/gcc/testsuite/gcc.target/loongarch/tls-gd-noplt.c
+++ b/gcc/testsuite/gcc.target/loongarch/tls-gd-noplt.c
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O0 -fno-plt -mcmodel=normal -mexplicit-relocs" } */
-/* { dg-final { scan-assembler "pcalau12i\t.*%got_pc_hi20\\(__tls_get_addr\\)\n\tld\.d.*%got_pc_lo12\\(__tls_get_addr\\)" } } */
+/* { dg-final { scan-assembler "pcalau12i\t.*%got_pc_hi20\\(__tls_get_addr\\)\n\tld\.d.*%got_pc_lo12\\(__tls_get_addr\\)" { target tls_native } } } */
 
 __attribute__ ((tls_model ("global-dynamic"))) __thread int a;
 
-- 
2.38.1

From 8769475527862e4a37f4f2f7d79afd75c16fc50e Mon Sep 17 00:00:00 2001
From: Xi Ruoyao <xry111@xry111.site>
Date: Thu, 1 Sep 2022 18:38:14 +0800
Subject: [PATCH 18/36] LoongArch: add -mdirect-extern-access option

As a new target, LoongArch does not use copy relocation as it's
problematic in some circumstances.  One bad consequence is we are
emitting GOT for all accesses to all extern objects with default
visibility.  The use of GOT is not needed in statically linked
executables, OS kernels etc.  The GOT entry just wastes space, and the
GOT access just slow down the execution in those environments.

Before -mexplicit-relocs, we used "-Wa,-mla-global-with-pcrel" to tell
the assembler not to use GOT for extern access.  But with
-mexplicit-relocs, we have to opt the logic in GCC.

The name "-mdirect-extern-access" is learnt from x86 port.

gcc/ChangeLog:

	* config/loongarch/genopts/loongarch.opt.in: Add
	-mdirect-extern-access option.
	* config/loongarch/loongarch.opt: Regenerate.
	* config/loongarch/loongarch.cc
	(loongarch_symbol_binds_local_p): Return true if
	TARGET_DIRECT_EXTERN_ACCESS.
	(loongarch_option_override_internal): Complain if
	-mdirect-extern-access is used with -fPIC or -fpic.
	* doc/invoke.texi: Document -mdirect-extern-access for
	LoongArch.

gcc/testsuite/ChangeLog:

	* gcc.target/loongarch/direct-extern-1.c: New test.
	* gcc.target/loongarch/direct-extern-2.c: New test.
---
 gcc/config/loongarch/genopts/loongarch.opt.in     |  4 ++++
 gcc/config/loongarch/loongarch.cc                 |  6 ++++++
 gcc/config/loongarch/loongarch.opt                |  4 ++++
 gcc/doc/invoke.texi                               | 15 +++++++++++++++
 .../gcc.target/loongarch/direct-extern-1.c        |  6 ++++++
 .../gcc.target/loongarch/direct-extern-2.c        |  6 ++++++
 6 files changed, 41 insertions(+)
 create mode 100644 gcc/testsuite/gcc.target/loongarch/direct-extern-1.c
 create mode 100644 gcc/testsuite/gcc.target/loongarch/direct-extern-2.c

diff --git a/gcc/config/loongarch/genopts/loongarch.opt.in b/gcc/config/loongarch/genopts/loongarch.opt.in
index ebdd9538d48..e10618777b2 100644
--- a/gcc/config/loongarch/genopts/loongarch.opt.in
+++ b/gcc/config/loongarch/genopts/loongarch.opt.in
@@ -184,3 +184,7 @@ Enum(cmodel) String(@@STR_CMODEL_EXTREME@@) Value(CMODEL_EXTREME)
 mcmodel=
 Target RejectNegative Joined Enum(cmodel) Var(la_opt_cmodel) Init(CMODEL_NORMAL)
 Specify the code model.
+
+mdirect-extern-access
+Target Var(TARGET_DIRECT_EXTERN_ACCESS) Init(0)
+Avoid using the GOT to access external symbols.
diff --git a/gcc/config/loongarch/loongarch.cc b/gcc/config/loongarch/loongarch.cc
index 77e3a105390..c9187bf81a7 100644
--- a/gcc/config/loongarch/loongarch.cc
+++ b/gcc/config/loongarch/loongarch.cc
@@ -1610,6 +1610,9 @@ loongarch_weak_symbol_p (const_rtx x)
 bool
 loongarch_symbol_binds_local_p (const_rtx x)
 {
+  if (TARGET_DIRECT_EXTERN_ACCESS)
+    return true;
+
   if (SYMBOL_REF_P (x))
     return (SYMBOL_REF_DECL (x)
 	    ? targetm.binds_local_p (SYMBOL_REF_DECL (x))
@@ -6093,6 +6096,9 @@ loongarch_option_override_internal (struct gcc_options *opts)
   if (loongarch_branch_cost == 0)
     loongarch_branch_cost = loongarch_cost->branch_cost;
 
+  if (TARGET_DIRECT_EXTERN_ACCESS && flag_shlib)
+    error ("%qs cannot be used for compiling a shared library",
+	   "-mdirect-extern-access");
 
   switch (la_target.cmodel)
     {
diff --git a/gcc/config/loongarch/loongarch.opt b/gcc/config/loongarch/loongarch.opt
index 6395234218b..96c811c850b 100644
--- a/gcc/config/loongarch/loongarch.opt
+++ b/gcc/config/loongarch/loongarch.opt
@@ -191,3 +191,7 @@ Enum(cmodel) String(extreme) Value(CMODEL_EXTREME)
 mcmodel=
 Target RejectNegative Joined Enum(cmodel) Var(la_opt_cmodel) Init(CMODEL_NORMAL)
 Specify the code model.
+
+mdirect-extern-access
+Target Var(TARGET_DIRECT_EXTERN_ACCESS) Init(0)
+Avoid using the GOT to access external symbols.
diff --git a/gcc/doc/invoke.texi b/gcc/doc/invoke.texi
index c0a084f6036..0b443a5e48c 100644
--- a/gcc/doc/invoke.texi
+++ b/gcc/doc/invoke.texi
@@ -1005,6 +1005,7 @@ Objective-C and Objective-C++ Dialects}.
 -memcpy  -mno-memcpy -mstrict-align -mno-strict-align @gol
 -mmax-inline-memcpy-size=@var{n} @gol
 -mexplicit-relocs -mno-explicit-relocs @gol
+-mdirect-extern-access -mno-direct-extern-access @gol
 -mcmodel=@var{code-model}}
 
 @emph{M32R/D Options}
@@ -24604,6 +24605,20 @@ GCC build-time by detecting corresponding assembler support:
 @code{-mno-explicit-relocs} otherwise.  This option is mostly useful for
 debugging, or interoperation with assemblers different from the build-time
 one.
+
+@item -mdirect-extern-access
+@itemx -mno-direct-extern-access
+@opindex mdirect-extern-access
+Do not use or use GOT to access external symbols.  The default is
+@option{-mno-direct-extern-access}: GOT is used for external symbols with
+default visibility, but not used for other external symbols.
+
+With @option{-mdirect-extern-access}, GOT is not used and all external
+symbols are PC-relatively addressed.  It is @strong{only} suitable for
+environments where no dynamic link is performed, like firmwares, OS
+kernels, executables linked with @option{-static} or @option{-static-pie}.
+@option{-mdirect-extern-access} is not compatible with @option{-fPIC} or
+@option{-fpic}.
 @end table
 
 @node M32C Options
diff --git a/gcc/testsuite/gcc.target/loongarch/direct-extern-1.c b/gcc/testsuite/gcc.target/loongarch/direct-extern-1.c
new file mode 100644
index 00000000000..85c6c1e8a88
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/direct-extern-1.c
@@ -0,0 +1,6 @@
+/* { dg-do compile } */
+/* { dg-options "-mexplicit-relocs -mdirect-extern-access" } */
+/* { dg-final { scan-assembler-not "got" } } */
+
+extern int x;
+int f() { return x; }
diff --git a/gcc/testsuite/gcc.target/loongarch/direct-extern-2.c b/gcc/testsuite/gcc.target/loongarch/direct-extern-2.c
new file mode 100644
index 00000000000..58d8bd68a06
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/direct-extern-2.c
@@ -0,0 +1,6 @@
+/* { dg-do compile } */
+/* { dg-options "-mno-explicit-relocs -mdirect-extern-access" } */
+/* { dg-final { scan-assembler-not "la.global" } } */
+
+extern int x;
+int f() { return x; }
-- 
2.38.1

From c5698ac0bc7f5cd07236e5099c436b3920a6bc4a Mon Sep 17 00:00:00 2001
From: Lulu Cheng <chenglulu@loongson.cn>
Date: Wed, 7 Sep 2022 11:25:45 +0800
Subject: [PATCH 19/36] LoongArch: Fix pr106828 by define hook
 TARGET_ASAN_SHADOW_OFFSET in loongarch backend [PR106828].

gcc/ChangeLog:

	PR target/106828
	* config/loongarch/loongarch.cc (loongarch_asan_shadow_offset): New.
	(TARGET_ASAN_SHADOW_OFFSET): New.

gcc/testsuite/ChangeLog:

	PR target/106828
	* g++.target/loongarch/pr106828.C: New test.
---
 gcc/config/loongarch/loongarch.cc             | 13 +++++++++++++
 gcc/testsuite/g++.target/loongarch/pr106828.C |  4 ++++
 2 files changed, 17 insertions(+)
 create mode 100644 gcc/testsuite/g++.target/loongarch/pr106828.C

diff --git a/gcc/config/loongarch/loongarch.cc b/gcc/config/loongarch/loongarch.cc
index c9187bf81a7..98c0e26cdb9 100644
--- a/gcc/config/loongarch/loongarch.cc
+++ b/gcc/config/loongarch/loongarch.cc
@@ -6466,6 +6466,16 @@ loongarch_use_anchors_for_symbol_p (const_rtx symbol)
   return default_use_anchors_for_symbol_p (symbol);
 }
 
+/* Implement the TARGET_ASAN_SHADOW_OFFSET hook.  */
+
+static unsigned HOST_WIDE_INT
+loongarch_asan_shadow_offset (void)
+{
+  /* We only have libsanitizer support for LOONGARCH64 at present.
+     This value is taken from the file libsanitizer/asan/asan_mappint.h.  */
+  return TARGET_64BIT ? (HOST_WIDE_INT_1 << 46) : 0;
+}
+
 /* Initialize the GCC target structure.  */
 #undef TARGET_ASM_ALIGNED_HI_OP
 #define TARGET_ASM_ALIGNED_HI_OP "\t.half\t"
@@ -6660,6 +6670,9 @@ loongarch_use_anchors_for_symbol_p (const_rtx symbol)
 #undef  TARGET_USE_ANCHORS_FOR_SYMBOL_P
 #define TARGET_USE_ANCHORS_FOR_SYMBOL_P loongarch_use_anchors_for_symbol_p
 
+#undef TARGET_ASAN_SHADOW_OFFSET
+#define TARGET_ASAN_SHADOW_OFFSET loongarch_asan_shadow_offset
+
 struct gcc_target targetm = TARGET_INITIALIZER;
 
 #include "gt-loongarch.h"
diff --git a/gcc/testsuite/g++.target/loongarch/pr106828.C b/gcc/testsuite/g++.target/loongarch/pr106828.C
new file mode 100644
index 00000000000..190c1db715f
--- /dev/null
+++ b/gcc/testsuite/g++.target/loongarch/pr106828.C
@@ -0,0 +1,4 @@
+/* { dg-do-preprocess } */
+/* { dg-options "-mabi=lp64d -fsanitize=address" } */
+
+/* Tests whether the compiler supports compile option '-fsanitize=address'.  */
-- 
2.38.1

From 136844cb9b80fcf44c9a5535f2eb73020196882c Mon Sep 17 00:00:00 2001
From: Xi Ruoyao <xry111@xry111.site>
Date: Tue, 13 Sep 2022 23:21:39 +0800
Subject: [PATCH 20/36] LoongArch: Prepare static PIE support

Static PIE allows us to extend the ASLR to cover static executables and
it's not too difficult to support it.  On GCC side, we just pass a group
of options to the linker, like other ports with static PIE support.

The real implementation of static PIE (rcrt1.o) will be added into Glibc
later.

gcc/ChangeLog:

	* config/loongarch/gnu-user.h (GNU_USER_TARGET_LINK_SPEC): For
	-static-pie, pass -static -pie --no-dynamic-linker -z text to
	the linker, and do not pass --dynamic-linker.
---
 gcc/config/loongarch/gnu-user.h | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/gcc/config/loongarch/gnu-user.h b/gcc/config/loongarch/gnu-user.h
index 664dc9206ad..c5b1afe530d 100644
--- a/gcc/config/loongarch/gnu-user.h
+++ b/gcc/config/loongarch/gnu-user.h
@@ -40,8 +40,10 @@ along with GCC; see the file COPYING3.  If not see
 #undef GNU_USER_TARGET_LINK_SPEC
 #define GNU_USER_TARGET_LINK_SPEC \
   "%{G*} %{shared} -m " GNU_USER_LINK_EMULATION \
-  "%{!shared: %{static} %{!static: %{rdynamic:-export-dynamic} " \
-  "-dynamic-linker " GNU_USER_DYNAMIC_LINKER "}}"
+  "%{!shared: %{static} " \
+  "%{!static: %{!static-pie: %{rdynamic:-export-dynamic} " \
+  "-dynamic-linker " GNU_USER_DYNAMIC_LINKER "}} " \
+  "%{static-pie: -static -pie --no-dynamic-linker -z text}}"
 
 
 /* Similar to standard Linux, but adding -ffast-math support.  */
-- 
2.38.1

From 3e8b0b80e63e420282f4bd5bc40119c26dbe01b4 Mon Sep 17 00:00:00 2001
From: Lulu Cheng <chenglulu@loongson.cn>
Date: Mon, 26 Sep 2022 09:42:51 +0800
Subject: [PATCH 21/36] LoongArch: Libitm add LoongArch support.

Co-Authored-By: Yang Yujie <yangyujie@loongson.cn>

libitm/ChangeLog:

	* configure.tgt: Add loongarch support.
	* config/loongarch/asm.h: New file.
	* config/loongarch/sjlj.S: New file.
	* config/loongarch/target.h: New file.
---
 libitm/config/loongarch/asm.h    |  54 +++++++++++++
 libitm/config/loongarch/sjlj.S   | 127 +++++++++++++++++++++++++++++++
 libitm/config/loongarch/target.h |  50 ++++++++++++
 libitm/configure.tgt             |   2 +
 4 files changed, 233 insertions(+)
 create mode 100644 libitm/config/loongarch/asm.h
 create mode 100644 libitm/config/loongarch/sjlj.S
 create mode 100644 libitm/config/loongarch/target.h

diff --git a/libitm/config/loongarch/asm.h b/libitm/config/loongarch/asm.h
new file mode 100644
index 00000000000..a8e3304bb19
--- /dev/null
+++ b/libitm/config/loongarch/asm.h
@@ -0,0 +1,54 @@
+/* Copyright (C) 2022 Free Software Foundation, Inc.
+   Contributed by Loongson Co. Ltd.
+
+   This file is part of the GNU Transactional Memory Library (libitm).
+
+   Libitm is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   Libitm is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+   more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _LA_ASM_H
+#define _LA_ASM_H
+
+#if defined(__loongarch_lp64)
+#  define GPR_L ld.d
+#  define GPR_S st.d
+#  define SZ_GPR 8
+#  define ADDSP(si)   addi.d  $sp, $sp, si
+#elif defined(__loongarch64_ilp32)
+#  define GPR_L ld.w
+#  define GPR_S st.w
+#  define SZ_GPR 4
+#  define ADDSP(si)   addi.w  $sp, $sp, si
+#else
+#  error Unsupported GPR size (must be 64-bit or 32-bit).
+#endif
+
+#if defined(__loongarch_double_float)
+#  define FPR_L fld.d
+#  define FPR_S fst.d
+#  define SZ_FPR 8
+#elif defined(__loongarch_single_float)
+#  define FPR_L fld.s
+#  define FPR_S fst.s
+#  define SZ_FPR 4
+#else
+#  define SZ_FPR 0
+#endif
+
+#endif  /* _LA_ASM_H */
diff --git a/libitm/config/loongarch/sjlj.S b/libitm/config/loongarch/sjlj.S
new file mode 100644
index 00000000000..a5f9fadde34
--- /dev/null
+++ b/libitm/config/loongarch/sjlj.S
@@ -0,0 +1,127 @@
+/* Copyright (C) 2022 Free Software Foundation, Inc.
+   Contributed by Loongson Co. Ltd.
+
+   This file is part of the GNU Transactional Memory Library (libitm).
+
+   Libitm is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   Libitm is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "asmcfi.h"
+#include "asm.h"
+
+	.text
+	.align	2
+	.global	_ITM_beginTransaction
+	.type	_ITM_beginTransaction, @function
+
+_ITM_beginTransaction:
+        cfi_startproc
+        move   $r5, $sp
+        ADDSP(-(12*SZ_GPR+8*SZ_FPR))
+        cfi_adjust_cfa_offset(12*SZ_GPR+8*SZ_FPR)
+
+        /* Frame Pointer */
+        GPR_S  $fp, $sp, 0*SZ_GPR
+        cfi_rel_offset(22, 0)
+
+        /* Return Address */
+        GPR_S  $r1, $sp, 1*SZ_GPR
+        cfi_rel_offset(1, SZ_GPR)
+
+        /* Caller's $sp */
+        GPR_S  $r5, $sp, 2*SZ_GPR
+
+        /* Callee-saved scratch GPRs (r23-r31) */
+        GPR_S  $s0, $sp, 3*SZ_GPR
+        GPR_S  $s1, $sp, 4*SZ_GPR
+        GPR_S  $s2, $sp, 5*SZ_GPR
+        GPR_S  $s3, $sp, 6*SZ_GPR
+        GPR_S  $s4, $sp, 7*SZ_GPR
+        GPR_S  $s5, $sp, 8*SZ_GPR
+        GPR_S  $s6, $sp, 9*SZ_GPR
+        GPR_S  $s7, $sp, 10*SZ_GPR
+        GPR_S  $s8, $sp, 11*SZ_GPR
+
+#if !defined(__loongarch_soft_float)
+        /* Callee-saved scratch FPRs (f24-f31) */
+        FPR_S  $f24, $sp, 12*SZ_GPR + 0*SZ_FPR
+        FPR_S  $f25, $sp, 12*SZ_GPR + 1*SZ_FPR
+        FPR_S  $f26, $sp, 12*SZ_GPR + 2*SZ_FPR
+        FPR_S  $f27, $sp, 12*SZ_GPR + 3*SZ_FPR
+        FPR_S  $f28, $sp, 12*SZ_GPR + 4*SZ_FPR
+        FPR_S  $f29, $sp, 12*SZ_GPR + 5*SZ_FPR
+        FPR_S  $f30, $sp, 12*SZ_GPR + 6*SZ_FPR
+        FPR_S  $f31, $sp, 12*SZ_GPR + 7*SZ_FPR
+#endif
+        move   $fp, $sp
+
+        /* Invoke GTM_begin_transaction with the struct we've just built.  */
+        move   $r5, $sp
+        bl     %plt(GTM_begin_transaction)
+
+        /* Return. (no call-saved scratch reg needs to be restored here)  */
+        GPR_L  $fp, $sp, 0*SZ_GPR
+        cfi_restore(22)
+        GPR_L  $r1, $sp, 1*SZ_GPR
+        cfi_restore(1)
+
+        ADDSP(12*SZ_GPR+8*SZ_FPR)
+        cfi_adjust_cfa_offset(-(12*SZ_GPR+8*SZ_FPR))
+
+        jr     $r1
+        cfi_endproc
+	.size	_ITM_beginTransaction, . - _ITM_beginTransaction
+
+	.align	2
+	.global	GTM_longjmp
+	.hidden	GTM_longjmp
+	.type	GTM_longjmp, @function
+
+GTM_longjmp:
+        cfi_startproc
+        GPR_L  $s0, $r5, 3*SZ_GPR
+        GPR_L  $s1, $r5, 4*SZ_GPR
+        GPR_L  $s2, $r5, 5*SZ_GPR
+        GPR_L  $s3, $r5, 6*SZ_GPR
+        GPR_L  $s4, $r5, 7*SZ_GPR
+        GPR_L  $s5, $r5, 8*SZ_GPR
+        GPR_L  $s6, $r5, 9*SZ_GPR
+        GPR_L  $s7, $r5, 10*SZ_GPR
+        GPR_L  $s8, $r5, 11*SZ_GPR
+
+        FPR_L  $f24, $r5, 12*SZ_GPR + 0*SZ_FPR
+        FPR_L  $f25, $r5, 12*SZ_GPR + 1*SZ_FPR
+        FPR_L  $f26, $r5, 12*SZ_GPR + 2*SZ_FPR
+        FPR_L  $f27, $r5, 12*SZ_GPR + 3*SZ_FPR
+        FPR_L  $f28, $r5, 12*SZ_GPR + 4*SZ_FPR
+        FPR_L  $f29, $r5, 12*SZ_GPR + 5*SZ_FPR
+        FPR_L  $f30, $r5, 12*SZ_GPR + 6*SZ_FPR
+        FPR_L  $f31, $r5, 12*SZ_GPR + 7*SZ_FPR
+
+        GPR_L  $r7, $r5, 2*SZ_GPR
+        GPR_L  $fp, $r5, 0*SZ_GPR
+        GPR_L  $r1, $r5, 1*SZ_GPR
+        cfi_def_cfa(5, 0)
+        move   $sp, $r7
+        jr     $r1
+        cfi_endproc
+	.size	GTM_longjmp, . - GTM_longjmp
+
+#ifdef __linux__
+.section .note.GNU-stack, "", @progbits
+#endif
diff --git a/libitm/config/loongarch/target.h b/libitm/config/loongarch/target.h
new file mode 100644
index 00000000000..0c5cf3ada57
--- /dev/null
+++ b/libitm/config/loongarch/target.h
@@ -0,0 +1,50 @@
+/* Copyright (C) 2022 Free Software Foundation, Inc.
+   Contributed by Loongson Co. Ltd.
+
+   This file is part of the GNU Transactional Memory Library (libitm).
+
+   Libitm is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   Libitm is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+   more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+namespace GTM HIDDEN {
+
+typedef struct gtm_jmpbuf
+  {
+    long int fp;        /* Frame Pointer: r22 */
+    long int pc;        /* Return Address: r1 */
+    void *cfa;          /* CFA: r3 */
+    long int gpr[9];	/* Callee-saved scratch GPRs: r23(s0)-r31(s8) */
+
+    /* Callee-saved scratch FPRs: f24-f31 */
+#if defined(__loongarch_double_float)
+    double fpr[8];
+#elif defined(__loongarch_single_float)
+    float fpr[8];
+#endif
+  } gtm_jmpbuf;
+
+#define HW_CACHELINE_SIZE 128
+
+static inline void
+cpu_relax (void)
+{
+    __asm__ volatile ("" : : : "memory");
+}
+
+} // namespace GTM
diff --git a/libitm/configure.tgt b/libitm/configure.tgt
index 06e90973ef3..4c0e78cff42 100644
--- a/libitm/configure.tgt
+++ b/libitm/configure.tgt
@@ -80,6 +80,8 @@ EOF
 	ARCH=x86
 	;;
 
+  loongarch*)   ARCH=loongarch ;;
+
   sh*)		ARCH=sh ;;
 
   sparc)
-- 
2.38.1

From 0ef235c85d488d1332dd60bce8a9317a1c3ee52f Mon Sep 17 00:00:00 2001
From: Lulu Cheng <chenglulu@loongson.cn>
Date: Wed, 28 Sep 2022 16:35:06 +0800
Subject: [PATCH 22/36] LoongArch: Fixed a typo in the comment information of
 the function loongarch_asan_shadow_offset.

gcc/ChangeLog:

	* config/loongarch/loongarch.cc (loongarch_asan_shadow_offset):
	Fixed typo in "asan_mapping.h".
---
 gcc/config/loongarch/loongarch.cc | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/gcc/config/loongarch/loongarch.cc b/gcc/config/loongarch/loongarch.cc
index 98c0e26cdb9..e9ba3374e35 100644
--- a/gcc/config/loongarch/loongarch.cc
+++ b/gcc/config/loongarch/loongarch.cc
@@ -6472,7 +6472,7 @@ static unsigned HOST_WIDE_INT
 loongarch_asan_shadow_offset (void)
 {
   /* We only have libsanitizer support for LOONGARCH64 at present.
-     This value is taken from the file libsanitizer/asan/asan_mappint.h.  */
+     This value is taken from the file libsanitizer/asan/asan_mapping.h.  */
   return TARGET_64BIT ? (HOST_WIDE_INT_1 << 46) : 0;
 }
 
-- 
2.38.1

From e9c66e490ad14cd0048b05ff865a844294632079 Mon Sep 17 00:00:00 2001
From: Xi Ruoyao <xry111@xry111.site>
Date: Sat, 24 Sep 2022 20:47:22 +0800
Subject: [PATCH 23/36] LoongArch: Use UNSPEC for fmin/fmax RTL pattern
 [PR105414]

I made a mistake defining fmin/fmax RTL patterns in r13-2085: I used
smin and smax in the definition mistakenly.  This causes the optimizer
to perform constant folding as if fmin/fmax was "really" smin/smax
operations even with -fsignaling-nans.  Then pr105414.c fails.

We don't have fmin/fmax RTL codes for now (PR107013) so we can only use
an UNSPEC for fmin and fmax patterns.

gcc/ChangeLog:

	PR tree-optimization/105414
	* config/loongarch/loongarch.md (UNSPEC_FMAX): New unspec.
	(UNSPEC_FMIN): Likewise.
	(fmax<mode>3): Use UNSPEC_FMAX instead of smax.
	(fmin<mode>3): Use UNSPEC_FMIN instead of smin.
---
 gcc/config/loongarch/loongarch.md | 12 ++++++++----
 1 file changed, 8 insertions(+), 4 deletions(-)

diff --git a/gcc/config/loongarch/loongarch.md b/gcc/config/loongarch/loongarch.md
index 3787fd8230f..214b14bddd3 100644
--- a/gcc/config/loongarch/loongarch.md
+++ b/gcc/config/loongarch/loongarch.md
@@ -35,6 +35,8 @@
   ;; Floating point unspecs.
   UNSPEC_FRINT
   UNSPEC_FCLASS
+  UNSPEC_FMAX
+  UNSPEC_FMIN
 
   ;; Override return address for exception handling.
   UNSPEC_EH_RETURN
@@ -1032,8 +1034,9 @@
 
 (define_insn "fmax<mode>3"
   [(set (match_operand:ANYF 0 "register_operand" "=f")
-	(smax:ANYF (match_operand:ANYF 1 "register_operand" "f")
-		   (match_operand:ANYF 2 "register_operand" "f")))]
+	(unspec:ANYF [(use (match_operand:ANYF 1 "register_operand" "f"))
+		      (use (match_operand:ANYF 2 "register_operand" "f"))]
+		     UNSPEC_FMAX))]
   ""
   "fmax.<fmt>\t%0,%1,%2"
   [(set_attr "type" "fmove")
@@ -1041,8 +1044,9 @@
 
 (define_insn "fmin<mode>3"
   [(set (match_operand:ANYF 0 "register_operand" "=f")
-	(smin:ANYF (match_operand:ANYF 1 "register_operand" "f")
-		   (match_operand:ANYF 2 "register_operand" "f")))]
+	(unspec:ANYF [(use (match_operand:ANYF 1 "register_operand" "f"))
+		      (use (match_operand:ANYF 2 "register_operand" "f"))]
+		     UNSPEC_FMIN))]
   ""
   "fmin.<fmt>\t%0,%1,%2"
   [(set_attr "type" "fmove")
-- 
2.38.1

From 50984bbb9692b11df16f7b554fe0c608ef82be53 Mon Sep 17 00:00:00 2001
From: Lulu Cheng <chenglulu@loongson.cn>
Date: Wed, 12 Oct 2022 11:02:11 +0800
Subject: [PATCH 24/36] LoongArch: Fixed a bug in the loongarch architecture of
 libitm package.

Add a soft floating point condition to the register recovery part of the code.

libitm/ChangeLog:

	* config/loongarch/sjlj.S: Add a soft floating point condition to the
	register recovery part of the code.
---
 libitm/config/loongarch/sjlj.S | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/libitm/config/loongarch/sjlj.S b/libitm/config/loongarch/sjlj.S
index a5f9fadde34..f896e400e6a 100644
--- a/libitm/config/loongarch/sjlj.S
+++ b/libitm/config/loongarch/sjlj.S
@@ -104,6 +104,8 @@ GTM_longjmp:
         GPR_L  $s7, $r5, 10*SZ_GPR
         GPR_L  $s8, $r5, 11*SZ_GPR
 
+#if !defined(__loongarch_soft_float)
+        /* Callee-saved scratch FPRs (f24-f31) */
         FPR_L  $f24, $r5, 12*SZ_GPR + 0*SZ_FPR
         FPR_L  $f25, $r5, 12*SZ_GPR + 1*SZ_FPR
         FPR_L  $f26, $r5, 12*SZ_GPR + 2*SZ_FPR
@@ -112,6 +114,7 @@ GTM_longjmp:
         FPR_L  $f29, $r5, 12*SZ_GPR + 5*SZ_FPR
         FPR_L  $f30, $r5, 12*SZ_GPR + 6*SZ_FPR
         FPR_L  $f31, $r5, 12*SZ_GPR + 7*SZ_FPR
+#endif
 
         GPR_L  $r7, $r5, 2*SZ_GPR
         GPR_L  $fp, $r5, 0*SZ_GPR
-- 
2.38.1

From 4b5b341fb9e58ad76217818e8063dea338a35403 Mon Sep 17 00:00:00 2001
From: Xi Ruoyao <xry111@xry111.site>
Date: Wed, 12 Oct 2022 22:06:07 +0800
Subject: [PATCH 25/36] LoongArch: implement count_{leading,trailing}_zeros

LoongArch always support clz and ctz instructions, so we can always use
__builtin_{clz,ctz} for count_{leading,trailing}_zeros.  This improves
the code of libgcc, and also benefits Glibc once we merge longlong.h
there.

Bootstrapped and regtested on loongarch64-linux-gnu.

include/ChangeLog:

	* longlong.h [__loongarch__] (count_leading_zeros): Define.
	[__loongarch__] (count_trailing_zeros): Likewise.
	[__loongarch__] (COUNT_LEADING_ZEROS_0): Likewise.
---
 include/longlong.h | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/include/longlong.h b/include/longlong.h
index 64a7b10f9b2..c3a6f1e7eaa 100644
--- a/include/longlong.h
+++ b/include/longlong.h
@@ -593,6 +593,18 @@ extern UDItype __umulsidi3 (USItype, USItype);
 #define UMUL_TIME 14
 #endif
 
+#ifdef __loongarch__
+# if W_TYPE_SIZE == 32
+#  define count_leading_zeros(count, x)  ((count) = __builtin_clz (x))
+#  define count_trailing_zeros(count, x) ((count) = __builtin_ctz (x))
+#  define COUNT_LEADING_ZEROS_0 32
+# elif W_TYPE_SIZE == 64
+#  define count_leading_zeros(count, x)  ((count) = __builtin_clzll (x))
+#  define count_trailing_zeros(count, x) ((count) = __builtin_ctzll (x))
+#  define COUNT_LEADING_ZEROS_0 64
+# endif
+#endif
+
 #if defined (__M32R__) && W_TYPE_SIZE == 32
 #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
   /* The cmp clears the condition bit.  */ \
-- 
2.38.1

From 8b331e121416135800ea00ebcec8339833ea6934 Mon Sep 17 00:00:00 2001
From: Lulu Cheng <chenglulu@loongson.cn>
Date: Tue, 27 Sep 2022 15:28:43 +0800
Subject: [PATCH 26/36] Libvtv: Add loongarch support.

The loongarch64 specification permits page sizes of 4KiB, 16KiB and 64KiB,
but only 16KiB pages are supported for now.

Co-Authored-By: qijingwen <qijingwen@loongson.cn>

include/ChangeLog:

	* vtv-change-permission.h (defined): Determines whether the macro
	__loongarch_lp64 is defined
	(VTV_PAGE_SIZE): Set VTV_PAGE_SIZE to 16KiB for loongarch64.

libvtv/ChangeLog:

	* configure.tgt: Add loongarch support.
---
 include/vtv-change-permission.h | 4 ++++
 libvtv/configure.tgt            | 3 +++
 2 files changed, 7 insertions(+)

diff --git a/include/vtv-change-permission.h b/include/vtv-change-permission.h
index 70bdad92bca..e7b9294a081 100644
--- a/include/vtv-change-permission.h
+++ b/include/vtv-change-permission.h
@@ -48,6 +48,10 @@ extern void __VLTChangePermission (int);
 #else 
 #if defined(__sun__) && defined(__svr4__) && defined(__sparc__)
 #define VTV_PAGE_SIZE 8192
+#elif defined(__loongarch_lp64)
+/* The page size is configurable by the kernel to be 4, 16 or 64 KiB.
+   For now, only the default page size of 16KiB is supported.  */
+#define VTV_PAGE_SIZE 16384
 #else
 #define VTV_PAGE_SIZE 4096
 #endif
diff --git a/libvtv/configure.tgt b/libvtv/configure.tgt
index aa2a3f675b8..6cdd1e97ab1 100644
--- a/libvtv/configure.tgt
+++ b/libvtv/configure.tgt
@@ -50,6 +50,9 @@ case "${target}" in
 	;;
   x86_64-*-darwin[1]* | i?86-*-darwin[1]*)
 	;;
+  loongarch*-*-linux*)
+	VTV_SUPPORTED=yes
+	;;
   *)
 	;;
 esac
-- 
2.38.1

From 63e8362452f770b61b70b63ea0174358419824ee Mon Sep 17 00:00:00 2001
From: Xi Ruoyao <xry111@xry111.site>
Date: Fri, 4 Nov 2022 15:12:22 +0800
Subject: [PATCH 27/36] LoongArch: Add fcopysign instructions

Add fcopysign.{s,d} with the names copysign{sf,df}3 so GCC will expand
__builtin_copysign{f,} to a single instruction.

Link: https://sourceware.org/pipermail/libc-alpha/2022-November/143177.html

gcc/ChangeLog:

	* config/loongarch/loongarch.md (UNSPEC_FCOPYSIGN): New unspec.
	(type): Add fcopysign.
	(copysign<mode>3): New instruction template.

gcc/testsuite/ChangeLog:

	* gcc.target/loongarch/fcopysign.c: New test.
---
 gcc/config/loongarch/loongarch.md             | 22 ++++++++++++++++++-
 .../gcc.target/loongarch/fcopysign.c          | 16 ++++++++++++++
 2 files changed, 37 insertions(+), 1 deletion(-)
 create mode 100644 gcc/testsuite/gcc.target/loongarch/fcopysign.c

diff --git a/gcc/config/loongarch/loongarch.md b/gcc/config/loongarch/loongarch.md
index 214b14bddd3..bda34d0f3db 100644
--- a/gcc/config/loongarch/loongarch.md
+++ b/gcc/config/loongarch/loongarch.md
@@ -37,6 +37,7 @@
   UNSPEC_FCLASS
   UNSPEC_FMAX
   UNSPEC_FMIN
+  UNSPEC_FCOPYSIGN
 
   ;; Override return address for exception handling.
   UNSPEC_EH_RETURN
@@ -214,6 +215,7 @@
 ;; fabs		floating point absolute value
 ;; fneg		floating point negation
 ;; fcmp		floating point compare
+;; fcopysign	floating point copysign
 ;; fcvt		floating point convert
 ;; fsqrt	floating point square root
 ;; frsqrt       floating point reciprocal square root
@@ -226,7 +228,7 @@
   "unknown,branch,jump,call,load,fpload,fpidxload,store,fpstore,fpidxstore,
    prefetch,prefetchx,condmove,mgtf,mftg,const,arith,logical,
    shift,slt,signext,clz,trap,imul,idiv,move,
-   fmove,fadd,fmul,fmadd,fdiv,frdiv,fabs,fneg,fcmp,fcvt,fsqrt,
+   fmove,fadd,fmul,fmadd,fdiv,frdiv,fabs,fneg,fcmp,fcopysign,fcvt,fsqrt,
    frsqrt,accext,accmod,multi,atomic,syncloop,nop,ghost"
   (cond [(eq_attr "jirl" "!unset") (const_string "call")
 	 (eq_attr "got" "load") (const_string "load")
@@ -976,6 +978,24 @@
    (set_attr "mode" "<UNITMODE>")])
 
 ;;
+;;  ....................
+;;
+;;	FLOATING POINT COPYSIGN
+;;
+;;  ....................
+
+(define_insn "copysign<mode>3"
+  [(set (match_operand:ANYF 0 "register_operand" "=f")
+	(unspec:ANYF [(match_operand:ANYF 1 "register_operand" "f")
+		      (match_operand:ANYF 2 "register_operand" "f")]
+		     UNSPEC_FCOPYSIGN))]
+  "TARGET_HARD_FLOAT"
+  "fcopysign.<fmt>\t%0,%1,%2"
+  [(set_attr "type" "fcopysign")
+   (set_attr "mode" "<UNITMODE>")])
+
+
+;;
 ;;  ...................
 ;;
 ;;  Count leading zeroes.
diff --git a/gcc/testsuite/gcc.target/loongarch/fcopysign.c b/gcc/testsuite/gcc.target/loongarch/fcopysign.c
new file mode 100644
index 00000000000..058ba2cf573
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/fcopysign.c
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-options "-mdouble-float" } */
+/* { dg-final { scan-assembler "fcopysign\\.s" } } */
+/* { dg-final { scan-assembler "fcopysign\\.d" } } */
+
+double
+my_copysign (double a, double b)
+{
+  return __builtin_copysign (a, b);
+}
+
+float
+my_copysignf (float a, float b)
+{
+  return __builtin_copysignf (a, b);
+}
-- 
2.38.1

From a93981837a453b5a0fa389fe81e857665cf84fb2 Mon Sep 17 00:00:00 2001
From: Xi Ruoyao <xry111@xry111.site>
Date: Fri, 4 Nov 2022 01:35:25 +0800
Subject: [PATCH 28/36] LoongArch: fix signed overflow in
 loongarch_emit_int_compare

Signed overflow is an undefined behavior, so we need to prevent it from
happening, instead of "checking" the result.

gcc/ChangeLog:

	* config/loongarch/loongarch.cc (loongarch_emit_int_compare):
	Avoid signed overflow.
---
 gcc/config/loongarch/loongarch.cc | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/gcc/config/loongarch/loongarch.cc b/gcc/config/loongarch/loongarch.cc
index e9ba3374e35..d552b162ae9 100644
--- a/gcc/config/loongarch/loongarch.cc
+++ b/gcc/config/loongarch/loongarch.cc
@@ -4177,10 +4177,13 @@ loongarch_emit_int_compare (enum rtx_code *code, rtx *op0, rtx *op1)
 	      if (!increment && !decrement)
 		continue;
 
+	      if ((increment && rhs == HOST_WIDE_INT_MAX)
+		  || (decrement && rhs == HOST_WIDE_INT_MIN))
+		break;
+
 	      new_rhs = rhs + (increment ? 1 : -1);
 	      if (loongarch_integer_cost (new_rhs)
-		    < loongarch_integer_cost (rhs)
-		  && (rhs < 0) == (new_rhs < 0))
+		    < loongarch_integer_cost (rhs))
 		{
 		  *op1 = GEN_INT (new_rhs);
 		  *code = mag_comparisons[i][increment];
-- 
2.38.1

From 29c3cb844dcf58a1b7e43edff361408715399acb Mon Sep 17 00:00:00 2001
From: Xi Ruoyao <xry111@xry111.site>
Date: Sun, 6 Nov 2022 20:41:38 +0800
Subject: [PATCH 29/36] LoongArch: Rename frint_<fmt> to rint<mode>2

Use standard name so __builtin_rint{,f} can be expanded to one
instruction.

gcc/ChangeLog:

	* config/loongarch/loongarch.md (frint_<fmt>): Rename to ..
	(rint<mode>2): .. this.

gcc/testsuite/ChangeLog:

	* gcc.target/loongarch/frint.c: New test.
---
 gcc/config/loongarch/loongarch.md          |  4 ++--
 gcc/testsuite/gcc.target/loongarch/frint.c | 16 ++++++++++++++++
 2 files changed, 18 insertions(+), 2 deletions(-)
 create mode 100644 gcc/testsuite/gcc.target/loongarch/frint.c

diff --git a/gcc/config/loongarch/loongarch.md b/gcc/config/loongarch/loongarch.md
index bda34d0f3db..a14ab14ac24 100644
--- a/gcc/config/loongarch/loongarch.md
+++ b/gcc/config/loongarch/loongarch.md
@@ -2012,8 +2012,8 @@
   [(set_attr "type" "move")]
 )
 
-;; Convert floating-point numbers to integers
-(define_insn "frint_<fmt>"
+;; Round floating-point numbers to integers
+(define_insn "rint<mode>2"
   [(set (match_operand:ANYF 0 "register_operand" "=f")
 	(unspec:ANYF [(match_operand:ANYF 1 "register_operand" "f")]
 		      UNSPEC_FRINT))]
diff --git a/gcc/testsuite/gcc.target/loongarch/frint.c b/gcc/testsuite/gcc.target/loongarch/frint.c
new file mode 100644
index 00000000000..3ee6a8f973a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/frint.c
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-options "-mdouble-float" } */
+/* { dg-final { scan-assembler "frint\\.s" } } */
+/* { dg-final { scan-assembler "frint\\.d" } } */
+
+double
+my_rint (double a)
+{
+  return __builtin_rint (a);
+}
+
+float
+my_rintf (float a)
+{
+  return __builtin_rintf (a);
+}
-- 
2.38.1

From 7126ca16d9c3cbbd6d26ccbb3f955d2e479cd848 Mon Sep 17 00:00:00 2001
From: Xi Ruoyao <xry111@xry111.site>
Date: Sun, 6 Nov 2022 23:16:49 +0800
Subject: [PATCH 30/36] LoongArch: Add ftint{,rm,rp}.{w,l}.{s,d} instructions

This allows to optimize the following builtins if -fno-math-errno:

- __builtin_lrint{,f}
- __builtin_lfloor{,f}
- __builtin_lceil{,f}

Inspired by
https://gcc.gnu.org/pipermail/gcc-patches/2022-November/605287.html.

ANYFI is added so the compiler won't try ftint.l.s if -mfpu=32.  If we
simply used GPR here an ICE would be triggered with __builtin_lrintf
and -mfpu=32.

ftint{rm,rp} instructions may raise inexact exception, so they can't be
used if -fno-trapping-math -fno-fp-int-builtin-inexact.

Note that the .w.{s,d} variants are not tested because we don't support
ILP32 for now.

gcc/ChangeLog:

	* config/loongarch/loongarch.md (UNSPEC_FTINT): New unspec.
	(UNSPEC_FTINTRM): Likewise.
	(UNSPEC_FTINTRP): Likewise.
	(LRINT): New define_int_iterator.
	(lrint_pattern): New define_int_attr.
	(lrint_submenmonic): Likewise.
	(lrint_allow_inexact): Likewise.
	(ANYFI): New define_mode_iterator.
	(lrint<ANYF><ANYFI>): New instruction template.

gcc/testsuite/ChangeLog:

	* gcc.target/loongarch/ftint.c: New test.
	* gcc.target/loongarch/ftint-no-inexact.c: New test.
---
 gcc/config/loongarch/loongarch.md             | 34 ++++++++++++++
 .../gcc.target/loongarch/ftint-no-inexact.c   | 44 +++++++++++++++++++
 gcc/testsuite/gcc.target/loongarch/ftint.c    | 44 +++++++++++++++++++
 3 files changed, 122 insertions(+)
 create mode 100644 gcc/testsuite/gcc.target/loongarch/ftint-no-inexact.c
 create mode 100644 gcc/testsuite/gcc.target/loongarch/ftint.c

diff --git a/gcc/config/loongarch/loongarch.md b/gcc/config/loongarch/loongarch.md
index a14ab14ac24..eb127c346a3 100644
--- a/gcc/config/loongarch/loongarch.md
+++ b/gcc/config/loongarch/loongarch.md
@@ -38,6 +38,9 @@
   UNSPEC_FMAX
   UNSPEC_FMIN
   UNSPEC_FCOPYSIGN
+  UNSPEC_FTINT
+  UNSPEC_FTINTRM
+  UNSPEC_FTINTRP
 
   ;; Override return address for exception handling.
   UNSPEC_EH_RETURN
@@ -374,6 +377,11 @@
 (define_mode_iterator ANYF [(SF "TARGET_HARD_FLOAT")
 			    (DF "TARGET_DOUBLE_FLOAT")])
 
+;; Iterator for fixed-point modes which can be hold by a hardware
+;; floating-point register.
+(define_mode_iterator ANYFI [(SI "TARGET_HARD_FLOAT")
+			     (DI "TARGET_DOUBLE_FLOAT")])
+
 ;; A mode for which moves involving FPRs may need to be split.
 (define_mode_iterator SPLITF
   [(DF "!TARGET_64BIT && TARGET_DOUBLE_FLOAT")
@@ -515,6 +523,19 @@
 (define_code_attr sel [(eq "masknez") (ne "maskeqz")])
 (define_code_attr selinv [(eq "maskeqz") (ne "masknez")])
 
+;; Iterator and attributes for floating-point to fixed-point conversion
+;; instructions.
+(define_int_iterator LRINT [UNSPEC_FTINT UNSPEC_FTINTRM UNSPEC_FTINTRP])
+(define_int_attr lrint_pattern [(UNSPEC_FTINT "lrint")
+				(UNSPEC_FTINTRM "lfloor")
+				(UNSPEC_FTINTRP "lceil")])
+(define_int_attr lrint_submenmonic [(UNSPEC_FTINT "")
+				    (UNSPEC_FTINTRM "rm")
+				    (UNSPEC_FTINTRP "rp")])
+(define_int_attr lrint_allow_inexact [(UNSPEC_FTINT "1")
+				      (UNSPEC_FTINTRM "0")
+				      (UNSPEC_FTINTRP "0")])
+
 ;;
 ;;  ....................
 ;;
@@ -2022,6 +2043,19 @@
   [(set_attr "type" "fcvt")
    (set_attr "mode" "<MODE>")])
 
+;; Convert floating-point numbers to integers
+(define_insn "<lrint_pattern><ANYF:mode><ANYFI:mode>2"
+  [(set (match_operand:ANYFI 0 "register_operand" "=f")
+	(unspec:ANYFI [(match_operand:ANYF 1 "register_operand" "f")]
+		      LRINT))]
+  "TARGET_HARD_FLOAT &&
+   (<lrint_allow_inexact>
+    || flag_fp_int_builtin_inexact
+    || !flag_trapping_math)"
+  "ftint<lrint_submenmonic>.<ANYFI:ifmt>.<ANYF:fmt> %0,%1"
+  [(set_attr "type" "fcvt")
+   (set_attr "mode" "<ANYF:MODE>")])
+
 ;; Load the low word of operand 0 with operand 1.
 (define_insn "load_low<mode>"
   [(set (match_operand:SPLITF 0 "register_operand" "=f,f")
diff --git a/gcc/testsuite/gcc.target/loongarch/ftint-no-inexact.c b/gcc/testsuite/gcc.target/loongarch/ftint-no-inexact.c
new file mode 100644
index 00000000000..88b83a9c056
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/ftint-no-inexact.c
@@ -0,0 +1,44 @@
+/* { dg-do compile } */
+/* { dg-options "-mabi=lp64d -mdouble-float -fno-math-errno -fno-fp-int-builtin-inexact" } */
+/* { dg-final { scan-assembler "ftint\\.l\\.s" } } */
+/* { dg-final { scan-assembler "ftint\\.l\\.d" } } */
+/* { dg-final { scan-assembler-not "ftintrm\\.l\\.s" } } */
+/* { dg-final { scan-assembler-not "ftintrm\\.l\\.d" } } */
+/* { dg-final { scan-assembler-not "ftintrp\\.l\\.s" } } */
+/* { dg-final { scan-assembler-not "ftintrp\\.l\\.d" } } */
+
+long
+my_lrint (double a)
+{
+  return __builtin_lrint (a);
+}
+
+long
+my_lrintf (float a)
+{
+  return __builtin_lrintf (a);
+}
+
+long
+my_lfloor (double a)
+{
+  return __builtin_lfloor (a);
+}
+
+long
+my_lfloorf (float a)
+{
+  return __builtin_lfloorf (a);
+}
+
+long
+my_lceil (double a)
+{
+  return __builtin_lceil (a);
+}
+
+long
+my_lceilf (float a)
+{
+  return __builtin_lceilf (a);
+}
diff --git a/gcc/testsuite/gcc.target/loongarch/ftint.c b/gcc/testsuite/gcc.target/loongarch/ftint.c
new file mode 100644
index 00000000000..7a326a454d8
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/ftint.c
@@ -0,0 +1,44 @@
+/* { dg-do compile } */
+/* { dg-options "-mabi=lp64d -mdouble-float -fno-math-errno -ffp-int-builtin-inexact" } */
+/* { dg-final { scan-assembler "ftint\\.l\\.s" } } */
+/* { dg-final { scan-assembler "ftint\\.l\\.d" } } */
+/* { dg-final { scan-assembler "ftintrm\\.l\\.s" } } */
+/* { dg-final { scan-assembler "ftintrm\\.l\\.d" } } */
+/* { dg-final { scan-assembler "ftintrp\\.l\\.s" } } */
+/* { dg-final { scan-assembler "ftintrp\\.l\\.d" } } */
+
+long
+my_lrint (double a)
+{
+  return __builtin_lrint (a);
+}
+
+long
+my_lrintf (float a)
+{
+  return __builtin_lrintf (a);
+}
+
+long
+my_lfloor (double a)
+{
+  return __builtin_lfloor (a);
+}
+
+long
+my_lfloorf (float a)
+{
+  return __builtin_lfloorf (a);
+}
+
+long
+my_lceil (double a)
+{
+  return __builtin_lceil (a);
+}
+
+long
+my_lceilf (float a)
+{
+  return __builtin_lceilf (a);
+}
-- 
2.38.1

From 9efe5fea70227d6f190abba8aeb6853419c30ad0 Mon Sep 17 00:00:00 2001
From: Xi Ruoyao <xry111@xry111.site>
Date: Tue, 8 Nov 2022 12:14:35 +0800
Subject: [PATCH 31/36] LoongArch: Add fscaleb.{s,d} instructions as
 ldexp{sf,df}3

This allows optimizing __builtin_ldexp{,f} and __builtin_scalbn{,f} with
-fno-math-errno.

IMODE is added because we can't hard code SI for operand 2: fscaleb.d
instruction always take the high half of both source registers into
account.  See my_ldexp_long in the test case.

gcc/ChangeLog:

	* config/loongarch/loongarch.md (UNSPEC_FSCALEB): New unspec.
	(type): Add fscaleb.
	(IMODE): New mode attr.
	(ldexp<mode>3): New instruction template.

gcc/testsuite/ChangeLog:

	* gcc.target/loongarch/fscaleb.c: New test.
---
 gcc/config/loongarch/loongarch.md            | 26 ++++++++++-
 gcc/testsuite/gcc.target/loongarch/fscaleb.c | 48 ++++++++++++++++++++
 2 files changed, 72 insertions(+), 2 deletions(-)
 create mode 100644 gcc/testsuite/gcc.target/loongarch/fscaleb.c

diff --git a/gcc/config/loongarch/loongarch.md b/gcc/config/loongarch/loongarch.md
index eb127c346a3..c141c9adde2 100644
--- a/gcc/config/loongarch/loongarch.md
+++ b/gcc/config/loongarch/loongarch.md
@@ -41,6 +41,7 @@
   UNSPEC_FTINT
   UNSPEC_FTINTRM
   UNSPEC_FTINTRP
+  UNSPEC_FSCALEB
 
   ;; Override return address for exception handling.
   UNSPEC_EH_RETURN
@@ -220,6 +221,7 @@
 ;; fcmp		floating point compare
 ;; fcopysign	floating point copysign
 ;; fcvt		floating point convert
+;; fscaleb	floating point scale
 ;; fsqrt	floating point square root
 ;; frsqrt       floating point reciprocal square root
 ;; multi	multiword sequence (or user asm statements)
@@ -231,8 +233,8 @@
   "unknown,branch,jump,call,load,fpload,fpidxload,store,fpstore,fpidxstore,
    prefetch,prefetchx,condmove,mgtf,mftg,const,arith,logical,
    shift,slt,signext,clz,trap,imul,idiv,move,
-   fmove,fadd,fmul,fmadd,fdiv,frdiv,fabs,fneg,fcmp,fcopysign,fcvt,fsqrt,
-   frsqrt,accext,accmod,multi,atomic,syncloop,nop,ghost"
+   fmove,fadd,fmul,fmadd,fdiv,frdiv,fabs,fneg,fcmp,fcopysign,fcvt,fscaleb,
+   fsqrt,frsqrt,accext,accmod,multi,atomic,syncloop,nop,ghost"
   (cond [(eq_attr "jirl" "!unset") (const_string "call")
 	 (eq_attr "got" "load") (const_string "load")
 
@@ -418,6 +420,10 @@
 ;; the controlling mode.
 (define_mode_attr HALFMODE [(DF "SI") (DI "SI") (TF "DI")])
 
+;; This attribute gives the integer mode that has the same size of a
+;; floating-point mode.
+(define_mode_attr IMODE [(SF "SI") (DF "DI")])
+
 ;; This code iterator allows signed and unsigned widening multiplications
 ;; to use the same template.
 (define_code_iterator any_extend [sign_extend zero_extend])
@@ -1014,7 +1020,23 @@
   "fcopysign.<fmt>\t%0,%1,%2"
   [(set_attr "type" "fcopysign")
    (set_attr "mode" "<UNITMODE>")])
+
+;;
+;;  ....................
+;;
+;;	FLOATING POINT SCALE
+;;
+;;  ....................
 
+(define_insn "ldexp<mode>3"
+  [(set (match_operand:ANYF 0 "register_operand" "=f")
+	(unspec:ANYF [(match_operand:ANYF    1 "register_operand" "f")
+		      (match_operand:<IMODE> 2 "register_operand" "f")]
+		     UNSPEC_FSCALEB))]
+  "TARGET_HARD_FLOAT"
+  "fscaleb.<fmt>\t%0,%1,%2"
+  [(set_attr "type" "fscaleb")
+   (set_attr "mode" "<UNITMODE>")])
 
 ;;
 ;;  ...................
diff --git a/gcc/testsuite/gcc.target/loongarch/fscaleb.c b/gcc/testsuite/gcc.target/loongarch/fscaleb.c
new file mode 100644
index 00000000000..f18470fbb8f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/fscaleb.c
@@ -0,0 +1,48 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mabi=lp64d -mdouble-float -fno-math-errno" } */
+/* { dg-final { scan-assembler-times "fscaleb\\.s" 3 } } */
+/* { dg-final { scan-assembler-times "fscaleb\\.d" 4 } } */
+/* { dg-final { scan-assembler-times "slli\\.w" 1 } } */
+
+double
+my_scalbln (double a, long b)
+{
+  return __builtin_scalbln (a, b);
+}
+
+double
+my_scalbn (double a, int b)
+{
+  return __builtin_scalbn (a, b);
+}
+
+double
+my_ldexp (double a, int b)
+{
+  return __builtin_ldexp (a, b);
+}
+
+float
+my_scalblnf (float a, long b)
+{
+  return __builtin_scalblnf (a, b);
+}
+
+float
+my_scalbnf (float a, int b)
+{
+  return __builtin_scalbnf (a, b);
+}
+
+float
+my_ldexpf (float a, int b)
+{
+  return __builtin_ldexpf (a, b);
+}
+
+/* b must be sign-extended */
+double
+my_ldexp_long (double a, long b)
+{
+  return __builtin_ldexp (a, b);
+}
-- 
2.38.1

From 3de4adb56e54dd088da4cd3f47e4e370dad3120b Mon Sep 17 00:00:00 2001
From: Xi Ruoyao <xry111@xry111.site>
Date: Tue, 8 Nov 2022 13:42:20 +0800
Subject: [PATCH 32/36] LoongArch: Add flogb.{s,d} instructions and expand
 logb{sf,df}2

On LoongArch, flogb instructions extract the exponent of a non-negative
floating point value, but produces NaN for negative values.  So we need
to add a fabs instruction when we expand logb.

gcc/ChangeLog:

	* config/loongarch/loongarch.md (UNSPEC_FLOGB): New unspec.
	(type): Add flogb.
	(logb_non_negative<mode>2): New instruction template.
	(logb<mode>2): New define_expand.

gcc/testsuite/ChangeLog:

	* gcc.target/loongarch/flogb.c: New test.
---
 gcc/config/loongarch/loongarch.md          | 35 ++++++++++++++++++++--
 gcc/testsuite/gcc.target/loongarch/flogb.c | 18 +++++++++++
 2 files changed, 51 insertions(+), 2 deletions(-)
 create mode 100644 gcc/testsuite/gcc.target/loongarch/flogb.c

diff --git a/gcc/config/loongarch/loongarch.md b/gcc/config/loongarch/loongarch.md
index c141c9adde2..682ab961741 100644
--- a/gcc/config/loongarch/loongarch.md
+++ b/gcc/config/loongarch/loongarch.md
@@ -42,6 +42,7 @@
   UNSPEC_FTINTRM
   UNSPEC_FTINTRP
   UNSPEC_FSCALEB
+  UNSPEC_FLOGB
 
   ;; Override return address for exception handling.
   UNSPEC_EH_RETURN
@@ -217,6 +218,7 @@
 ;; fdiv		floating point divide
 ;; frdiv	floating point reciprocal divide
 ;; fabs		floating point absolute value
+;; flogb	floating point exponent extract
 ;; fneg		floating point negation
 ;; fcmp		floating point compare
 ;; fcopysign	floating point copysign
@@ -233,8 +235,8 @@
   "unknown,branch,jump,call,load,fpload,fpidxload,store,fpstore,fpidxstore,
    prefetch,prefetchx,condmove,mgtf,mftg,const,arith,logical,
    shift,slt,signext,clz,trap,imul,idiv,move,
-   fmove,fadd,fmul,fmadd,fdiv,frdiv,fabs,fneg,fcmp,fcopysign,fcvt,fscaleb,
-   fsqrt,frsqrt,accext,accmod,multi,atomic,syncloop,nop,ghost"
+   fmove,fadd,fmul,fmadd,fdiv,frdiv,fabs,flogb,fneg,fcmp,fcopysign,fcvt,
+   fscaleb,fsqrt,frsqrt,accext,accmod,multi,atomic,syncloop,nop,ghost"
   (cond [(eq_attr "jirl" "!unset") (const_string "call")
 	 (eq_attr "got" "load") (const_string "load")
 
@@ -1039,6 +1041,35 @@
    (set_attr "mode" "<UNITMODE>")])
 
 ;;
+;;  ....................
+;;
+;;	FLOATING POINT EXPONENT EXTRACT
+;;
+;;  ....................
+
+(define_insn "logb_non_negative<mode>2"
+  [(set (match_operand:ANYF 0 "register_operand" "=f")
+	(unspec:ANYF [(match_operand:ANYF 1 "register_operand" "f")]
+		     UNSPEC_FLOGB))]
+  "TARGET_HARD_FLOAT"
+  "flogb.<fmt>\t%0,%1"
+  [(set_attr "type" "flogb")
+   (set_attr "mode" "<UNITMODE>")])
+
+(define_expand "logb<mode>2"
+  [(set (match_operand:ANYF 0 "register_operand")
+	(unspec:ANYF [(abs:ANYF (match_operand:ANYF 1 "register_operand"))]
+		     UNSPEC_FLOGB))]
+  "TARGET_HARD_FLOAT"
+{
+  rtx tmp = gen_reg_rtx (<MODE>mode);
+
+  emit_insn (gen_abs<mode>2 (tmp, operands[1]));
+  emit_insn (gen_logb_non_negative<mode>2 (operands[0], tmp));
+  DONE;
+})
+
+;;
 ;;  ...................
 ;;
 ;;  Count leading zeroes.
diff --git a/gcc/testsuite/gcc.target/loongarch/flogb.c b/gcc/testsuite/gcc.target/loongarch/flogb.c
new file mode 100644
index 00000000000..1daefe54e13
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/flogb.c
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-options "-mdouble-float -fno-math-errno" } */
+/* { dg-final { scan-assembler "fabs\\.s" } } */
+/* { dg-final { scan-assembler "fabs\\.d" } } */
+/* { dg-final { scan-assembler "flogb\\.s" } } */
+/* { dg-final { scan-assembler "flogb\\.d" } } */
+
+double
+my_logb (double a)
+{
+  return __builtin_logb (a);
+}
+
+float
+my_logbf (float a)
+{
+  return __builtin_logbf (a);
+}
-- 
2.38.1

From 4b072a97304214e08b1d29d6e525d46fc9450c39 Mon Sep 17 00:00:00 2001
From: Jinyang He <hejinyang@loongson.cn>
Date: Thu, 17 Nov 2022 14:38:52 +0800
Subject: [PATCH 33/36] LoongArch: Fix atomic_exchange expanding [PR107713]

We used to expand atomic_exchange_n(ptr, new, mem_order) for subword types
into something like:

    {
      __typeof__(*ptr) t = atomic_load_n(ptr, mem_order);
      atomic_compare_exchange_n(ptr, &t, new, true, mem_order, mem_order);
      return t;
    }

It's incorrect because another thread may store a different value into *ptr
after atomic_load_n.  Then atomic_compare_exchange_n will not store into
*ptr, but atomic_exchange_n should always perform the store.

gcc/ChangeLog:

	PR target/107713
	* config/loongarch/sync.md
	(atomic_cas_value_exchange_7_<mode>): New define_insn.
	(atomic_exchange): Use atomic_cas_value_exchange_7_si instead of
	atomic_cas_value_cmp_and_7_si.

gcc/testsuite/ChangeLog:

	PR target/107713
	* gcc.target/loongarch/pr107713-1.c: New test.
	* gcc.target/loongarch/pr107713-2.c: New test.
---
 gcc/config/loongarch/sync.md                  | 27 +++++++++-
 .../gcc.target/loongarch/pr107713-1.c         | 50 +++++++++++++++++++
 .../gcc.target/loongarch/pr107713-2.c         |  9 ++++
 3 files changed, 84 insertions(+), 2 deletions(-)
 create mode 100644 gcc/testsuite/gcc.target/loongarch/pr107713-1.c
 create mode 100644 gcc/testsuite/gcc.target/loongarch/pr107713-2.c

diff --git a/gcc/config/loongarch/sync.md b/gcc/config/loongarch/sync.md
index 0c4f1983e88..45be1442439 100644
--- a/gcc/config/loongarch/sync.md
+++ b/gcc/config/loongarch/sync.md
@@ -448,6 +448,29 @@
 }
   [(set (attr "length") (const_int 32))])
 
+(define_insn "atomic_cas_value_exchange_7_<mode>"
+  [(set (match_operand:GPR 0 "register_operand" "=&r")
+	(match_operand:GPR 1 "memory_operand" "+ZC"))
+   (set (match_dup 1)
+	(unspec_volatile:GPR [(match_operand:GPR 2 "reg_or_0_operand" "rJ")
+			      (match_operand:GPR 3 "reg_or_0_operand" "rJ")
+			      (match_operand:GPR 4 "reg_or_0_operand" "rJ")
+			      (match_operand:GPR 5 "reg_or_0_operand"  "rJ")
+			      (match_operand:SI 6 "const_int_operand")] ;; model
+	 UNSPEC_SYNC_EXCHANGE))
+   (clobber (match_scratch:GPR 7 "=&r"))]
+  ""
+{
+  return "%G6\\n\\t"
+	 "1:\\n\\t"
+	 "ll.<amo>\\t%0,%1\\n\\t"
+	 "and\\t%7,%0,%z3\\n\\t"
+	 "or%i5\\t%7,%7,%5\\n\\t"
+	 "sc.<amo>\\t%7,%1\\n\\t"
+	 "beqz\\t%7,1b\\n\\t";
+}
+  [(set (attr "length") (const_int 20))])
+
 (define_expand "atomic_exchange<mode>"
   [(set (match_operand:SHORT 0 "register_operand")
 	(unspec_volatile:SHORT
@@ -459,9 +482,9 @@
   ""
 {
   union loongarch_gen_fn_ptrs generator;
-  generator.fn_7 = gen_atomic_cas_value_cmp_and_7_si;
+  generator.fn_7 = gen_atomic_cas_value_exchange_7_si;
   loongarch_expand_atomic_qihi (generator, operands[0], operands[1],
-				operands[1], operands[2], operands[3]);
+				const0_rtx, operands[2], operands[3]);
   DONE;
 })
 
diff --git a/gcc/testsuite/gcc.target/loongarch/pr107713-1.c b/gcc/testsuite/gcc.target/loongarch/pr107713-1.c
new file mode 100644
index 00000000000..d1536c95b27
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/pr107713-1.c
@@ -0,0 +1,50 @@
+/* { dg-do run } */
+/* { dg-require-effective-target pthread } */
+/* { dg-options "-pthread" } */
+
+#include <pthread.h>
+
+char x, x1, x2;
+
+void *
+work1 (void *)
+{
+  for (int i = 0; i < 100; i++)
+    x1 = __atomic_exchange_n (&x, x1, __ATOMIC_SEQ_CST);
+  return NULL;
+}
+
+void *
+work2 (void *)
+{
+  for (int i = 0; i < 100; i++)
+    x2 = __atomic_exchange_n (&x, x2, __ATOMIC_SEQ_CST);
+  return NULL;
+}
+
+void
+test (void)
+{
+  x = 0;
+  x1 = 1;
+  x2 = 2;
+  pthread_t w1, w2;
+  if (pthread_create (&w1, NULL, work1, NULL) != 0)
+    __builtin_abort ();
+  if (pthread_create (&w2, NULL, work2, NULL) != 0)
+    __builtin_abort ();
+  if (pthread_join (w1, NULL) != 0)
+    __builtin_abort ();
+  if (pthread_join (w2, NULL) != 0)
+    __builtin_abort ();
+  if ((x ^ x1 ^ x2) != 3)
+    __builtin_abort ();
+}
+
+int
+main ()
+{
+  int i;
+  for (i = 0; i < 10000; i++)
+    test ();
+}
diff --git a/gcc/testsuite/gcc.target/loongarch/pr107713-2.c b/gcc/testsuite/gcc.target/loongarch/pr107713-2.c
new file mode 100644
index 00000000000..82d44db3d51
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/pr107713-2.c
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+/* { dg-final { scan-assembler-times "beq|bne" 1 } } */
+
+char
+t (char *p, char x)
+{
+  return __atomic_exchange_n (p, x, __ATOMIC_RELAXED);
+}
-- 
2.38.1

From 8757cb59b7f9684cb610b292bbf31bac25f0ef4d Mon Sep 17 00:00:00 2001
From: Lulu Cheng <chenglulu@loongson.cn>
Date: Wed, 16 Nov 2022 09:25:14 +0800
Subject: [PATCH 34/36] LoongArch: Add prefetch instructions.

Enable sw prefetching at -O3 and higher.

Co-Authored-By: xujiahao <xujiahao@loongson.cn>

gcc/ChangeLog:

	* config/loongarch/constraints.md (ZD): New constraint.
	* config/loongarch/loongarch-def.c: Initial number of parallel prefetch.
	* config/loongarch/loongarch-tune.h (struct loongarch_cache):
	Define number of parallel prefetch.
	* config/loongarch/loongarch.cc (loongarch_option_override_internal):
	Set up parameters to be used in prefetching algorithm.
	* config/loongarch/loongarch.md (prefetch): New template.
---
 gcc/config/loongarch/constraints.md   | 10 ++++++++++
 gcc/config/loongarch/loongarch-def.c  |  2 ++
 gcc/config/loongarch/loongarch-tune.h |  1 +
 gcc/config/loongarch/loongarch.cc     | 28 +++++++++++++++++++++++++++
 gcc/config/loongarch/loongarch.md     | 14 ++++++++++++++
 5 files changed, 55 insertions(+)

diff --git a/gcc/config/loongarch/constraints.md b/gcc/config/loongarch/constraints.md
index 43cb7b5f0f5..46f7f63ae31 100644
--- a/gcc/config/loongarch/constraints.md
+++ b/gcc/config/loongarch/constraints.md
@@ -86,6 +86,10 @@
 ;;    "ZB"
 ;;      "An address that is held in a general-purpose register.
 ;;      The offset is zero"
+;;    "ZD"
+;;	"An address operand whose address is formed by a base register
+;;	 and offset that is suitable for use in instructions with the same
+;;	 addressing mode as @code{preld}."
 ;; "<" "Matches a pre-dec or post-dec operand." (Global non-architectural)
 ;; ">" "Matches a pre-inc or post-inc operand." (Global non-architectural)
 
@@ -190,3 +194,9 @@
   The offset is zero"
   (and (match_code "mem")
        (match_test "REG_P (XEXP (op, 0))")))
+
+(define_address_constraint "ZD"
+  "An address operand whose address is formed by a base register
+   and offset that is suitable for use in instructions with the same
+   addressing mode as @code{preld}."
+   (match_test "loongarch_12bit_offset_address_p (op, mode)"))
diff --git a/gcc/config/loongarch/loongarch-def.c b/gcc/config/loongarch/loongarch-def.c
index cbf995d81b5..80ab10a52a8 100644
--- a/gcc/config/loongarch/loongarch-def.c
+++ b/gcc/config/loongarch/loongarch-def.c
@@ -62,11 +62,13 @@ loongarch_cpu_cache[N_TUNE_TYPES] = {
       .l1d_line_size = 64,
       .l1d_size = 64,
       .l2d_size = 256,
+      .simultaneous_prefetches = 4,
   },
   [CPU_LA464] = {
       .l1d_line_size = 64,
       .l1d_size = 64,
       .l2d_size = 256,
+      .simultaneous_prefetches = 4,
   },
 };
 
diff --git a/gcc/config/loongarch/loongarch-tune.h b/gcc/config/loongarch/loongarch-tune.h
index 6f3530f5c02..8e3eb29472b 100644
--- a/gcc/config/loongarch/loongarch-tune.h
+++ b/gcc/config/loongarch/loongarch-tune.h
@@ -45,6 +45,7 @@ struct loongarch_cache {
     int l1d_line_size;  /* bytes */
     int l1d_size;       /* KiB */
     int l2d_size;       /* kiB */
+    int simultaneous_prefetches; /* number of parallel prefetch */
 };
 
 #endif /* LOONGARCH_TUNE_H */
diff --git a/gcc/config/loongarch/loongarch.cc b/gcc/config/loongarch/loongarch.cc
index d552b162ae9..622c9435b3b 100644
--- a/gcc/config/loongarch/loongarch.cc
+++ b/gcc/config/loongarch/loongarch.cc
@@ -63,6 +63,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "context.h"
 #include "builtins.h"
 #include "rtl-iter.h"
+#include "opts.h"
 
 /* This file should be included last.  */
 #include "target-def.h"
@@ -6099,6 +6100,33 @@ loongarch_option_override_internal (struct gcc_options *opts)
   if (loongarch_branch_cost == 0)
     loongarch_branch_cost = loongarch_cost->branch_cost;
 
+  /* Set up parameters to be used in prefetching algorithm.  */
+  int simultaneous_prefetches
+    = loongarch_cpu_cache[LARCH_ACTUAL_TUNE].simultaneous_prefetches;
+
+  SET_OPTION_IF_UNSET (opts, &global_options_set,
+		       param_simultaneous_prefetches,
+		       simultaneous_prefetches);
+
+  SET_OPTION_IF_UNSET (opts, &global_options_set,
+		       param_l1_cache_line_size,
+		       loongarch_cpu_cache[LARCH_ACTUAL_TUNE].l1d_line_size);
+
+  SET_OPTION_IF_UNSET (opts, &global_options_set,
+		       param_l1_cache_size,
+		       loongarch_cpu_cache[LARCH_ACTUAL_TUNE].l1d_size);
+
+  SET_OPTION_IF_UNSET (opts, &global_options_set,
+		       param_l2_cache_size,
+		       loongarch_cpu_cache[LARCH_ACTUAL_TUNE].l2d_size);
+
+
+  /* Enable sw prefetching at -O3 and higher.  */
+  if (opts->x_flag_prefetch_loop_arrays < 0
+      && (opts->x_optimize >= 3 || opts->x_flag_profile_use)
+      && !opts->x_optimize_size)
+    opts->x_flag_prefetch_loop_arrays = 1;
+
   if (TARGET_DIRECT_EXTERN_ACCESS && flag_shlib)
     error ("%qs cannot be used for compiling a shared library",
 	   "-mdirect-extern-access");
diff --git a/gcc/config/loongarch/loongarch.md b/gcc/config/loongarch/loongarch.md
index 682ab961741..2fda5381904 100644
--- a/gcc/config/loongarch/loongarch.md
+++ b/gcc/config/loongarch/loongarch.md
@@ -3282,6 +3282,20 @@
 ;;  ....................
 ;;
 
+(define_insn "prefetch"
+  [(prefetch (match_operand 0 "address_operand" "ZD")
+	     (match_operand 1 "const_int_operand" "n")
+	     (match_operand 2 "const_int_operand" "n"))]
+  ""
+{
+  switch (INTVAL (operands[1]))
+  {
+    case 0: return "preld\t0,%a0";
+    case 1: return "preld\t8,%a0";
+    default: gcc_unreachable ();
+  }
+})
+
 (define_insn "nop"
   [(const_int 0)]
   ""
-- 
2.38.1

From a532648008c86d09152d9168a08e5ba2ad30b4dc Mon Sep 17 00:00:00 2001
From: Lulu Cheng <chenglulu@loongson.cn>
Date: Thu, 17 Nov 2022 17:08:36 +0800
Subject: [PATCH 35/36] LoongArch: Optimize immediate load.

The immediate number is split in the Split pass, not in the expand pass.

Because loop2_invariant pass will extract the instructions that do not change
in the loop out of the loop, some instructions will not meet the extraction
conditions if the machine performs immediate decomposition while expand pass,
so the immediate decomposition will be transferred to the split process.

gcc/ChangeLog:

	* config/loongarch/loongarch.cc (enum loongarch_load_imm_method):
	Remove the member METHOD_INSV that is not currently used.
	(struct loongarch_integer_op): Define a new member curr_value,
	that records the value of the number stored in the destination
	register immediately after the current instruction has run.
	(loongarch_build_integer): Assign a value to the curr_value member variable.
	(loongarch_move_integer): Adds information for the immediate load instruction.
	* config/loongarch/loongarch.md (*movdi_32bit): Redefine as define_insn_and_split.
	(*movdi_64bit): Likewise.
	(*movsi_internal): Likewise.
	(*movhi_internal): Likewise.
	* config/loongarch/predicates.md: Return true as long as it is CONST_INT, ensure
	that the immediate number is not optimized by decomposition during expand
	optimization loop.

gcc/testsuite/ChangeLog:

	* gcc.target/loongarch/imm-load.c: New test.
	* gcc.target/loongarch/imm-load1.c: New test.
---
 gcc/config/loongarch/loongarch.cc             | 62 ++++++++++---------
 gcc/config/loongarch/loongarch.md             | 44 +++++++++++--
 gcc/config/loongarch/predicates.md            |  2 +-
 gcc/testsuite/gcc.target/loongarch/imm-load.c | 10 +++
 .../gcc.target/loongarch/imm-load1.c          | 26 ++++++++
 5 files changed, 110 insertions(+), 34 deletions(-)
 create mode 100644 gcc/testsuite/gcc.target/loongarch/imm-load.c
 create mode 100644 gcc/testsuite/gcc.target/loongarch/imm-load1.c

diff --git a/gcc/config/loongarch/loongarch.cc b/gcc/config/loongarch/loongarch.cc
index 622c9435b3b..f45a49f9057 100644
--- a/gcc/config/loongarch/loongarch.cc
+++ b/gcc/config/loongarch/loongarch.cc
@@ -139,22 +139,21 @@ struct loongarch_address_info
 
    METHOD_LU52I:
      Load 52-63 bit of the immediate number.
-
-   METHOD_INSV:
-     immediate like 0xfff00000fffffxxx
-   */
+*/
 enum loongarch_load_imm_method
 {
   METHOD_NORMAL,
   METHOD_LU32I,
-  METHOD_LU52I,
-  METHOD_INSV
+  METHOD_LU52I
 };
 
 struct loongarch_integer_op
 {
   enum rtx_code code;
   HOST_WIDE_INT value;
+  /* Represent the result of the immediate count of the load instruction at
+     each step.  */
+  HOST_WIDE_INT curr_value;
   enum loongarch_load_imm_method method;
 };
 
@@ -1474,24 +1473,27 @@ loongarch_build_integer (struct loongarch_integer_op *codes,
     {
       /* The value of the lower 32 bit be loaded with one instruction.
 	 lu12i.w.  */
-      codes[0].code = UNKNOWN;
-      codes[0].method = METHOD_NORMAL;
-      codes[0].value = low_part;
+      codes[cost].code = UNKNOWN;
+      codes[cost].method = METHOD_NORMAL;
+      codes[cost].value = low_part;
+      codes[cost].curr_value = low_part;
       cost++;
     }
   else
     {
       /* lu12i.w + ior.  */
-      codes[0].code = UNKNOWN;
-      codes[0].method = METHOD_NORMAL;
-      codes[0].value = low_part & ~(IMM_REACH - 1);
+      codes[cost].code = UNKNOWN;
+      codes[cost].method = METHOD_NORMAL;
+      codes[cost].value = low_part & ~(IMM_REACH - 1);
+      codes[cost].curr_value = codes[cost].value;
       cost++;
       HOST_WIDE_INT iorv = low_part & (IMM_REACH - 1);
       if (iorv != 0)
 	{
-	  codes[1].code = IOR;
-	  codes[1].method = METHOD_NORMAL;
-	  codes[1].value = iorv;
+	  codes[cost].code = IOR;
+	  codes[cost].method = METHOD_NORMAL;
+	  codes[cost].value = iorv;
+	  codes[cost].curr_value = low_part;
 	  cost++;
 	}
     }
@@ -1514,11 +1516,14 @@ loongarch_build_integer (struct loongarch_integer_op *codes,
 	{
 	  codes[cost].method = METHOD_LU52I;
 	  codes[cost].value = value & LU52I_B;
+	  codes[cost].curr_value = value;
 	  return cost + 1;
 	}
 
       codes[cost].method = METHOD_LU32I;
       codes[cost].value = (value & LU32I_B) | (sign51 ? LU52I_B : 0);
+      codes[cost].curr_value = (value & 0xfffffffffffff)
+	| (sign51 ? LU52I_B : 0);
       cost++;
 
       /* Determine whether the 52-61 bits are sign-extended from the low order,
@@ -1527,6 +1532,7 @@ loongarch_build_integer (struct loongarch_integer_op *codes,
 	{
 	  codes[cost].method = METHOD_LU52I;
 	  codes[cost].value = value & LU52I_B;
+	  codes[cost].curr_value = value;
 	  cost++;
 	}
     }
@@ -2910,6 +2916,9 @@ loongarch_move_integer (rtx temp, rtx dest, unsigned HOST_WIDE_INT value)
       else
 	x = force_reg (mode, x);
 
+      set_unique_reg_note (get_last_insn (), REG_EQUAL,
+			   GEN_INT (codes[i-1].curr_value));
+
       switch (codes[i].method)
 	{
 	case METHOD_NORMAL:
@@ -2917,22 +2926,17 @@ loongarch_move_integer (rtx temp, rtx dest, unsigned HOST_WIDE_INT value)
 			      GEN_INT (codes[i].value));
 	  break;
 	case METHOD_LU32I:
-	  emit_insn (
-	    gen_rtx_SET (x,
-			 gen_rtx_IOR (DImode,
-				      gen_rtx_ZERO_EXTEND (
-					DImode, gen_rtx_SUBREG (SImode, x, 0)),
-				      GEN_INT (codes[i].value))));
+	  gcc_assert (mode == DImode);
+	  x = gen_rtx_IOR (DImode,
+			   gen_rtx_ZERO_EXTEND (DImode,
+						gen_rtx_SUBREG (SImode, x, 0)),
+			   GEN_INT (codes[i].value));
 	  break;
 	case METHOD_LU52I:
-	  emit_insn (gen_lu52i_d (x, x, GEN_INT (0xfffffffffffff),
-				  GEN_INT (codes[i].value)));
-	  break;
-	case METHOD_INSV:
-	  emit_insn (
-	    gen_rtx_SET (gen_rtx_ZERO_EXTRACT (DImode, x, GEN_INT (20),
-					       GEN_INT (32)),
-			 gen_rtx_REG (DImode, 0)));
+	  gcc_assert (mode == DImode);
+	  x = gen_rtx_IOR (DImode,
+			   gen_rtx_AND (DImode, x, GEN_INT (0xfffffffffffff)),
+			   GEN_INT (codes[i].value));
 	  break;
 	default:
 	  gcc_unreachable ();
diff --git a/gcc/config/loongarch/loongarch.md b/gcc/config/loongarch/loongarch.md
index 2fda5381904..f61db66d535 100644
--- a/gcc/config/loongarch/loongarch.md
+++ b/gcc/config/loongarch/loongarch.md
@@ -1718,23 +1718,41 @@
     DONE;
 })
 
-(define_insn "*movdi_32bit"
+(define_insn_and_split "*movdi_32bit"
   [(set (match_operand:DI 0 "nonimmediate_operand" "=r,r,r,w,*f,*f,*r,*m")
        (match_operand:DI 1 "move_operand" "r,i,w,r,*J*r,*m,*f,*f"))]
   "!TARGET_64BIT
    && (register_operand (operands[0], DImode)
        || reg_or_0_operand (operands[1], DImode))"
   { return loongarch_output_move (operands[0], operands[1]); }
+  "CONST_INT_P (operands[1]) && REG_P (operands[0]) && GP_REG_P (REGNO
+  (operands[0]))"
+  [(const_int 0)]
+  "
+{
+  loongarch_move_integer (operands[0], operands[0], INTVAL (operands[1]));
+  DONE;
+}
+  "
   [(set_attr "move_type" "move,const,load,store,mgtf,fpload,mftg,fpstore")
    (set_attr "mode" "DI")])
 
-(define_insn "*movdi_64bit"
+(define_insn_and_split "*movdi_64bit"
   [(set (match_operand:DI 0 "nonimmediate_operand" "=r,r,r,w,*f,*f,*r,*m")
 	(match_operand:DI 1 "move_operand" "r,Yd,w,rJ,*r*J,*m,*f,*f"))]
   "TARGET_64BIT
    && (register_operand (operands[0], DImode)
        || reg_or_0_operand (operands[1], DImode))"
   { return loongarch_output_move (operands[0], operands[1]); }
+  "CONST_INT_P (operands[1]) && REG_P (operands[0]) && GP_REG_P (REGNO
+  (operands[0]))"
+  [(const_int 0)]
+  "
+{
+  loongarch_move_integer (operands[0], operands[0], INTVAL (operands[1]));
+  DONE;
+}
+  "
   [(set_attr "move_type" "move,const,load,store,mgtf,fpload,mftg,fpstore")
    (set_attr "mode" "DI")])
 
@@ -1749,12 +1767,21 @@
     DONE;
 })
 
-(define_insn "*movsi_internal"
+(define_insn_and_split "*movsi_internal"
   [(set (match_operand:SI 0 "nonimmediate_operand" "=r,r,r,w,*f,*f,*r,*m,*r,*z")
 	(match_operand:SI 1 "move_operand" "r,Yd,w,rJ,*r*J,*m,*f,*f,*z,*r"))]
   "(register_operand (operands[0], SImode)
     || reg_or_0_operand (operands[1], SImode))"
   { return loongarch_output_move (operands[0], operands[1]); }
+  "CONST_INT_P (operands[1]) && REG_P (operands[0]) && GP_REG_P (REGNO
+  (operands[0]))"
+  [(const_int 0)]
+  "
+{
+  loongarch_move_integer (operands[0], operands[0], INTVAL (operands[1]));
+  DONE;
+}
+  "
   [(set_attr "move_type" "move,const,load,store,mgtf,fpload,mftg,fpstore,mftg,mgtf")
    (set_attr "mode" "SI")])
 
@@ -1774,12 +1801,21 @@
     DONE;
 })
 
-(define_insn "*movhi_internal"
+(define_insn_and_split "*movhi_internal"
   [(set (match_operand:HI 0 "nonimmediate_operand" "=r,r,r,r,m,r,k")
 	(match_operand:HI 1 "move_operand" "r,Yd,I,m,rJ,k,rJ"))]
   "(register_operand (operands[0], HImode)
        || reg_or_0_operand (operands[1], HImode))"
   { return loongarch_output_move (operands[0], operands[1]); }
+  "CONST_INT_P (operands[1]) && REG_P (operands[0]) && GP_REG_P (REGNO
+  (operands[0]))"
+  [(const_int 0)]
+  "
+{
+  loongarch_move_integer (operands[0], operands[0], INTVAL (operands[1]));
+  DONE;
+}
+  "
   [(set_attr "move_type" "move,const,const,load,store,load,store")
    (set_attr "mode" "HI")])
 
diff --git a/gcc/config/loongarch/predicates.md b/gcc/config/loongarch/predicates.md
index 8bd0c1376c9..58c3dc2261c 100644
--- a/gcc/config/loongarch/predicates.md
+++ b/gcc/config/loongarch/predicates.md
@@ -226,7 +226,7 @@
   switch (GET_CODE (op))
     {
     case CONST_INT:
-      return !splittable_const_int_operand (op, mode);
+      return true;
 
     case CONST:
     case SYMBOL_REF:
diff --git a/gcc/testsuite/gcc.target/loongarch/imm-load.c b/gcc/testsuite/gcc.target/loongarch/imm-load.c
new file mode 100644
index 00000000000..c04ca33996f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/imm-load.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-mabi=lp64d -O2 -fdump-rtl-split1" } */
+
+long int
+test (void)
+{
+  return 0x1234567890abcdef;
+}
+/* { dg-final { scan-rtl-dump-times "scanning new insn with uid" 6 "split1" } } */
+
diff --git a/gcc/testsuite/gcc.target/loongarch/imm-load1.c b/gcc/testsuite/gcc.target/loongarch/imm-load1.c
new file mode 100644
index 00000000000..2ff02971239
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/imm-load1.c
@@ -0,0 +1,26 @@
+/* { dg-do compile } */
+/* { dg-options "-mabi=lp64d -O2" } */
+/* { dg-final { scan-assembler "test:.*lu52i\.d.*\n\taddi\.w.*\n\.L2:" } } */
+
+
+extern long long b[10];
+static inline long long
+repeat_bytes (void)
+{
+  long long r = 0x0101010101010101;
+
+  return r;
+}
+
+static inline long long
+highbit_mask (long long m)
+{
+  return m & repeat_bytes ();
+}
+
+void test(long long *a)
+{
+  for (int i = 0; i < 10; i++)
+    b[i] = highbit_mask (a[i]);
+
+}
-- 
2.38.1

From 34c62acb10adc4971a303fb5c9354e705c079dad Mon Sep 17 00:00:00 2001
From: Lulu Cheng <chenglulu@loongson.cn>
Date: Tue, 29 Nov 2022 16:06:12 +0800
Subject: [PATCH 36/36] LoongArch: Optimize the implementation of stack check.

The old stack check was performed before the stack was dropped,
which would cause the detection tool to report a memory leak.

The current stack check scheme is as follows:

'-fstack-clash-protection':
1. When the frame->total_size is smaller than the guard page size,
   the stack is dropped according to the original scheme, and there
   is no need to perform stack detection in the prologue.
2. When frame->total_size is greater than or equal to guard page size,
   the first step to drop the stack is to drop the space required by
   the caller-save registers. This space needs to save the caller-save
   registers, so an implicit stack check is performed.
   So just need to check the rest of the stack space.

'-fstack-check':
There is no one-time stack drop and then page-by-page detection as
described in the document. It is also the same as
'-fstack-clash-protection', which is detected immediately after page drop.

It is judged that when frame->total_size is not 0, only the size required
to save the s register is dropped for the first stack down.

The test cases are referenced from aarch64.

gcc/ChangeLog:

	* config/loongarch/linux.h (STACK_CHECK_MOVING_SP):
	Define this macro to 1.
	* config/loongarch/loongarch.cc (STACK_CLASH_PROTECTION_GUARD_SIZE):
	Size of guard page.
	(loongarch_first_stack_step): Return the size of the first drop stack
	according to whether stack checking is performed.
	(loongarch_emit_probe_stack_range): Adjust the method of stack checking in prologue.
	(loongarch_output_probe_stack_range): Delete useless code.
	(loongarch_expand_prologue): Adjust the method of stack checking in prologue.
	(loongarch_option_override_internal): Enforce that interval is the same
	size as size so the mid-end does the right thing.
	* config/loongarch/loongarch.h (STACK_CLASH_MAX_UNROLL_PAGES):
	New macro decide whether to loop stack detection.

gcc/testsuite/ChangeLog:

	* lib/target-supports.exp:
	* gcc.target/loongarch/stack-check-alloca-1.c: New test.
	* gcc.target/loongarch/stack-check-alloca-2.c: New test.
	* gcc.target/loongarch/stack-check-alloca-3.c: New test.
	* gcc.target/loongarch/stack-check-alloca-4.c: New test.
	* gcc.target/loongarch/stack-check-alloca-5.c: New test.
	* gcc.target/loongarch/stack-check-alloca-6.c: New test.
	* gcc.target/loongarch/stack-check-alloca.h: New test.
	* gcc.target/loongarch/stack-check-cfa-1.c: New test.
	* gcc.target/loongarch/stack-check-cfa-2.c: New test.
	* gcc.target/loongarch/stack-check-prologue-1.c: New test.
	* gcc.target/loongarch/stack-check-prologue-2.c: New test.
	* gcc.target/loongarch/stack-check-prologue-3.c: New test.
	* gcc.target/loongarch/stack-check-prologue-4.c: New test.
	* gcc.target/loongarch/stack-check-prologue-5.c: New test.
	* gcc.target/loongarch/stack-check-prologue-6.c: New test.
	* gcc.target/loongarch/stack-check-prologue-7.c: New test.
	* gcc.target/loongarch/stack-check-prologue.h: New test.
---
 gcc/config/loongarch/linux.h                  |   3 +
 gcc/config/loongarch/loongarch.cc             | 248 +++++++++++-------
 gcc/config/loongarch/loongarch.h              |   4 +
 .../loongarch/stack-check-alloca-1.c          |  15 ++
 .../loongarch/stack-check-alloca-2.c          |  12 +
 .../loongarch/stack-check-alloca-3.c          |  12 +
 .../loongarch/stack-check-alloca-4.c          |  12 +
 .../loongarch/stack-check-alloca-5.c          |  13 +
 .../loongarch/stack-check-alloca-6.c          |  13 +
 .../gcc.target/loongarch/stack-check-alloca.h |  15 ++
 .../gcc.target/loongarch/stack-check-cfa-1.c  |  12 +
 .../gcc.target/loongarch/stack-check-cfa-2.c  |  12 +
 .../loongarch/stack-check-prologue-1.c        |  11 +
 .../loongarch/stack-check-prologue-2.c        |  11 +
 .../loongarch/stack-check-prologue-3.c        |  11 +
 .../loongarch/stack-check-prologue-4.c        |  11 +
 .../loongarch/stack-check-prologue-5.c        |  12 +
 .../loongarch/stack-check-prologue-6.c        |  11 +
 .../loongarch/stack-check-prologue-7.c        |  12 +
 .../loongarch/stack-check-prologue.h          |   5 +
 gcc/testsuite/lib/target-supports.exp         |   7 +-
 21 files changed, 361 insertions(+), 101 deletions(-)
 create mode 100644 gcc/testsuite/gcc.target/loongarch/stack-check-alloca-1.c
 create mode 100644 gcc/testsuite/gcc.target/loongarch/stack-check-alloca-2.c
 create mode 100644 gcc/testsuite/gcc.target/loongarch/stack-check-alloca-3.c
 create mode 100644 gcc/testsuite/gcc.target/loongarch/stack-check-alloca-4.c
 create mode 100644 gcc/testsuite/gcc.target/loongarch/stack-check-alloca-5.c
 create mode 100644 gcc/testsuite/gcc.target/loongarch/stack-check-alloca-6.c
 create mode 100644 gcc/testsuite/gcc.target/loongarch/stack-check-alloca.h
 create mode 100644 gcc/testsuite/gcc.target/loongarch/stack-check-cfa-1.c
 create mode 100644 gcc/testsuite/gcc.target/loongarch/stack-check-cfa-2.c
 create mode 100644 gcc/testsuite/gcc.target/loongarch/stack-check-prologue-1.c
 create mode 100644 gcc/testsuite/gcc.target/loongarch/stack-check-prologue-2.c
 create mode 100644 gcc/testsuite/gcc.target/loongarch/stack-check-prologue-3.c
 create mode 100644 gcc/testsuite/gcc.target/loongarch/stack-check-prologue-4.c
 create mode 100644 gcc/testsuite/gcc.target/loongarch/stack-check-prologue-5.c
 create mode 100644 gcc/testsuite/gcc.target/loongarch/stack-check-prologue-6.c
 create mode 100644 gcc/testsuite/gcc.target/loongarch/stack-check-prologue-7.c
 create mode 100644 gcc/testsuite/gcc.target/loongarch/stack-check-prologue.h

diff --git a/gcc/config/loongarch/linux.h b/gcc/config/loongarch/linux.h
index 110d0fab93d..00039ac1871 100644
--- a/gcc/config/loongarch/linux.h
+++ b/gcc/config/loongarch/linux.h
@@ -48,3 +48,6 @@ along with GCC; see the file COPYING3.  If not see
 #define STACK_CHECK_PROTECT (TARGET_64BIT ? 16 * 1024 : 12 * 1024)
 
 #define TARGET_ASM_FILE_END file_end_indicate_exec_stack
+
+/* The stack pointer needs to be moved while checking the stack.  */
+#define STACK_CHECK_MOVING_SP 1
diff --git a/gcc/config/loongarch/loongarch.cc b/gcc/config/loongarch/loongarch.cc
index f45a49f9057..e59edc4cd5e 100644
--- a/gcc/config/loongarch/loongarch.cc
+++ b/gcc/config/loongarch/loongarch.cc
@@ -257,6 +257,10 @@ const char *const
 loongarch_fp_conditions[16]= {LARCH_FP_CONDITIONS (STRINGIFY)};
 #undef STRINGIFY
 
+/* Size of guard page.  */
+#define STACK_CLASH_PROTECTION_GUARD_SIZE \
+  (1 << param_stack_clash_protection_guard_size)
+
 /* Implement TARGET_FUNCTION_ARG_BOUNDARY.  Every parameter gets at
    least PARM_BOUNDARY bits of alignment, but will be given anything up
    to PREFERRED_STACK_BOUNDARY bits if the type requires it.  */
@@ -1069,11 +1073,20 @@ loongarch_restore_reg (rtx reg, rtx mem)
 static HOST_WIDE_INT
 loongarch_first_stack_step (struct loongarch_frame_info *frame)
 {
+  HOST_WIDE_INT min_first_step
+    = LARCH_STACK_ALIGN (frame->total_size - frame->fp_sp_offset);
+
+  /* When stack checking is required, if the sum of frame->total_size
+     and stack_check_protect is greater than stack clash protection guard
+     size, then return min_first_step.  */
+  if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK
+      || (flag_stack_clash_protection
+	  && frame->total_size > STACK_CLASH_PROTECTION_GUARD_SIZE))
+    return min_first_step;
+
   if (IMM12_OPERAND (frame->total_size))
     return frame->total_size;
 
-  HOST_WIDE_INT min_first_step
-    = LARCH_STACK_ALIGN (frame->total_size - frame->fp_sp_offset);
   HOST_WIDE_INT max_first_step = IMM_REACH / 2 - PREFERRED_STACK_BOUNDARY / 8;
   HOST_WIDE_INT min_second_step = frame->total_size - max_first_step;
   gcc_assert (min_first_step <= max_first_step);
@@ -1106,103 +1119,109 @@ loongarch_emit_stack_tie (void)
 static void
 loongarch_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)
 {
-  /* See if we have a constant small number of probes to generate.  If so,
-     that's the easy case.  */
-  if ((TARGET_64BIT && (first + size <= 32768))
-      || (!TARGET_64BIT && (first + size <= 2048)))
-    {
-      HOST_WIDE_INT i;
+  HOST_WIDE_INT rounded_size;
+  HOST_WIDE_INT interval;
 
-      /* Probe at FIRST + N * PROBE_INTERVAL for values of N from 1 until
-	 it exceeds SIZE.  If only one probe is needed, this will not
-	 generate any code.  Then probe at FIRST + SIZE.  */
-      for (i = PROBE_INTERVAL; i < size; i += PROBE_INTERVAL)
-	emit_stack_probe (plus_constant (Pmode, stack_pointer_rtx,
-					 -(first + i)));
+  if (flag_stack_clash_protection)
+    interval = STACK_CLASH_PROTECTION_GUARD_SIZE;
+  else
+    interval = PROBE_INTERVAL;
 
-      emit_stack_probe (plus_constant (Pmode, stack_pointer_rtx,
-				       -(first + size)));
-    }
+  rtx r12 = LARCH_PROLOGUE_TEMP2 (Pmode);
+  rtx r14 = LARCH_PROLOGUE_TEMP3 (Pmode);
 
-  /* Otherwise, do the same as above, but in a loop.  Note that we must be
-     extra careful with variables wrapping around because we might be at
-     the very top (or the very bottom) of the address space and we have
-     to be able to handle this case properly; in particular, we use an
-     equality test for the loop condition.  */
-  else
-    {
-      HOST_WIDE_INT rounded_size;
-      rtx r13 = LARCH_PROLOGUE_TEMP (Pmode);
-      rtx r12 = LARCH_PROLOGUE_TEMP2 (Pmode);
-      rtx r14 = LARCH_PROLOGUE_TEMP3 (Pmode);
+  size = size + first;
 
-      /* Sanity check for the addressing mode we're going to use.  */
-      gcc_assert (first <= 16384);
+  /* Sanity check for the addressing mode we're going to use.  */
+  gcc_assert (first <= 16384);
 
+  /* Step 1: round SIZE to the previous multiple of the interval.  */
 
-      /* Step 1: round SIZE to the previous multiple of the interval.  */
+  rounded_size = ROUND_DOWN (size, interval);
 
-      rounded_size = ROUND_DOWN (size, PROBE_INTERVAL);
+  /* Step 2: compute initial and final value of the loop counter.  */
 
-      /* TEST_ADDR = SP + FIRST */
-      if (first != 0)
-	{
-	  emit_move_insn (r14, GEN_INT (first));
-	  emit_insn (gen_rtx_SET (r13, gen_rtx_MINUS (Pmode,
-						      stack_pointer_rtx,
-						      r14)));
-	}
-      else
-	emit_move_insn (r13, stack_pointer_rtx);
+  emit_move_insn (r14, GEN_INT (interval));
+
+  /* If rounded_size is zero, it means that the space requested by
+     the local variable is less than the interval, and there is no
+     need to display and detect the allocated space.  */
+  if (rounded_size != 0)
+    {
+      /* Step 3: the loop
+
+	 do
+	 {
+	 TEST_ADDR = TEST_ADDR + PROBE_INTERVAL
+	 probe at TEST_ADDR
+	 }
+	 while (TEST_ADDR != LAST_ADDR)
 
-      /* Step 2: compute initial and final value of the loop counter.  */
+	 probes at FIRST + N * PROBE_INTERVAL for values of N from 1
+	 until it is equal to ROUNDED_SIZE.  */
 
-      emit_move_insn (r14, GEN_INT (PROBE_INTERVAL));
-      /* LAST_ADDR = SP + FIRST + ROUNDED_SIZE.  */
-      if (rounded_size == 0)
-	emit_move_insn (r12, r13);
+      if (rounded_size <= STACK_CLASH_MAX_UNROLL_PAGES * interval)
+	{
+	  for (HOST_WIDE_INT i = 0; i < rounded_size; i += interval)
+	    {
+	      emit_insn (gen_rtx_SET (stack_pointer_rtx,
+				      gen_rtx_MINUS (Pmode,
+						     stack_pointer_rtx,
+						     r14)));
+	      emit_move_insn (gen_rtx_MEM (Pmode,
+					   gen_rtx_PLUS (Pmode,
+							 stack_pointer_rtx,
+							 const0_rtx)),
+			      const0_rtx);
+	      emit_insn (gen_blockage ());
+	    }
+	  dump_stack_clash_frame_info (PROBE_INLINE, size != rounded_size);
+	}
       else
 	{
 	  emit_move_insn (r12, GEN_INT (rounded_size));
-	  emit_insn (gen_rtx_SET (r12, gen_rtx_MINUS (Pmode, r13, r12)));
-	  /* Step 3: the loop
-
-	     do
-	     {
-	     TEST_ADDR = TEST_ADDR + PROBE_INTERVAL
-	     probe at TEST_ADDR
-	     }
-	     while (TEST_ADDR != LAST_ADDR)
-
-	     probes at FIRST + N * PROBE_INTERVAL for values of N from 1
-	     until it is equal to ROUNDED_SIZE.  */
-
-	  emit_insn (gen_probe_stack_range (Pmode, r13, r13, r12, r14));
+	  emit_insn (gen_rtx_SET (r12,
+				  gen_rtx_MINUS (Pmode,
+						 stack_pointer_rtx,
+						 r12)));
+
+	  emit_insn (gen_probe_stack_range (Pmode, stack_pointer_rtx,
+					    stack_pointer_rtx, r12, r14));
+	  emit_insn (gen_blockage ());
+	  dump_stack_clash_frame_info (PROBE_LOOP, size != rounded_size);
 	}
+    }
+  else
+    dump_stack_clash_frame_info (NO_PROBE_SMALL_FRAME, true);
+
 
-      /* Step 4: probe at FIRST + SIZE if we cannot assert at compile-time
-	 that SIZE is equal to ROUNDED_SIZE.  */
+  /* Step 4: probe at FIRST + SIZE if we cannot assert at compile-time
+     that SIZE is equal to ROUNDED_SIZE.  */
 
-      if (size != rounded_size)
+  if (size != rounded_size)
+    {
+      if (size - rounded_size >= 2048)
 	{
-	  if (TARGET_64BIT)
-	    emit_stack_probe (plus_constant (Pmode, r12, rounded_size - size));
-	  else
-	    {
-	      HOST_WIDE_INT i;
-	      for (i = 2048; i < (size - rounded_size); i += 2048)
-		{
-		  emit_stack_probe (plus_constant (Pmode, r12, -i));
-		  emit_insn (gen_rtx_SET (r12,
-					  plus_constant (Pmode, r12, -2048)));
-		}
-	      rtx r1 = plus_constant (Pmode, r12,
-				      -(size - rounded_size - i + 2048));
-	      emit_stack_probe (r1);
-	    }
+	  emit_move_insn (r14, GEN_INT (size - rounded_size));
+	  emit_insn (gen_rtx_SET (stack_pointer_rtx,
+				  gen_rtx_MINUS (Pmode,
+						 stack_pointer_rtx,
+						 r14)));
 	}
+      else
+	emit_insn (gen_rtx_SET (stack_pointer_rtx,
+				gen_rtx_PLUS (Pmode,
+					      stack_pointer_rtx,
+					      GEN_INT (rounded_size - size))));
     }
 
+  if (first)
+    {
+      emit_move_insn (r12, GEN_INT (first));
+      emit_insn (gen_rtx_SET (stack_pointer_rtx,
+			      gen_rtx_PLUS (Pmode,
+					    stack_pointer_rtx, r12)));
+    }
   /* Make sure nothing is scheduled before we are done.  */
   emit_insn (gen_blockage ());
 }
@@ -1223,7 +1242,6 @@ loongarch_output_probe_stack_range (rtx reg1, rtx reg2, rtx reg3)
 
   /* TEST_ADDR = TEST_ADDR + PROBE_INTERVAL.  */
   xops[0] = reg1;
-  xops[1] = GEN_INT (-PROBE_INTERVAL);
   xops[2] = reg3;
   if (TARGET_64BIT)
     output_asm_insn ("sub.d\t%0,%0,%2", xops);
@@ -1249,28 +1267,11 @@ loongarch_expand_prologue (void)
 {
   struct loongarch_frame_info *frame = &cfun->machine->frame;
   HOST_WIDE_INT size = frame->total_size;
-  HOST_WIDE_INT tmp;
   rtx insn;
 
   if (flag_stack_usage_info)
     current_function_static_stack_size = size;
 
-  if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK
-      || flag_stack_clash_protection)
-    {
-      if (crtl->is_leaf && !cfun->calls_alloca)
-	{
-	  if (size > PROBE_INTERVAL && size > get_stack_check_protect ())
-	    {
-	      tmp = size - get_stack_check_protect ();
-	      loongarch_emit_probe_stack_range (get_stack_check_protect (),
-						tmp);
-	    }
-	}
-      else if (size > 0)
-	loongarch_emit_probe_stack_range (get_stack_check_protect (), size);
-    }
-
   /* Save the registers.  */
   if ((frame->mask | frame->fmask) != 0)
     {
@@ -1283,7 +1284,6 @@ loongarch_expand_prologue (void)
       loongarch_for_each_saved_reg (size, loongarch_save_reg);
     }
 
-
   /* Set up the frame pointer, if we're using one.  */
   if (frame_pointer_needed)
     {
@@ -1294,7 +1294,45 @@ loongarch_expand_prologue (void)
       loongarch_emit_stack_tie ();
     }
 
-  /* Allocate the rest of the frame.  */
+  if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK
+       || flag_stack_clash_protection)
+    {
+      HOST_WIDE_INT first = get_stack_check_protect ();
+
+      if (frame->total_size == 0)
+	{
+	  /* do nothing.  */
+	  dump_stack_clash_frame_info (NO_PROBE_NO_FRAME, false);
+	  return;
+	}
+
+      if (crtl->is_leaf && !cfun->calls_alloca)
+	{
+	  HOST_WIDE_INT interval;
+
+	  if (flag_stack_clash_protection)
+	    interval = STACK_CLASH_PROTECTION_GUARD_SIZE;
+	  else
+	    interval = PROBE_INTERVAL;
+
+	  if (size > interval && size > first)
+	    loongarch_emit_probe_stack_range (first, size - first);
+	  else
+	    loongarch_emit_probe_stack_range (first, size);
+	}
+      else
+	loongarch_emit_probe_stack_range (first, size);
+
+      if (size > 0)
+	{
+	  /* Describe the effect of the previous instructions.  */
+	  insn = plus_constant (Pmode, stack_pointer_rtx, -size);
+	  insn = gen_rtx_SET (stack_pointer_rtx, insn);
+	  loongarch_set_frame_expr (insn);
+	}
+      return;
+    }
+
   if (size > 0)
     {
       if (IMM12_OPERAND (-size))
@@ -1305,7 +1343,8 @@ loongarch_expand_prologue (void)
 	}
       else
 	{
-	  loongarch_emit_move (LARCH_PROLOGUE_TEMP (Pmode), GEN_INT (-size));
+	  loongarch_emit_move (LARCH_PROLOGUE_TEMP (Pmode),
+			       GEN_INT (-size));
 	  emit_insn (gen_add3_insn (stack_pointer_rtx, stack_pointer_rtx,
 				    LARCH_PROLOGUE_TEMP (Pmode)));
 
@@ -6162,6 +6201,15 @@ loongarch_option_override_internal (struct gcc_options *opts)
 	gcc_unreachable ();
     }
 
+  /* Validate the guard size.  */
+  int guard_size = param_stack_clash_protection_guard_size;
+
+  /* Enforce that interval is the same size as size so the mid-end does the
+     right thing.  */
+  SET_OPTION_IF_UNSET (opts, &global_options_set,
+		       param_stack_clash_protection_probe_interval,
+		       guard_size);
+
   loongarch_init_print_operand_punct ();
 
   /* Set up array to map GCC register number to debug register number.
diff --git a/gcc/config/loongarch/loongarch.h b/gcc/config/loongarch/loongarch.h
index f4a9c329fef..a402d3ba35a 100644
--- a/gcc/config/loongarch/loongarch.h
+++ b/gcc/config/loongarch/loongarch.h
@@ -668,6 +668,10 @@ enum reg_class
 
 #define STACK_BOUNDARY (TARGET_ABI_LP64 ? 128 : 64)
 
+/* This value controls how many pages we manually unroll the loop for when
+   generating stack clash probes.  */
+#define STACK_CLASH_MAX_UNROLL_PAGES 4
+
 /* Symbolic macros for the registers used to return integer and floating
    point values.  */
 
diff --git a/gcc/testsuite/gcc.target/loongarch/stack-check-alloca-1.c b/gcc/testsuite/gcc.target/loongarch/stack-check-alloca-1.c
new file mode 100644
index 00000000000..6ee589c4b3d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/stack-check-alloca-1.c
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16" } */
+/* { dg-require-effective-target supports_stack_clash_protection } */
+/* { dg-require-effective-target alloca } */
+/* { dg-skip-if "" { *-*-* } { "-fstack-check" } { "" } } */
+
+#define SIZE y
+#include "stack-check-alloca.h"
+
+/* { dg-final { scan-assembler-times {stp*t*r*\.d\t\$r0,\$r\d{1,2},-8} 1 } } */
+/* { dg-final { scan-assembler-times {stx\.d\t\$r0,\$r3,\$r12} 1 } } */
+
+/* Dynamic alloca, expect loop, and 1 probes with top at sp.
+   1st probe is inside the loop for the full guard-size allocations, second
+   probe is for the case where residual is zero.  */
diff --git a/gcc/testsuite/gcc.target/loongarch/stack-check-alloca-2.c b/gcc/testsuite/gcc.target/loongarch/stack-check-alloca-2.c
new file mode 100644
index 00000000000..8deaa587305
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/stack-check-alloca-2.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16" } */
+/* { dg-require-effective-target supports_stack_clash_protection } */
+/* { dg-require-effective-target alloca } */
+/* { dg-skip-if "" { *-*-* } { "-fstack-check" } { "" } } */
+
+#define SIZE 0
+#include "stack-check-alloca.h"
+
+/* { dg-final { scan-assembler-not {stp*t*r*\.d\t\$r0,\$r3,4088} } } */
+
+/* Alloca of 0 should emit no probes, boundary condition.  */
diff --git a/gcc/testsuite/gcc.target/loongarch/stack-check-alloca-3.c b/gcc/testsuite/gcc.target/loongarch/stack-check-alloca-3.c
new file mode 100644
index 00000000000..e326ba9a092
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/stack-check-alloca-3.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16" } */
+/* { dg-require-effective-target supports_stack_clash_protection } */
+/* { dg-require-effective-target alloca } */
+/* { dg-skip-if "" { *-*-* } { "-fstack-check" } { "" } } */
+
+#define SIZE 100
+#include "stack-check-alloca.h"
+
+/* { dg-final { scan-assembler-times {st\.d\t\$r0,\$r3,104} 1 } } */
+
+/* Alloca is less than guard-size, 1 probe at the top of the new allocation.  */
diff --git a/gcc/testsuite/gcc.target/loongarch/stack-check-alloca-4.c b/gcc/testsuite/gcc.target/loongarch/stack-check-alloca-4.c
new file mode 100644
index 00000000000..b9f7572dedc
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/stack-check-alloca-4.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16" } */
+/* { dg-require-effective-target supports_stack_clash_protection } */
+/* { dg-require-effective-target alloca } */
+/* { dg-skip-if "" { *-*-* } { "-fstack-check" } { "" } } */
+
+#define SIZE 64 * 1024
+#include "stack-check-alloca.h"
+
+/* { dg-final { scan-assembler-times {stp*t*r*\.d\t\$r0,\$r\d{1,2},-8} 1 } } */
+
+/* Alloca is exactly one guard-size, 1 probe expected at top.  */
diff --git a/gcc/testsuite/gcc.target/loongarch/stack-check-alloca-5.c b/gcc/testsuite/gcc.target/loongarch/stack-check-alloca-5.c
new file mode 100644
index 00000000000..0ff6e493fec
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/stack-check-alloca-5.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16" } */
+/* { dg-require-effective-target supports_stack_clash_protection } */
+/* { dg-require-effective-target alloca } */
+/* { dg-skip-if "" { *-*-* } { "-fstack-check" } { "" } } */
+
+#define SIZE 65 * 1024
+#include "stack-check-alloca.h"
+
+/* { dg-final { scan-assembler-times {stp*t*r*\.d\t\$r0,\$r\d{1,2},-8} 1 } } */
+/* { dg-final { scan-assembler-times {stp*t*r*\.d\t\$r0,\$r3,1016} 1 } } */
+
+/* Alloca is more than one guard-page. 2 probes expected.  */
diff --git a/gcc/testsuite/gcc.target/loongarch/stack-check-alloca-6.c b/gcc/testsuite/gcc.target/loongarch/stack-check-alloca-6.c
new file mode 100644
index 00000000000..c5cf74fcb4f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/stack-check-alloca-6.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16" } */
+/* { dg-require-effective-target supports_stack_clash_protection } */
+/* { dg-require-effective-target alloca } */
+/* { dg-skip-if "" { *-*-* } { "-fstack-check" } { "" } } */
+
+#define SIZE 127 * 64 * 1024
+#include "stack-check-alloca.h"
+
+/* { dg-final { scan-assembler-times {stp*t*r*\.d\t\$r0,\$r\d{1,2},-8} 1 } } */
+
+/* Large alloca of a constant amount which is a multiple of a guard-size.
+   Loop expected with top probe.  */
diff --git a/gcc/testsuite/gcc.target/loongarch/stack-check-alloca.h b/gcc/testsuite/gcc.target/loongarch/stack-check-alloca.h
new file mode 100644
index 00000000000..8c75f6c0f70
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/stack-check-alloca.h
@@ -0,0 +1,15 @@
+
+/* Avoid inclusion of alloca.h, unavailable on some systems.  */
+#define alloca __builtin_alloca
+
+__attribute__((noinline, noipa))
+void g (char* ptr, int y)
+{
+  ptr[y] = '\0';
+}
+
+void f_caller (int y)
+{
+  char* pStr = alloca(SIZE);
+  g (pStr, y);
+}
diff --git a/gcc/testsuite/gcc.target/loongarch/stack-check-cfa-1.c b/gcc/testsuite/gcc.target/loongarch/stack-check-cfa-1.c
new file mode 100644
index 00000000000..f0c6877fc25
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/stack-check-cfa-1.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16 -funwind-tables" } */
+/* { dg-require-effective-target supports_stack_clash_protection } */
+/* { dg-skip-if "" { *-*-* } { "-fstack-check" } { "" } } */
+
+#define SIZE 128*1024
+#include "stack-check-prologue.h"
+
+/* { dg-final { scan-assembler-times {\.cfi_def_cfa_offset 131088} 1 } } */
+/* { dg-final { scan-assembler-times {\.cfi_def_cfa_offset 0} 1 } } */
+
+/* Checks that the CFA notes are correct for every sp adjustment.  */
diff --git a/gcc/testsuite/gcc.target/loongarch/stack-check-cfa-2.c b/gcc/testsuite/gcc.target/loongarch/stack-check-cfa-2.c
new file mode 100644
index 00000000000..c6e07bc561a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/stack-check-cfa-2.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16 -funwind-tables" } */
+/* { dg-require-effective-target supports_stack_clash_protection } */
+/* { dg-skip-if "" { *-*-* } { "-fstack-check" } { "" } } */
+
+#define SIZE 1280*1024 + 512
+#include "stack-check-prologue.h"
+
+/* { dg-final { scan-assembler-times {\.cfi_def_cfa_offset 1311248} 1 } } */
+/* { dg-final { scan-assembler-times {\.cfi_def_cfa_offset 0} 1 } } */
+
+/* Checks that the CFA notes are correct for every sp adjustment.  */
diff --git a/gcc/testsuite/gcc.target/loongarch/stack-check-prologue-1.c b/gcc/testsuite/gcc.target/loongarch/stack-check-prologue-1.c
new file mode 100644
index 00000000000..351bc1f61fd
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/stack-check-prologue-1.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16" } */
+/* { dg-require-effective-target supports_stack_clash_protection } */
+/* { dg-skip-if "" { *-*-* } { "-fstack-check" } { "" } } */
+
+#define SIZE 128
+#include "stack-check-prologue.h"
+
+/* { dg-final { scan-assembler-times {stp*t*r*\.d\t\$r0,\$r3,0} 0 } } */
+
+/* SIZE is smaller than guard-size so no probe expected.  */
diff --git a/gcc/testsuite/gcc.target/loongarch/stack-check-prologue-2.c b/gcc/testsuite/gcc.target/loongarch/stack-check-prologue-2.c
new file mode 100644
index 00000000000..6bba659a36d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/stack-check-prologue-2.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16" } */
+/* { dg-require-effective-target supports_stack_clash_protection } */
+/* { dg-skip-if "" { *-*-* } { "-fstack-check" } { "" } } */
+
+#define SIZE 63 * 1024
+#include "stack-check-prologue.h"
+
+/* { dg-final { scan-assembler-times {stp*t*r*.d\t\$r0,\$r3,0} 0 } } */
+
+/* SIZE is smaller than guard-size so no probe expected.  */
diff --git a/gcc/testsuite/gcc.target/loongarch/stack-check-prologue-3.c b/gcc/testsuite/gcc.target/loongarch/stack-check-prologue-3.c
new file mode 100644
index 00000000000..164956c3747
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/stack-check-prologue-3.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16" } */
+/* { dg-require-effective-target supports_stack_clash_protection } */
+/* { dg-skip-if "" { *-*-* } { "-fstack-check" } { "" } } */
+
+#define SIZE 64 * 1024
+#include "stack-check-prologue.h"
+
+/* { dg-final { scan-assembler-times {stp*t*r*\.d\t\$r0,\$r3,0} 1 } } */
+
+/* SIZE is equal to guard-size, 1 probe expected, boundary condition.  */
diff --git a/gcc/testsuite/gcc.target/loongarch/stack-check-prologue-4.c b/gcc/testsuite/gcc.target/loongarch/stack-check-prologue-4.c
new file mode 100644
index 00000000000..f53da6b0de9
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/stack-check-prologue-4.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16" } */
+/* { dg-require-effective-target supports_stack_clash_protection } */
+/* { dg-skip-if "" { *-*-* } { "-fstack-check" } { "" } } */
+
+#define SIZE 65 * 1024
+#include "stack-check-prologue.h"
+
+/* { dg-final { scan-assembler-times {stp*t*r*\.d\t\$r0,\$r3,0} 1 } } */
+
+/* SIZE is more than guard-size 1 probe expected.  */
diff --git a/gcc/testsuite/gcc.target/loongarch/stack-check-prologue-5.c b/gcc/testsuite/gcc.target/loongarch/stack-check-prologue-5.c
new file mode 100644
index 00000000000..c092317ea94
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/stack-check-prologue-5.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16" } */
+/* { dg-require-effective-target supports_stack_clash_protection } */
+/* { dg-skip-if "" { *-*-* } { "-fstack-check" } { "" } } */
+
+#define SIZE 127 * 1024
+#include "stack-check-prologue.h"
+
+/* { dg-final { scan-assembler-times {stp*t*r*\.d\t\$r0,\$r3,0} 1 } } */
+
+/* SIZE is more than 1x guard-size and remainder small than guard-size,
+   1 probe expected, unrolled, no loop.  */
diff --git a/gcc/testsuite/gcc.target/loongarch/stack-check-prologue-6.c b/gcc/testsuite/gcc.target/loongarch/stack-check-prologue-6.c
new file mode 100644
index 00000000000..70a2f53f6d7
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/stack-check-prologue-6.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16" } */
+/* { dg-require-effective-target supports_stack_clash_protection } */
+/* { dg-skip-if "" { *-*-* } { "-fstack-check" } { "" } } */
+
+#define SIZE 128 * 1024
+#include "stack-check-prologue.h"
+
+/* { dg-final { scan-assembler-times {stp*t*r*\.d\t\$r0,\$r3,0} 2 } } */
+
+/* SIZE is more than 2x guard-size and no remainder, unrolled, no loop.  */
diff --git a/gcc/testsuite/gcc.target/loongarch/stack-check-prologue-7.c b/gcc/testsuite/gcc.target/loongarch/stack-check-prologue-7.c
new file mode 100644
index 00000000000..e2df89acc77
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/stack-check-prologue-7.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16" } */
+/* { dg-require-effective-target supports_stack_clash_protection } */
+/* { dg-skip-if "" { *-*-* } { "-fstack-check" } { "" } } */
+
+#define SIZE 6 * 64 * 1024
+#include "stack-check-prologue.h"
+
+/* { dg-final { scan-assembler-times {stp*t*r*.d\t\$r0,\$r3,0} 1 } } */
+
+/* SIZE is more than 4x guard-size and no remainder, 1 probe expected in a loop
+   and no residual probe.  */
diff --git a/gcc/testsuite/gcc.target/loongarch/stack-check-prologue.h b/gcc/testsuite/gcc.target/loongarch/stack-check-prologue.h
new file mode 100644
index 00000000000..b7e06aedb81
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/stack-check-prologue.h
@@ -0,0 +1,5 @@
+int f_test (int x)
+{
+  char arr[SIZE];
+  return arr[x];
+}
diff --git a/gcc/testsuite/lib/target-supports.exp b/gcc/testsuite/lib/target-supports.exp
index 244fe2306f4..e4cfe3d3845 100644
--- a/gcc/testsuite/lib/target-supports.exp
+++ b/gcc/testsuite/lib/target-supports.exp
@@ -11256,7 +11256,8 @@ proc check_effective_target_supports_stack_clash_protection { } {
 
     if { [istarget x86_64-*-*] || [istarget i?86-*-*] 
 	  || [istarget powerpc*-*-*] || [istarget rs6000*-*-*]
-	  || [istarget aarch64*-**] || [istarget s390*-*-*] } {
+	  || [istarget aarch64*-**] || [istarget s390*-*-*]
+	  || [istarget loongarch64*-**] } {
 	return 1
     }
   return 0
@@ -11307,6 +11308,10 @@ proc check_effective_target_caller_implicit_probes { } {
 	return 1;
   }
 
+  if { [istarget loongarch64*-*-*] } {
+	return 1;
+  }
+
   return 0
 }
 
-- 
2.38.1

